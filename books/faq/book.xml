<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook XML V4.2-Based Extension//EN"
	"../../../share/xml/freebsd42.dtd" [
<!ENTITY % entities PUBLIC "-//FreeBSD//ENTITIES DocBook FreeBSD Entity Set//PT" "../../share/xml/entities.ent">
%entities;
<!ENTITY bibliography SYSTEM "../../share/xml/bibliography.xml">
]>

<!--
     The FreeBSD Documentation Project
     The FreeBSD Brazilian Portuguese Documentation Project

     Original revision: 1.456

     $FreeBSD: trunk/docs/pt_BR.ISO8859-1/books/faq/book.xml 165 2012-10-04 21:26:02Z ebrandi@fugspbr.org $
-->

<book lang='pt_br'>
  <bookinfo>
    <title>Perguntas mais freq&uuml;entes sobre FreeBSD 2.X, 3.X e
      4.X</title>

    <corpauthor>Projeto de Documentação do FreeBSD</corpauthor>

    <copyright>
      <year>1995</year>
      <year>1996</year>
      <year>1997</year>
      <year>1998</year>
      <year>1999</year>
      <year>2000</year>
      <year>2001</year>
      <year>2002</year>
      <holder>Projeto de Documentação do FreeBSD</holder>
    </copyright>

    &legalnotice;

    <releaseinfo>$FreeBSD: trunk/docs/pt_BR.ISO8859-1/books/faq/book.xml 165 2012-10-04 21:26:02Z ebrandi@fugspbr.org $</releaseinfo>

    <abstract>
      <para>Estas são as Perguntas Mais Freq&uuml;entes
	(<literal>FAQ</literal>) para as versões 2.X, 3.X e 4.X
	do FreeBSD.  Deve-se assumir que todos os assuntos aqui
	tratados são relevantes para FreeBSD 2.0.5 ou
	posterior, a não ser que o contrário esteja
	explicitamente denotado.  Todos os assuntos assinalados com
	&lt;XXX&gt; estão em processo de desenvolvimento.  Se
	você estiver interessado em ajudar este projeto, envie
	e-mail para &a.doc;.  A versão mais atualizada deste
	documento está sempre disponível no <ulink
	  url="../../../../index.html">servidor WWW do
	  FreeBSD</ulink>.  Também pode ser obtida como um
	único grande arquivo <ulink
	  url="book.html">HTML</ulink> via HTTP;  ou, como texto puro,
	ou nos formatos postscript, PDF, etc. no <ulink
	  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">servidor FTP do
	  FreeBSD</ulink>.  Você também pode querer
	<ulink url="../../../../search/index.html">realizar uma busca
	  nas Perguntas Mais Freq&uuml;entes
	  (<literal>FAQ</literal>)</ulink>.</para>
    </abstract>
  </bookinfo>

  <chapter id="introduction">
    <title>Introdução</title>

    <para>Bem vindo às Perguntas Mais Freq&uuml;entes
      (<literal>FAQ</literal>) para as versões 2.X à 4.X
      do FreeBSD!</para>

    <para>Como é de costume em Perguntas Mais Freq&uuml;entes
      (<literal>FAQ</literal>) da Usenet, este documento pretende
      cobrir as perguntas mais freq&uuml;entes relacionadas ao sistema
      operacional FreeBSD (e claro, respondê-las todas!).
      Embora originalmente tais documentos tivessem apenas a
      finalidade de reduzir a utilização da largura de
      banda da rede ao evitar que o mesmo tipo de pergunta antiga
      fosse sempre repetida, <literal>FAQs</literal> tornaram-se
      reconhecidamente uma fonte valiosa de
      informações.</para>

    <para>Inúmeros esforços foram feitos para tornar
      este <literal>FAQ</literal> o mais informativo possível;
      se você tiver alguma sugestão de como esse
      documento pode ser melhorado, sinta-se a vontade para enviar
      suas sugestões por e-mail para o &a.faq;.</para>

    <qandaset>
      <qandaentry>
	<question id="what-is-FreeBSD">
	  <para>O que é FreeBSD?</para>
	</question>

	<answer>
	  <para>Em síntese, FreeBSD é um sistema
	    operacional <foreignphrase>UN*X-like</foreignphrase> para
	    plataformas i386 e Alpha/AXP, baseado no
	    <quote>4.4BSD-Lite</quote> da Universidade da
	    Califórnia em Berkeley, com alguns aprimoramentos
	    adotados do <quote>4.4BSD-Lite2</quote>.  O FreeBSD
	    também é baseado, indiretamente, na
	    conversão de William Jolitz conhecida como
	    <quote>386BSD</quote> para a plataforma i386 do
	    <quote>Net/2</quote> da Universidade da Califórnia,
	    em Berkeley;  apesar que pouquíssimo código
	    originado do 386BSD ainda exista no FreeBSD.  Uma
	    descrição mais abrangente do que é
	    FreeBSD e como o sistema funciona, pode ser encontrada na
	    <ulink url="../../../../index.html">página
	      principal do FreeBSD</ulink>.</para>

	  <para>O FreeBSD é amplamente utilizado por empresas,
	    Provedores de Serviço Internet, pesquisadores,
	    profissionais de informática, estudantes e
	    usuários domésticos no mundo todo, para
	    trabalho, educação e
	    recreação.  Alguns destes exemplos podem ser
	    observados na <ulink
	      url="../../../../gallery/index.html">Galeria
	      FreeBSD,</ulink>.</para>

	  <para>Para informações mais detalhadas sobre o
	    FreeBSD, por favor, leia o <ulink
	      url="../handbook/index.html">&a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="FreeBSD-goals">
	  <para>Qual o objetivo do Projeto FreeBSD?</para>
	</question>

	<answer>
	  <para>O objetivo do Projeto FreeBSD é oferecer
	    <foreignphrase>software</foreignphrase> que possa ser
	    utilizado para qualquer finalidade e sem
	    obrigações anexadas à esse
	    código.  Muitos de nós investimos
	    significantemente no código (e no projeto como um
	    todo), e com certeza não nos importaríamos
	    em receber algum tipo de compensação
	    financeira neste momento ou qualquer outro no futuro, mas
	    ninguém no projeto insistirá nisso.
	    Acreditamos que a nossa primeira e mais importante
	    missão é oferecer código para toda e
	    qualquer pessoa, que possa ser utilizado para qualquer
	    propósito, de forma que esse código
	    ofereça o maior número possível de
	    benefícios e formas de uso.  Nós acreditamos
	    que este é um dos objetivos fundamentais do
	    <foreignphrase>Software</foreignphrase> Livre, e é
	    um dos quais nós apoiamos com entusiasmo.</para>

	  <para>O código fonte em nossa árvore que
	    é distribuído sob a <ulink
	      url="http://www.FreeBSD.org/copyright/COPYING">Licença
	      Pública Geral GNU (GPL)</ulink> ou sob a <ulink
	      url="http://www.FreeBSD.org/copyright/COPYING.LIB">
	      Licença Pública Geral de Bibliotecas GNU
	      (LGPL)</ulink> inclue, pode-se dizer, algumas
	    obrigações anexadas a ele;  contudo tais
	    restrições visam garantir o acesso livre a
	    esse código, e não o contrário.
	    Devido à complexidades adicionais que envolvem a
	    utilização comercial de software licenciado
	    sob GPL, nós procuramos substituir tais softwares
	    sob a mais relaxada <ulink
	      url="http://www.FreeBSD.org/copyright/freebsd-license.html">licença
	      de direito autoral FreeBSD</ulink> sempre que
	    possível;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bsd-license-restrictions">
	  <para>A licença FreeBSD tem alguma
	    restrição?</para>
	</question>

	<answer>
	  <para>Sim.  Entrentanto, essas restrições
	    não definem regras a respeito de como o
	    código deve ser utilizado, mas de como você
	    deve tratar o Projeto FreeBSD ao utilizar código
	    distribuído pelo mesmo.  Se você tem
	    sérias dúvidas sobre o licençiamento,
	    sinta-se a vontade para ler a <ulink
	      url="http://www.FreeBSD.org/copyright/freebsd-license.html">
	      licença</ulink>.  Para os meramente curiosos, a
	    licença pode ser resumida em:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Não alegue que o código foi escrito
		por você.</para>
	    </listitem>

	    <listitem>
	      <para>Não nos processe se o código
		falhar.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="replace-current-OS">
	  <para>O FreeBSD pode substituir meu sistema operacional
	    atual?</para>
	</question>

	<answer>
	  <para>Para maioria das pessoas, sim.  Mas essa não
	    é uma pergunta tão simples assim.</para>

	  <para>A maioria das pessoas, na verdade, não utiliza
	    um sistema operacional.  As aplicações
	    utilizadas pelos usuários é que realmente
	    usam o sistema operacional.  O FreeBSD é projetado
	    de forma a oferecer um ambiente robusto e completo para as
	    aplicações.  Suporta uma enorme variedade de
	    navegadores internet, de suítes de
	    escritório, clientes de e-mail, programas de
	    manipulação gráfica, ambientes de
	    programação, servidores e serviços de
	    rede, e praticamente tudo mais que você pode
	    desejar.  A maioria destas aplicações podem
	    ainda ser gerenciadas através da <ulink
	      url="http://www.freebsd.org/ports/">Coleção
	      de <literal>Ports</literal></ulink>.</para>

	  <para>Em circunstâncias nas quais precise usar uma
	    aplicação disponível apenas para um
	    determinado sistema operacional, não é
	    possível substituir aquele sistema operacional.
	    Entretanto, há uma boa chance que alguma
	    aplicação similar à que você
	    precisa, exista para FreeBSD.  Se você quer ter,
	    desde um sólido conjunto de
	    aplicações para escritório,
	    até um robusto e altamente escalável
	    servidor Internet, ou simplesmente uma
	    estação de trabalho confiável, onde
	    você possa realizar seu trabalho sem
	    interrupções, FreeBSD provavelmente vai
	    suprir todas as suas necessidades.  Inúmeras
	    pessoas pelo mundo todo, desde usuários novatos
	    à administradores de sistemas UNIX experientes usam
	    FreeBSD como seu único sistema operacional para
	    <foreignphrase>desktop</foreignphrase>.</para>

	  <para>Se você está migrando para FreeBSD a
	    partir de algum outro ambiente UNIX, provavelmente
	    já sabe quase tudo o que precisa pra começar
	    a se envolver com o sistema.  Entretanto, se o seu
	    histórico em computação envolveu
	    somente sistemas operacionais baseados em ambientes
	    gráficos como Windows e antigos Mac OS, será
	    necessário investir algum tempo a mais aprendendo a
	    maneira UNIX de fazer as coisas.  Este
	    <literal>FAQ</literal> e o <ulink
	      url="../handbook/index.html">&a.ptbr.p.handbook;</ulink>
	    são excelentes formas de começar sua
	    jornada.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="why-called-FreeBSD">
	  <para>Por que o sistema se chama FreeBSD?</para>
	</question>

	<answer>
	  <itemizedlist>
	    <listitem>
	      <para>Pode ser utilizado sem nenhum encargo
		monetário, inclusive para uso comercial.</para>
	    </listitem>

	    <listitem>
	      <para>O código fonte completo do sistema
		operacional é livremente distribuído, e
		pode ser adquirido gratuitamente.  O menor
		número possível de
		restrições foram colocadas sobre o uso
		do sistema, sua distribuição e sua
		incorporação à outro projeto
		(comercial ou não).</para>
	    </listitem>

	    <listitem>
	      <para>Qualquer pessoa que tiver feito alguma
		correção ou aprimoramento do
		código do sistema pode livremente enviar suas
		alterações e ter seu código
		adicionado à árvore de código
		fonte do sistema (obviamente sujeito a prévias
		análises).</para>
	    </listitem>
	  </itemizedlist>

	  <para>É importante ressaltar que a palavra de origem
	    inglesa <quote>free</quote> em português pode ser
	    traduzida como <quote>livre</quote> e
	    <quote>gratuito</quote>.  Além disso, a palavra
	    <quote>free</quote> está sendo usada aqui com dois
	    significados: <quote>sem custo</quote> e <quote>você
	      pode fazer o que quiser</quote>.  <quote>Free</quote> no
	    nome do sistema operacional remete aos dois significados
	    da palavra.  O sistema pode ser utilizado <quote>sem
	      nenhum custo</quote>, e pode ser utilizado <quote>da
	      forma que você quiser</quote>.  Exceto por algumas
	    poucas coisinhas que você não pode fazer com
	    o FreeBSD (por exemplo, fingir que foi você quem o
	    escreveu), você pode realmente fazer o que bem
	    entender com o sistema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="latest-version">
	  <para>Qual a versão mais recente do FreeBSD?</para>
	</question>

	<answer>
	  <para>A versão <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">&rel.current;</ulink>
	    é a versão <emphasis>RELEASE</emphasis> mais
	    recente;  lançada em &rel.current.date;.  Esta
	    também é a versão
	    <emphasis>STABLE</emphasis> mais recente.</para>

	  <para>Resumidamente, <emphasis>-STABLE</emphasis> é a
	    série voltada para Provedores de Serviço de
	    Internet, usuários corporativos, ou qualquer
	    usuário que deseje estabilidade e um número
	    mínimo de alterações e novas
	    características adotadas do
	    <foreignphrase>snapshot</foreignphrase>
	    <emphasis>-CURRENT</emphasis>.  Lançamentos podem
	    vir de qualquer um dos ramos de desenvolvimento;  a
	    série <emphasis>-CURRENT</emphasis>, todavia,
	    deveria ser utilizada apenas por usuários
	    preparados para um ambiente em constante
	    modificação, instável em muitas de
	    suas características e extremamente sem garantias
	    (ao menos, quando comparado ao
	    <emphasis>-STABLE</emphasis>).</para>

	  <para>Lançamentos são realizados <link
	      linkend="release-freq">de alguns em alguns meses</link>.
	    Muitos usuários mantém o código fonte
	    de seus sistemas em mais sincronia com a árvore de
	    desenvolvimento do FreeBSD (veja as perguntas sobre <link
	      linkend="current">FreeBSD-CURRENT</link> e <link
	      linkend="stable">FreeBSD-STABLE</link>) que isto,  fazer
	    isto é uma demonstração de interesse
	    e compromisso visto que o código fonte sofre
	    constantes modificações.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="current">
	  <para>O que é FreeBSD-CURRENT?</para>
	</question>

	<answer>
	  <para><ulink
	      url="../handbook/cutting-edge.html#CURRENT">FreeBSD-CURRENT</ulink>
	    é a versão de desenvolvimento do sistema
	    operacional, que brevemente se tornará a
	    série 5.0-<literal>RELEASE</literal>.  Exatamente
	    por ser uma série de desenvolvimento, e portanto
	    sem garantias de estabilidade, o uso desse sistema
	    operacional é de interesse exclusivo de
	    desenvolvedores que trabalham no sistema, usuários
	    extremamente experientes que acompanham e analisam
	    (testam) o novo sistema ou daqueles que o fazem por
	    <foreignphrase>hobby</foreignphrase>.  Veja a <ulink
	      url="../handbook/cutting-edge.html#CURRENT">seção
	      relevante</ulink> no <ulink
	      url="../handbook/index.html">&a.ptbr.p.handbook;</ulink>.</para>

	  <para>Se você não tem familiaridade com o
	    sistema operacional, não é um usuário
	    experiente ou não consegue distinguir a
	    diferença entre um problema de verdade e um
	    problema temporário, então é
	    desaconselhável que você use o
	    FreeBSD-CURRENT.  Essa série, as vezes, evolui de
	    forma extremamente rápida, e pode se tornar
	    extremamente instável e subutilizável por
	    vários dias seguidos.  Usuários do
	    FreeBSD-CURRENT devem ser capazes de analisar qualquer
	    problema no sistema, e apenas relatar a falha se o
	    problema tratar-se de um erro ou um engano no
	    desenvolvimento do mesmo ao invés de
	    <quote>pequenos problemas temporários de
	      instabilidade
	      (<foreignphrase>glitches</foreignphrase>)</quote>.
	    Perguntas sobre o porquê de <quote>make world
	      produzir erros a respeito de grupos</quote> são
	    devidamente ignoradas ou escrachadas na lista de
	    discussão da série -CURRENT.</para>

	  <para>Diariamente, <ulink
	      url="../../../../releases/snapshots.html"><foreignphrase>snapshots</foreignphrase></ulink>
	    são lançados baseados no estado atual de
	    desenvolvimento dos ramos -CURRENT e -STABLE.  Atualmente,
	    distribuições ocasionais de
	    <foreignphrase>snapshots</foreignphrase> estão
	    sendo disponibilizadas.  Os objetivos por trás do
	    lançamento de cada
	    <foreignphrase>snapshot</foreignphrase> são:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Testar a versão mais recente do programa de
		instalação.</para>
	    </listitem>

	    <listitem>
	      <para>Dar a oportunidade para aqueles que querem usar o
		-CURRENT ou o -STABLE - mas não tem tempo ou
		não tem uma conexão Internet
		rápida o suficiente para estarem diariamente
		sincronizados com a versão mais atualizada do
		código no projeto.</para>
	    </listitem>

	    <listitem>
	      <para>Manter um ponto de referência fixo, em
		relação ao código em
		desenvolvimento e o código disponível
		até então, para o caso de nós
		seriamente <quote>quebrarmos</quote> alguma coisa.
		(Embora CVS normalmente previna que desastres
		horríveis como este aconteçam :)</para>
	    </listitem>

	    <listitem>
	      <para>Garantir que todas as novas características
		e funções do sistema que precisem ser
		testadas, tenham o maior número possível
		de pessoas potencialmente testando-as.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Sob nenhuma circunstância, nenhum
	    <foreignphrase>snapshot</foreignphrase> -CURRENT pode ser
	    considerado software de <quote>qualidade de
	      produção</quote> para qualquer que seja o
	    propósito, e por mais maduro que o código
	    -CURRENT atual possa parecer.  Se a intenção
	    é usar um sistema estável e completamente
	    testado, você deverá usar apenas
	    lançamentos, ou
	    <foreignphrase>snapshots</foreignphrase> do ramo
	    -STABLE.</para>

	  <para>Os <foreignphrase>snapshots</foreignphrase>
	    lançados podem ser diretamente acessados em <ulink
	      url="ftp://current.FreeBSD.org/pub/FreeBSD/">
	      ftp://current.FreeBSD.org/pub/FreeBSD/</ulink> para a
	    série 5.0-CURRENT e em <ulink
	      url="ftp://releng4.FreeBSD.org/pub/FreeBSD">
	      releng4.FreeBSD.org</ulink> para
	    <foreignphrase>snapshots</foreignphrase> da série
	    4-STABLE.  <foreignphrase>Snapshots</foreignphrase> para a
	    série 3-STABLE não estão sendo
	    produzidos na data em que este documento foi escrito (Maio
	    de 2000).</para>

	  <para>Normalmente, os snapshots são gerados uma vez
	    ao dia, para todas as séries em desenvolvimento
	    ativo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="stable">
	  <para>Qual o conceito por trás do
	    FreeBSD-STABLE?</para>
	</question>

	<answer>
	  <para>Nos primórdios do projeto quando o FreeBSD
	    2.0.5 foi lançado, a árvore de
	    desenvolvimento do sistema foi dividida em dois ramos.  Um
	    ramo foi chamado <ulink
	      url="../handbook/current-stable.html#STABLE">-STABLE</ulink>
	    e o outro <ulink
	      url="../handbook/current-stable.html#CURRENT">-CURRENT</ulink>.
	    O FreeBSD-STABLE é direcionado para Provedores de
	    Serviços de Internet e para outros empreendimentos
	    comerciais que não pretendem conviver com
	    mudanças bruscas ou testar novas
	    características experimentais do sistema.  Ele
	    recebe apenas código que tenha sido totalmente
	    testado, correções de problemas e outras
	    pequenas inovações incrementais.  O
	    FreeBSD-CURRENT, por outro lado, tem sido uma linha sem
	    interrupções visando ao 5.0-RELEASE (e
	    além) desde o lançamento 2.0.  Se uma
	    pequena ilustração em arte ASCII ajudasse,
	    isto seria o que pareceria:</para>


          <programlisting>                 2.0
                  |
                  |
                  |  [2.1-STABLE]
 *BRANCH*       2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [2.1-STABLE termina]
                  |                            (Mar 1997)
                  |
                  |
                  |  [2.2-STABLE]
 *BRANCH*       2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [fim]
                  |       (Mar 1997)    (Out 97) (Abr 98) (Jul 98) (Dez 98)
                  |
                  |
               3.0-SNAPs  (inicio Q1 1997)
                  |
                  |
               3.0-RELEASE (Out 1998)
                  |
                  |  [3.0-STABLE]
 *BRANCH*      3.1-RELEASE  (Fev 1999) -&gt; 3.2 -&gt; 3.3 -&gt; 3.4 -&gt; 3.5 -&gt; 3.5.1
                  |                     (Mai 1999) (Set 1999) (Dez 1999) (Jun 2000) (Jul 2000)
                  |
                  |  [4.0-STABLE]
 *BRANCH*        4.0  (Mar 2000) -&gt; 4.1 -&gt; 4.1.1 -&gt; 4.2 -&gt; 4.3 -&gt; 4.4 -&gt; ... Lançamentos 4.x futuro ...
                  |
                  |              (Jul 2000)   (Set 2000)   (Nov 2000)
                 \|/
                  +
          [5.0-CURRENT continua]</programlisting>


	  <para>O ramo 2.2-STABLE saiu de produção com o
	    lançamento 2.2.8.  O ramo 3-STABLE saiu de
	    produção com o lançamento 3.5.1, que
	    foi também o último -RELEASE 3.X.  As
	    únicas modificações ainda realizadas
	    em quaisquer destes ramos são praticamente
	    relacionados apenas à correções de
	    segurança.</para>

	  <para>O 4-STABLE é o ramo -STABLE em desenvolvimento
	    ativo.  A versão mais recente da série
	    4-STABLE é &rel.current;-RELEASE, lançada em
	    &rel.current.date;.</para>

	  <para>O ramo 5-CURRENT está lentamente progredindo
	    para o que se tornará o FreeBSD 5.0-RELEASE e
	    além.  Veja <link linkend="current">O que é
	      FreeBSD-CURRENT?</link> para obter mais
	    informações sobre este ramo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="release-freq">
	  <para>Quando são realizados lançamentos
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O &a.re; lança uma nova versão do
	    FreeBSD, em média, a cada 4 meses.  As datas de
	    lançamento são anunciadas com uma certa
	    antecedência, de forma que os desenvolvedores
	    trabalhando no sistema saibam quando seus projetos
	    precisam estar terminados e testados.  Um período
	    de testes antecede cada novo lançamento, de forma a
	    garantir que a adição de novas
	    características não comprometa a
	    estabilidade do lançamento.  Muitos usuários
	    consideram tais precauções uma das
	    principais vantagens do projeto FreeBSD, mesmo admitindo
	    que, as vezes, esperar que as novidades sejam adotadas
	    pelo ramo -STABLE possa ser um pouco frustante.</para>

	  <para>Mais informações sobre o processo de
	    engenharia de lançamento (incluindo a
	    programação de novos lançamentos)
	    podem ser obtidas nas páginas de <ulink
	      url="http://www.FreeBSD.org/releng/index.html">engenharia
	      de lançamento</ulink> no sítio WWW do
	    FreeBSD.</para>

	  <para>Para as pessoas que precisam, ou desejam um pouco mais
	    de emoção,
	    <foreignphrase>snapshots</foreignphrase> binários
	    são feitos diariamente como discutido acima.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="responsible">
	  <para>Quem é responsável pelo FreeBSD?</para>
	</question>

	<answer>
	  <para>As principais decisões relacionadas ao Projeto
	    FreeBSD, como os objetivos e direção geral
	    do projeto, e quem tem permissão para adicionar
	    código à árvore de código,
	    são tomadas por um <ulink
	      url="../../articles/contributors/article.html#STAFF-CORE">grupo
	      central (<literal>core team</literal>)</ulink> composto
	    de 9 pessoas.  Existe um grupo muito maior, composto de
	    mais de 200 desenvolvedores, denominados <ulink
	      url="../../articles/contributors/article.html#STAFF-COMMITTERS"><foreignphrase>committers</foreignphrase></ulink>,
	    que tem autorização para fazer
	    alterações diretamente na árvore de
	    código do FreeBSD.</para>

	  <para>Entretanto, a maioria das alterações
	    não triviais são previamente discutidas nas
	    <link linkend="mailing"> listas de
	      discussões</link>, e não existe
	    restrição quanto a quem pode participar das
	    discussões.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="where-get">
	  <para>Onde posso obter o FreeBSD?</para>
	</question>

	<answer>
	  <para>Todo lançamento significativo do FreeBSD
	    está disponível via FTP anônimo no
	    <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/">sítio
	      FTP do Projeto FreeBSD</ulink>:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Para obter o lançamento 3.X-STABLE
		corrente, 3.5.1-RELEASE, veja <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.5.1-RELEASE/">diretório
		  3.5.1-RELEASE</ulink>.</para>
	    </listitem>

	    <listitem>
	      <para>O lançamento 4-STABLE corrente,
		&rel.current;-RELEASE pode ser encontrado no <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/&rel.current;-RELEASE/">diretório
		  &rel.current;-RELEASE</ulink>.</para>
	    </listitem>

	    <listitem>
	      <para><ulink
		  url="ftp://releng4.FreeBSD.org/pub/FreeBSD/"><foreignphrase>Snapshots</foreignphrase>
		  4.X</ulink> são normalmente criados uma vez
		ao dia.</para>
	    </listitem>

	    <listitem>
	      <para>Lançamentos <ulink
		  url="ftp://current.FreeBSD.org/pub/FreeBSD/"><foreignphrase>Snapshot</foreignphrase>
		  5.0</ulink> são feitos uma vez ao dia no ramo
		<link linkend="current">-CURRENT</link>, útil
		apenas tanto para aqueles que gostam de viver no
		limite quanto para aqueles que precisam usar a
		versão mais recente possível com todas
		as últimas características; sejam pessoas
		conduzindo testes ou desenvolvedores.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Informação sobre como obter o FreeBSD em
	    CD, DVD, e outras mídias, pode ser encontrada no
	    <ulink
	      url="../handbook/mirrors.html">&a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="access-pr">
	  <para>Como eu acesso o banco de dados de Relatórios
	    de Problemas?</para>
	</question>

	<answer>
	  <para>A base de dados de Relatórios de Problemas
	    é um banco de pedidos de alterações
	    realizados pelos usuários.  Todos os pedidos de
	    alteração já realizados podem ser
	    consultados (ou novos submetidos) através de
	    nossas interfaces PR WWW para <ulink
	    url="http://www.FreeBSD.org/send-pr.html">submeter
	    (novos pedidos)</ulink> e <ulink
	      url="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query">consultar
	      (já submetidos)</ulink>.
	    O comando &man.send-pr.1; também pode ser usado
	    para submeter relatórios de problema e pedidos
	    de alteração por meio de correio
	    eletrônico.</para>

	  <para>Antes de enviar um relatório de problema, por
	    favor, leia o artigo <ulink
	      url="../../articles/problem-reports/article.html">Escrevendo
	      Relatórios de Problemas para o FreeBSD</ulink>,
	    que dá boas dicas de como escrever um bom
	    relatório de problema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="become-web-mirror">
	  <para>Como eu me torno um espelho do sítio WWW
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Existam várias formas de espelhar o
	    sítio WWW do FreeBSD.</para>

	  <itemizedlist>
	    <listitem>
	      <para>Você pode obter os arquivos já
		formatados a partir de um servidor CVSup FreeBSD
		usando o aplicativo <filename
		  role="package">net/cvsup</filename>.  O arquivo
		<filename>/usr/share/examples/cvsup/www-supfile</filename>
		oferece um exemplo de configuração do
		CVSup para espelhar o servidor WWW do projeto
		FreeBSD.</para>
	    </listitem>

	    <listitem>
	      <para>Você pode obter o código fonte do
		sítio WWW do projeto FreeBSD a partir de
		qualquer servidor FTP do projeto usando sua ferramento
		de espelhamento ftp favorita.  Considere que estes
		fontes devem ser processados para publicá-los
		em formato WWW tradicional.  Você pode
		começar a espelhar o projeto a partir de <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/www">ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/www</ulink>.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="other-info-sources">
	  <para>Que outras fontes de informações sobre o
	    FreeBSD existem?</para>
	</question>

	<answer>
	  <para>Por gentileza, queira verificar a lista de <ulink
	      url="http://www.FreeBSD.org/docs.html">Documentação</ulink>
	    no sítio WWW principal <ulink
	      url="http://www.FreeBSD.org">FreeBSD</ulink>.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="support">
    <title>Documentação e Suporte</title>

    <qandaset>
      <qandaentry>
	<question id="books">
	  <para>Quais bons livros existem sobre FreeBSD?</para>
	</question>

	<answer>
	  <para>O projeto FreeBSD produz um grande número de
	    documentos disponíveis em <ulink
	      url="http://www.freebsd.org/docs.html">http://www.FreeBSD.org/docs.html</ulink>.
	    Além destes, outros livros recomendados são
	    referenciados nas Bibliografias disponíveis ao
	    final deste <literal>FAQ</literal> e do
	    &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="doc-formats">
	  <para>A documentação está
	    disponível em outros formatos, como texto puro
	    (ASCII) ou Postscript?</para>
	</question>

	<answer>
	  <para>Claro.  A documentação pode ser obtida
	    em uma variedade de formatos e opções de
	    compressão no servidor FTP do FreeBSD, sob o
	    diretório <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">/pub/FreeBSD/doc/</ulink>.</para>

	  <para>A documentação é organizada em
	    diversas categorias, como:</para>

	  <itemizedlist>
	    <listitem>
	      <para>O nome do documento, como <literal>faq</literal>
		ou <literal>&a.ptbr.p.handbook;</literal>.</para>
	    </listitem>

	    <listitem>
	      <para>A codificação e língua do
		conteúdo do documento.  Tal
		categorização é baseada nos nomes
		de localização, que podem ser
		encontrados sob <filename>/usr/share/locale</filename>
		no seu FreeBSD.  Atualmente existem documentos nas
		seguintes línguas e
		codificações:</para>

	      <informaltable frame="none">
		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Nome</entry>

		      <entry>Significado</entry>
		    </row>
		  </thead>

		  <tbody>

		    <row>
		      <entry><literal>en_US.ISO8859-1</literal></entry>

		      <entry>Inglês Americano</entry>
		    </row>

		    <row>
		      <entry><literal>de_DE.ISO8859-1</literal></entry>

		      <entry>Alemão</entry>
		    </row>

		    <row>
		      <entry><literal>es_ES.ISO8859-1</literal></entry>

		      <entry>Espanhol</entry>
		    </row>


		    <row>
		      <entry><literal>fr_FR.ISO8859-1</literal></entry>

		      <entry>Francês</entry>
		    </row>

		    <row>
		      <entry><literal>ja_JP.eucJP</literal></entry>

		      <entry>Japonês (codificação
			EUC)</entry>
		    </row>

		    <row>
		      <entry><literal>ru_RU.KOI8-R</literal></entry>

		      <entry>Russo (codificação
			KOI8-R)</entry>
		    </row>
		    <row>
		      <entry><literal>zh_TW.Big5</literal></entry>

		      <entry>Chinês (codificação
			Big5)</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>

	      <note>
		<para>Alguns documentos podem não estar
		  disponíveis em todas as
		  línguas.</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>Formato da documentação.  A
		documentação é produzida em
		vários formatos.  Cada qual com suas vantagens
		e desvantagens.  Alguns formatos são mais
		apropriados para leitura on-line, enquanto outros
		são mais agradéveis estéticamente
		em formato impresso.  Disponibilizar a
		documentação em todos estes formatos,
		garante que os leitores poderão sempre ler os
		trechos de seu interesse, tanto no monitor do seu
		computador quanto em papel impresso.  Atualmente os
		formatos disponíveis são:</para>

	      <informaltable frame="none">
		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Formato</entry>

		      <entry>Significado</entry>
		    </row>
		  </thead>

		  <tbody>
		    <row>
		      <entry><literal>html-split</literal></entry>

		      <entry>Uma série de pequenos documentos
			HTML, devidamente ligados.</entry>
		    </row>

		    <row>
		      <entry><literal>html</literal></entry>

		      <entry>Um único grande arquivo HTML
			contendo todo o documento.</entry>
		    </row>

		    <row>
		      <entry><literal>pdb</literal></entry>

		      <entry>Formato de banco de dados pra Palm Pilot,
			para ser usado com o visualizador <ulink
			  url="http://www.iSilo.com/">iSilo</ulink>.</entry>
		    </row>

		    <row>
		      <entry><literal>pdf</literal></entry>

		      <entry>PDF (Formato de Documento
			Portável) da Adobe</entry>
		    </row>

		    <row>
		      <entry><literal>ps</literal></entry>

		      <entry>Postscript</entry>
		    </row>

		    <row>
		      <entry><literal>rtf</literal></entry>

		      <entry>RTF (Formato de Texto Enriquecido) da
			Microsoft<footnote>
			  <para>A númeração de
			    página não é
			    automaticamente atualizada quando este
			    tipo de arquivo é aberto no Word.
			    Digite <keycombo
			      action="simul"><keycap>CTRL</keycap><keycap>A</keycap></keycombo>,
			    <keycombo
			      action="simul"><keycap>CTRL</keycap><keycap>END</keycap></keycombo>,
			    <keycap>F9</keycap> depois de abrir o
			    documento no Word, para atualizar a
			    numeração das
			    páginas.</para>
			</footnote>
		      </entry>
		    </row>

		    <row>
		      <entry><literal>txt</literal></entry>

		      <entry>Texto puro</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>
	    </listitem>

	    <listitem>
	      <para>As técnicas de compressão e
		empacotamento dos arquivos.  Atualmente, 3 destes
		formatos estão em uso:</para>

	      <orderedlist>
		<listitem>
		  <para>Para o formato <literal>html-split</literal>,
		    os arquivos são todos empacotados com
		    &man.tar.1;.  O resultado é um arquivo
		    <literal>.tar</literal> que é
		    posteriormente comprimido usando as
		    técnicas de compressão detalhadas a
		    seguir.</para>
		</listitem>

		<listitem>
		  <para>Todos os outros formatos geram apenas um
		    arquivo, nomeado
		    <filename>book.<replaceable>formato</replaceable></filename>
		    (por exemplo, <filename>book.pdb</filename>,
		    <filename>book.html</filename>, e outros).</para>

		  <para>Estes arquivos são, então
		    comprimidos utilizando três técnicas
		    de compressão:</para>

		  <informaltable frame="none">
		    <tgroup cols="2">
		      <thead>
			<row>
			  <entry>Tipo</entry>

			  <entry>Descrição</entry>
			</row>
		      </thead>

		      <tbody>
			<row>
			  <entry><literal>zip</literal></entry>

			  <entry>Formato Zip.  Se você quiser
			    descomprimir este formato no FreeBSD,
			    será necessário instalar o
			    <literal>port</literal> <filename
			      role="package">archivers/unzip</filename>
			    antes.</entry>
			</row>

			<row>
			  <entry><literal>gz</literal></entry>

			  <entry>Formato GNU Zip.  Para descomprimir
			    estes arquivos, use o comando
			    &man.gunzip.1; que faz parte do
			    FreeBSD.</entry>
			</row>

			<row>
			  <entry><literal>bz2</literal></entry>

			  <entry>Formato BZip2.  Esse formato é
			    menos popular que os outros, mas
			    geralmente produz arquivos menores.
			    Instale o <literal>port</literal>
			    <filename
			      role="package">archivers/bzip2</filename>
			    para descomprimir arquivos deste
			    formato.</entry>
			</row>
		      </tbody>
		    </tgroup>
		  </informaltable>

		  <para>Portanto, o &a.ptbr.p.handbook; em formato
		    Postscript comprimido com o BZip2 será
		    armazenado como <filename>book.ps.bz2</filename>
		    sob o diretório
		    <filename>handbook/</filename>.</para>
		</listitem>

		<listitem>
		  <para>A documentação formatada
		    está disponível ainda como um pacote
		    FreeBSD.</para>
		</listitem>
	      </orderedlist>
	    </listitem>
	  </itemizedlist>

	  <para>Após escolher o formato e o mecanismo de
	    compressão, você deve decidir se vai ou
	    não pegar o documento em formato de
	    <emphasis>pacote</emphasis> FreeBSD.</para>

	  <para>A vantagem de baixar e instalar os pacotes é
	    que a documentação pode então ser
	    gerenciada usando os comandos de gerenciamento de pacotes
	    FreeBSD, como &man.pkg.add.1; e &man.pkg.delete.1;.</para>

	  <para>Se decidir baixar e instalar o pacote, então
	    você deve conhecer o nome do arquivo antes de
	    começar.  Os arquivos de
	    documentação-como-pacotes estão
	    estocados em um diretório chamado
	    <filename>packages</filename>.  Cada arquivo de pacote
	    segue o padrão de nome
	    <filename><replaceable>document-name</replaceable>.<replaceable>lang</replaceable>.<replaceable>encoding</replaceable>.<replaceable>format</replaceable>.tgz</filename>.</para>

	  <para>Por exemplo, o <literal>FAQ</literal>, em
	    língua Inglesa e formato PDF, estará no
	    pacote de nome
	    <filename>faq.en_US.ISO8859-1.pdf.tgz</filename>.</para>

	  <para>Sabendo isto, você pode usar o seguinte comando
	    pra instalar o pacote contendo o <literal>FAQ</literal> na
	    língua Inglesa e formato PDF:</para>

	  <screen>&prompt.root; <userinput>pkg_add
	      ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/packages/faq.en_US.ISO8859-1.pdf.tgz</userinput></screen>

	  <para>Depois disso, você pode usar o &man.pkg.info.1;
	    pra determinar onde o documento foi instalado.</para>

	  <screen>&prompt.root; <userinput>pkg_info -f faq.en_US.ISO8859-1.pdf</userinput>
Information for faq.en_US.ISO8859-1.pdf:

Packing list:
        Package name: faq.en_US.ISO8859-1.pdf
        CWD to /usr/share/doc/en_US.ISO8859-1/books/faq
File: book.pdf
        CWD to .
File: +COMMENT (ignored)
File: +DESC (ignored)</screen>

	  <para>Como pode ver, <filename>book.pdf</filename>
	    terá sido instalado sob
	    <filename>/usr/share/doc/en_US.ISO8859-1/books/faq</filename>.</para>

	  <para>Se você preferir não usar pacotes,
	    será necessário baixar os arquivos
	    comprimidos, depois descomprimí-los e copiar os
	    documentos apropriados para os lugares corretos.</para>

	  <para>Por exemplo, a versão do <literal>FAQ</literal>
	    dividido em vários arquivos HTML, comprimido usando
	    &man.gzip.1;, pode ser encontrado no arquivo
	    <filename>doc/en_US.ISO8859-1/books/faq/book.html-split.tar.gz</filename>.
	    Para baixar e descomprimir aquele arquivo, você
	    deveria fazer o seguinte.</para>

	  <screen>&prompt.root; <userinput>fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.gz</userinput>
&prompt.root; <userinput>gzip -d book.html-split.tar.gz</userinput>
&prompt.root; <userinput>tar xvf book.html-split.tar</userinput></screen>

	  <para>Será criada, então, uma série de
	    arquivos <filename>.html</filename>.  O principal arquivo
	    é chamado <filename>index.html</filename> contendo
	    o índice, material introdutório e links para
	    outras partes do documento.  Posteriormente, você
	    pode copiar ou mover esses arquivos pra onde você
	    quiser.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mailing">
	  <para>Onde posso obter informações sobre as
	    listas de discussão FreeBSD?</para>
	</question>

	<answer>
	  <para>Você pode encontrar uma vasta gama de
	    informações na <ulink
	      url="../handbook/eresources.html#ERESOURCES-MAIL">seção
	      do &a.ptbr.p.handbook; sobre listas de
	      discussão</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="y2k">
	  <para>Onde encontro informações sobre a
	    compatibilidade FreeBSD ano 2000 (FreeBSD Y2K)?</para>
	</question>

	<answer>
	  <para>Informações completas na <ulink
	      url="../../../../y2kbug.html">página FreeBSD
	      Y2K</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="newsgroups">
	  <para>Que grupos de notícias (<foreignphrase>news
	      groups</foreignphrase>) existem sobre o FreeBSD?</para>
	</question>

	<answer>
	  <para>Informações completas podem ser
	    encontradas na <ulink
	      url="../handbook/eresources-news.html">seção
	      do &a.ptbr.p.handbook; sobre grupos de notícias
	      (<foreignphrase>newsgroups</foreignphrase>)</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="irc">
	  <para>Existem canais de bate-papo retransmitido via Internet
	    (<acronym>IRC</acronym>) FreeBSD?</para>
	</question>

	<answer>
	  <para>Sim, a maioria das grandes redes de bate-papo
	    retransmitido via Internet (<acronym>IRC</acronym>) tem um
	    canal de bate-papo sobre FreeBSD:</para>

	  <itemizedlist>
	    <listitem>
	      <para>O canal <literal>#FreeBSD</literal> na <ulink
		  url="http://www.efnet.org/index.php">EFNet</ulink>
		é essencialmente um fórum sobre FreeBSD,
		mas não entre no canal se você procura
		suporte técnico, nem se você está
		procurando uma maneira de evitar a leitura de
		páginas de manual ou fazer suas próprias
		pesquisas.  Este é essencialmente um canal de
		bate-papo geral.  Assuntos como sexo, esportes ou
		armas nucleares são tão comuns quanto
		FreeBSD no canal.  Lembre-se, Você Foi Avisado!
		Para conectar-se, use o servidor
		<hostid>irc.chat.org</hostid>.</para>
	    </listitem>

	    <listitem>
	      <para>O canal <literal>#FreeBSDhelp</literal> na <ulink
		  url="http://www.efnet.org/index.php">EFNet</ulink>
		é dedicado a suporte e auxilio de
		usuários de FreeBSD.  Os participantes neste
		canal são bem mais receptivos a perguntas que
		os do canal <literal>#FreeBSD</literal>.</para>
	    </listitem>

	    <listitem>
	      <para>O canal <literal>#FreeBSD</literal> na <ulink
		  url="http://www.dal.net/">DALNET</ulink> pode ser
		acessado em <hostid>irc.dal.net</hostid> nos Estados
		Unidos, e <hostid>irc.eu.dal.net</hostid> na
		Europa.</para>
	    </listitem>

	    <listitem>
	      <para>O canal <literal>#FreeBSD</literal> na <ulink
		  url="http://www.undernet.org/">UNDERNET</ulink> pode
		ser acessado em <literal>us.undernet.org</literal> nos
		Estados Unidos, e <literal>eu.undernet.org</literal>
		na Europa.  Partindo do princípio que esse
		é um canal de ajuda, esteja preparado para ler
		todos os documentos a que for referido.</para>
	    </listitem>

	    <listitem>
	      <para>O canal <literal>#FreeBSD</literal> na <ulink
		  url="http://www.hybnet.net/">HybNet</ulink>
		<emphasis>é</emphasis> um canal de ajuda.  Uma
		lista de servidores pode ser encontrada no <ulink
		  url="http://www.hybnet.net/">sítio WWW da
		  HybNet</ulink>.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Cada um destes canais é independente, e
	    exatamente por estarem em redes distintas, não
	    é conectada ou relacionada entre si.  Os estilos de
	    bate-papo em cada um dos canais são bastante
	    distintos, pode ser necessário testar cada um para
	    descobrir qual á mais adequado ao seu estilo
	    pessoal de bate-papo.  Como em toda rede de bate-papo
	    retransmitido via Internet (<acronym>IRC</acronym>), nem
	    considere acessar os canais se você ofende-se
	    facilmente ou se você não se dá bem
	    com muita gente jovem (e alguns bem velhos) que usam as
	    mais irregulares formas de escrita e
	    conversação possível, quase sempre
	    assassinando sem o menor pudor todos os princípios
	    verbais - de qualquer língua que seja.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="training">
	  <para>Onde eu consigo treinamento em e suporte comercial ao
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>DaemonNews oferece treinamento em e suporte comercial
	    ao FreeBSD.  Mais informações podem ser
	    obtidas no sítio WWW <ulink
	      url="http://www.bsdmall.com/">BSD Mall</ulink>.</para>

	  <para>FreeBSD Services oferece suporte comercial ao FreeBSD
	    no Reino Unido (além de vender o FreeBSD em
	    mídia DVD).  Veja o <ulink
	      url="http://www.freebsd-services.com">sítio
	      WWW</ulink> deles para maiores
	    informações.</para>

	  <para>A FreeBSD Mall oferece suporte comercial ao FreeBSD.
	    Maiores informações podem ser obtidas no
	    <ulink url="http://www.freebsdmall.com/">sítio
	      WWW deles</ulink>.</para>

	  <para>Qualquer outra organização que
	    ofereça treinamento em ou suporte ao FreeBSD deve
	    entrar em contato com o projeto para serem listadas
	    aqui.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="install">
    <chapterinfo>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
	<affiliation>
	  <address><email>nik@FreeBSD.org</email></address>
	</affiliation>
      </author>
    </chapterinfo>

    <title>Instalação</title>

    <qandaset>
      <qandaentry>
	<question id="floppy-download">
	  <para>De qual arquivo eu devo baixar o FreeBSD da
	    rede?</para>
	</question>

	<answer>
	  <para>Até a versão 3.1 era necessário
	    apenas um disquete para instalação do
	    FreeBSD, o disco era o
	    <filename>floppies/boot.flp</filename>.  Contudo, depois
	    que o 3.1 foi lançado, o Projeto adicionou ao
	    <foreignphrase>kernel</foreignphrase> genérico o
	    suporte a uma grande variedade de dispositivos, de forma
	    que ele passou a consumir mais espaço.  Por este
	    motivo, desde a série 3.X são
	    necessários dois disquetes, o
	    <filename>floppies/kernel.flp</filename> e o
	    <filename>floppies/mfsroot.flp</filename>.  Essas imagens
	    precisam ser copiadas para disquetes, usando ferramentas
	    como o <command>fdimage</command> ou o &man.dd.1;.</para>

	  <para>Caso seja necessário baixar da rede a
	    distribuição do sistema (por exemplo, para
	    uma instalação por meio de um sistema de
	    arquivos DOS), você terá que obter as
	    seguintes estruturas da distribuição
	    padrão:</para>

	  <itemizedlist>
	    <listitem>
	      <para>bin/</para>
	    </listitem>

	    <listitem>
	      <para>manpages/</para>
	    </listitem>

	    <listitem>
	      <para>compat*/</para>
	    </listitem>

	    <listitem>
	      <para>doc/</para>
	    </listitem>

	    <listitem>
	      <para>src/ssys.*</para>
	    </listitem>
	  </itemizedlist>

	  <para>Para obter instruções completas sobre o
	    procedimento de instalação do FreeBSD e
	    maiores detalhes sobre os meios de
	    instalação, por gentileza, consulte a <ulink
	      url="../handbook/install.html">seção de
	      instalação</ulink> no
	    &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="floppy-image-too-large">
	  <para>O que eu devo fazer se as imagens de disquete
	    não couberem em um único disco?</para>
	</question>

	<answer>
	  <para>Um disquete de 3.5 polegadas (1,44 MB) armazena
	    até 1474560 bytes de dados.  O tamanho da imagem de
	    inicialização é de exatamente 1474560
	    bytes.</para>

	  <para>Erros comuns, cometidos na
	    preparação dos discos de
	    inicialização, são:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Baixar a imagem de disco via
		<acronym>FTP</acronym> sem utilizar o modo de
		transferência
		<emphasis>binário</emphasis>.</para>

	      <para>Alguns clientes de FTP - especialmente navegadores
		de Internet - costumam usar por padrão o modo
		de transferência <emphasis>ascii</emphasis> nas
		sessões FTP, e para normalizar o arquivo de
		acordo com o sistema, eles tentam alterar os
		caracteres finais de cada linha do arquivo.
		Invariavelmente esse comportamento resulta em baixar
		uma imagem de inicialização
		(<foreignphrase>boot</foreignphrase>) corrompida.
		Verifique o tamanho da imagem que você tem em
		mãos, se é exatamente do mesmo tamanho
		da imagem no servidor.  Caso o tamanho não seja
		<emphasis>exatamente</emphasis> o mesmo, você
		pode suspeitar do arquivo que você
		baixou.</para>

	      <para>Para garantir que esse problema não ocorra,
		digite <emphasis>binary</emphasis> na prompt de
		comando do seu cliente FTP, ou defina as
		preferências do programa para utilizar o modo
		binário.  Aí sim, faça baixe da
		rede a imagem de inicialização.</para>
	    </listitem>

	    <listitem>
	      <para>Usar o comando <command>copy</command> do DOS (ou
		simplesmente copiar, por meio da Interface
		Gráfica do sistema) para transferir a imagem de
		inicialização para o disquete.</para>

	      <para>Programas como o <command>copy</command>
		não vão funcionar para copiar a imagem
		de inicialização direto para o disquete,
		exatamente porque a imagem foi criada de forma que ela
		seja carregada diretamente.  A imagem tem o
		conteúdo completo que o disquete deve ter, com
		seus dados alocados trilha-a-trilha, e portanto
		não pode ser copiado para o disquete como um
		simples arquivo.  Você tem que copiar a imagem
		para o disquete usando alguma ferramenta de
		<quote>cópia crua</quote> (raw copy, como o
		<command>fdimage</command> ou o
		<command>rawrite</command>) como descrito no <ulink
		  url="../handbook/install.html">guia de
		  instalação do FreeBSD</ulink>.</para>
	    </listitem>
	    </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="install-instructions-location">
	  <para>Onde estão as instruções para
	    instalar o FreeBSD?</para>
	</question>

	<answer>
	  <para>As instruções de
	    instalação do FreeBSD podem ser encontradas
	    na <ulink
	      url="../handbook/install.html">seção de
	      instalação do FreeBSD no
	      &a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="need-to-run">
	  <para>O que é preciso para usar o FreeBSD?</para>
	</question>

	<answer>
	  <para>Você vai precisar, no mínimo de um PC 386
	    com 5MB de memória RAM e no mínimo 60 MB em
	    disco.  Essa configuração permite o uso de
	    uma placa de vídeo MDA simples, mas para usar o
	    X11R6 é necessário uma placa de vídeo
	    VGA ou mais avançada.</para>

	  <para>Para mais informações consulte <xref
	      linkend="hardware"/></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="four-meg-ram-install">
	  <para>Eu tenho apenas 4 MB de memória RAM.  Posso
	    usar o FreeBSD?</para>
	</question>

	<answer>
	  <para>O FreeBSD 2.1.7 foi a última versão do
	    sistema que rodava com apenas 4MB de memória.  A
	    partir do FreeBSD 2.2, é necessário no
	    mínimo 5MB de memória para usar o
	    sistema.</para>

	  <para>Praticamente todas as versões do FreeBSD podem
	    <emphasis>rodar</emphasis> com 4MB de memória RAM,
	    contudo, a instalação do sistema operacional
	    não pode ser feita com apenas 4MB.  Você pode
	    colocar mais memória para o processo de
	    instalação do sistema, e depois de
	    instalado, voltar a máquina para apenas 4MB de
	    memória, ou como alternativa, instale o seu disco
	    rígido em uma máquina com mais de 4MB,
	    efetue a instalação do sistema, e depois
	    instale o seu disco de volta na máquina com apenas
	    4MB.</para>

	  <para>O FreeBSD 2.1.7 não irá instalar em
	    sistemas que usam 640 Kb de memória base + 3 MB de
	    memória extendida.  Se sua placa mãe pode
	    fazer o remapeamento da memória
	    <quote>subutilizada</quote> que vai sobrar dos 640kB da
	    região de 1MB, ai sim, você vai conseguir
	    usar o FreeBSD 2.1.7.  Entre no Setup da sua BIOS, procure
	    a opção ``remap'' e habilite-a.  Talvez
	    você tenha que desabilitar a opção de
	    ROM shadowing.  Com certeza é mais fácil
	    você conseguir mais 4MB apenas para a
	    instalação, compilar um
	    <foreignphrase>kernel</foreignphrase> customizado e
	    portanto menor, e ai sim, tirar esses 4MB sobresalentes e
	    usar o sistema com apenas os 4MB originais.  Também
	    é possível instalar o FreeBSD 2.0.5 e depois
	    <quote>atualizá-lo</quote> para o 2.1.7 com a
	    opção ``upgrade'' disponível no
	    programa de instalação do FreeBSD
	    2.1.7.</para>

	  <para>Depois de instalado o sistema, você pode
	    compilar um <foreignphrase>kernel</foreignphrase>
	    personalizado, que provavelmente irá permitir que o
	    sistema seja usado com 4MB de memória apenas.
	    Existem relatos de sucesso na utilização do
	    sistema com apenas 2MB de memória, contudo, nesse
	    caso é praticamente impossível usar alguma
	    outra aplicação junto ao sistema
	    operacional.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="custom-boot-floppy">
	  <para>Como eu crio meu próprio disquete de
	    instalação?</para>
	</question>

	<answer>
	  <para>Atualmente não existe uma forma de
	    <emphasis>simplesmente criar</emphasis> um disco de
	    instalação personalizado.  Para criar um
	    disquete personalizado você terá que preparar
	    todo um novo <literal>release</literal>, o qual, aí
	    sim, teria instruções de
	    instalação.</para>

	  <para>Para montar um <literal>release</literal>
	    personalizado siga as instruções do artigo
	    de <ulink
	      url="../../articles/releng/article.html">Engenharia de
	      <literal>Release</literal></ulink> article.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multiboot">
	  <para>Posso ter mais de um sistema operacional no meu PC?</para>
	</question>

	<answer>
	  <para>De uma olhada na página de <ulink url="../../articles/multi-os/index.html">múltiplos-SO</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="windows-coexist">
	  <para>O Windows 95/98 pode co-existir com o FreeBSD?</para>
	</question>

	<answer>
	  <para>Sim.  Primeiro você deve instalar o seu Windows,
	    e depois instalar o FreeBSD.  O gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) do FreeBSD vai ser
	    instalado na MBR do seu disco, e vai conseguir controlar o
	    inicialização entre o FreeBSD e seu Windows.
	    Se você instalar o Windows depois do FreeBSD, a
	    instalação dele irá sobrescrever o
	    setor de inicialização
	    (<foreignphrase>boot</foreignphrase>) do seu disco, e
	    conseq&uuml;entemente seu gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>), sem avisar ou pedir
	    qualquer confirmação.  Se esse for o caso,
	    leia a próxima seção.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="win95-damaged-boot-manager">
	  <para>O Windows 95/98 sobrescreveu meu gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>)! Como eu instalo ele
	    de volta?</para>
	</question>

	<answer>
	  <para>Você pode reinstalar o gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) do FreeBSD de uma
	    das 3 maneiras:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Sob o DOS, entre no diretório tools/ da sua
		distribuição do FreeBSD (seu CDROM por
		exemplo) e procure o programa
		<filename>bootinst.exe</filename>.  Depois, execute-o
		da seguinte forma:</para>

	      <screen><prompt>...\TOOLS&gt;</prompt> <userinput>bootinst.exe boot.bin</userinput></screen>

	      <para>e o gerenciador de inicialização
		(<foreignphrase>boot</foreignphrase>) será
		reinstalado.</para>
	    </listitem>

	    <listitem>
	      <para>Faça a inicialização do
		FreeBSD pelos disquetes de instalação ou
		pelo CDROM novamente.  Entre na opção
		&quot;Custom&quot; do menu de
		instalação, escolha a o ítem de
		partições (Partition), selecione o drive
		do disco que continha o seu gerenciador de
		inicialização
		(<foreignphrase>boot</foreignphrase>) (normalmente, se
		trata do primeiro disco) e então você
		entra no editor de partições.  Não
		faça nenhuma alteração, apenas
		aperte a tecla W (Write).  O programa de
		instalação irá pedir a
		confirmação, se você quer gravar
		suas informações mesmo sem ter feito
		nenhuma alteração.  Escolha Sim.  O
		programa irá perguntar se você deseja
		instalar o gerenciador de inicialização
		(<foreignphrase>boot</foreignphrase>) do FreeBSD ou se
		você deseja deixar o setor de
		inicialização
		(<foreignphrase>boot</foreignphrase>) intacto (ou
		instalar um setor de inicialização
		(<foreignphrase>boot</foreignphrase>) padrão)
		exatamente como no instante da primeira
		instalação do FreeBSD.  Escolha
		<quote>Boot Manager</quote>.  Agora o gerenciador de
		inicialização
		(<foreignphrase>boot</foreignphrase>) será
		reinstalado no disco.  Saia do programa de
		instalação e reinicie o processo de
		inicialização pelo HD
		normalmente.</para>
	    </listitem>

	    <listitem>
	      <para>Inicie o FreeBSD com o disquete (ou CD) de
		inicialização tradicional, escolha a
		opção <quote>Fixit</quote> no menu do
		sysinstall.  Escolha entre o disquete de
		correção ou o segundo CDROM (a
		opção <quote>live</quote> na
		distribuição padrão do FreeBSD)
		no menu a seguir, e entre na shell de
		correção do sistema.  Em seguida execute
		o comando:</para>

	      <screen><prompt>Fixit#</prompt> <userinput>fdisk -B -b /boot/boot0 <replaceable>bootdevice</replaceable></userinput></screen>

	      <para>substituindo <replaceable>bootdevice</replaceable>
		pela device controladora do seu disco, como por
		exemplo, <devicename>ad0</devicename> (para o primeiro
		disco IDE),<devicename>ad4</devicename> (para o
		primeiro disco IDE na controladora secundária),
		<devicename>da0</devicename> (para o primeiro disco
		SCSI), etc.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="boot-on-thinkpad">
	  <para>O meu IBM Thinkpad série A, T ou X trava
	    sempre, quando eu tento inicializar
	    (<foreignphrase>boot</foreignphrase>) o FreeBSD.  Como eu
	    resolvo isso?</para>
	</question>

	<answer>
	  <para>Um bug nas primeiras versões da BIOS da IBM
	    nessas máquinas, erroneamente identifica as
	    partições FreeBSD como
	    partições FAT especiais.  Quando a BIOS
	    tenta reconhecer a partição FreeBSD, o
	    sistema trava.</para>

	  <para>De acordo com a IBM<footnote><para>Em um e-mail
		enviado por Keith Frechettei
		<email>kfrechet@us.ibm.com</email>.</para></footnote>,
	    os seguintes modelos/BIOS tem esse problema
	    corrigido:</para>

	  <informaltable frame="none">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Modelo</entry>

		  <entry>Revisão da BIOS</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>T20</entry>

		  <entry>IYET49WW ou posterior</entry>
		</row>

		<row>
		  <entry>T21</entry>

		  <entry>KZET22WW ou posterior</entry>
		</row>

		<row>
		  <entry>A20p</entry>

		  <entry>IVET62WW ou posterior</entry>
		</row>

		<row>
		  <entry>A20m</entry>

		  <entry>IWET54WW ou posterior</entry>
		</row>

		<row>
		  <entry>A21p</entry>

		  <entry>KYET27WW ou posterior</entry>
		</row>

		<row>
		  <entry>A21m</entry>

		  <entry>KXET24WW ou posterior</entry>
		</row>

		<row>
		  <entry>A21e</entry>

		  <entry>KUET30WW</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>Existem relatos de que as revisões posteriores
	    das BIOS IBM re-introduziram esse bug.  <ulink
	      url="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=200565+208320+/usr/local/www/db/text/2001/freebsd-mobile/20010429.freebsd-mobile">Essa
	      mensagem</ulink>  enviada por Jacques Vidrine para a
	    &a.mobile; descreve uma série de procedimentos que
	    podem funcionar no seu laptop IBM, caso seja uma
	    versão um pouco mais nova, e que não consiga
	    inicializar (<foreignphrase>boot</foreignphrase>) o
	    FreeBSD corretamente.  Você pode ainda fazer uma
	    atualização ou desatualização
	    (upgrade ou downgrade) da BIOS.</para>

	  <para>Se a BIOS é mais antiga, e você
	    não considera sua atualização, existe
	    uma opção que pode sanar seu problema.  A
	    instalação do FreeBSD pode ser feita
	    alterando-se a identificação da
	    partição (partition ID) do sistema, e depois
	    instalar novos setores de inicialização
	    (<foreignphrase>boot</foreignphrase>) que podem controlar
	    uma partition ID diferente.</para>

	  <para>O primeiro passo é restaurar o seu laptop ao
	    ponto onde ele pode fazer os auto-testes, ou seja, os
	    testes básicos de I/O da BIOS.  Para fazer isso,
	    basta ligar o computador de forma que ele não
	    consiga encontrar a partição primária
	    do FreeBSD.  A maneira mais simples de faze-lo, é
	    retirando o disco rígido do seu laptop, e
	    temporariamente ligando-o em um ThinkPad mais antigo (como
	    oThinkPad 600) ou em um PC comum, com um cabo de
	    conversão apropriado.  Uma vez feito isso, basta
	    apagar a partição FreeBSD e colocar o disco
	    de volta no laptop.  Agora sim, o ThinkPad deve estar de
	    volta ao estado onde ele pode reconhecer o disco.</para>

	  <para>Com a máquina funcionando, basta seguir as
	    próximas instruções para fazer o seu
	    FreeBSD instalar:</para>

	  <procedure>
	    <step>
	      <para>Baixe da rede os arquivos
		<filename>boot1</filename> e
		<filename>boot2</filename> no site <ulink
		  url="http://people.FreeBSD.org/~bmah/ThinkPad/">http://people.FreeBSD.org/~bmah/ThinkPad/</ulink>.
		Coloque esses arquivos em algum lugar onde você
		possa acessá-los posteriormente.</para>
	    </step>

	    <step>
	      <para>Instale o FreeBSD normalmente no ThinkPad.
		<emphasis>Não</emphasis> use o modo
		<literal>Dangerously Dedicated</literal>.
		<emphasis>Não</emphasis> reinicie o sistema
		quando o processo de instalação for
		concluído.</para>
	    </step>

	    <step>
	      <para>Vá para a <quote>Shell Holográfica
		  de Emergência</quote> (<keycombo
		  action="simul"><keycap>ALT</keycap>
		  <keycap>F4</keycap></keycombo>) ou inicie uma shell
		de recuperação -
		<quote>fixit</quote></para>
	    </step>

	    <step>
	      <para>Use o &man.fdisk.8; para alterar a partition ID de
		<literal>165</literal> para <literal>166</literal>
		(166 é o ID usado pelo OpenBSD).</para>
	    </step>

	    <step>
	      <para>Coloque os arquivos <filename>boot1</filename> e
		<filename>boot2</filename> no sistema de arquivos
		local.</para>
	    </step>

	    <step>
	      <para>Use o &man.disklabel.8; para escrever o
		<filename>boot1</filename> e o
		<filename>boot2</filename> na sua
		partição FreeBSD.</para>

	      <screen>&prompt.root; <userinput>disklabel -B -b boot1 -s boot2 ad0s<replaceable>n</replaceable></userinput></screen>

	      <para><replaceable>n</replaceable> é o
		número da partição onde o FreeBSD
		está instalado.</para>
	    </step>

	    <step>
	      <para>Reinicie o sistema.  O gerenciador de
		inicialização
		(<foreignphrase>boot</foreignphrase>)
		oferecerá a opção de iniciar o
		<literal>OpenBSD</literal>, mas na verdade essa
		opção estará iniciando o
		FreeBSD.</para>
	    </step>
	  </procedure>

	  <para>Agora, se você quer manter os sistemas
	    operacionais OpenBSD e FreeBSD no mesmo laptop ThinkPad,
	    pode considerar isso um exercício prático
	    que fica a critério do leitor.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="install-bad-blocks">
	  <para>Posso instalar o FreeBSD em um disco com bad
	    blocks?</para>
	</question>

	<answer>
	  <para>Até a versão 3.0, o FreeBSD tinha um
	    utilitário chamado <command>bad144</command>, que
	    automaticamente remapeava os bad blocks.  Atualmente, os
	    discos IDE modernos são capazes de fazer isso
	    sozinhos, portanto o <command>bad144</command> foi
	    retirado da árvore do FreeBSD.  Se sua
	    intenção é instalar o FreeBSD 3.0 ou
	    alguma versão mais recente, nós sinceramente
	    aconselhamos que você compre um novo disco.  Se
	    você não quer comprar um disco novo,
	    então use o FreeBSD 2.X.</para>

	  <para>Se você esta tendo problemas de bad block com
	    algum disco IDE moderno, provavelmente o disco será
	    perdido em breve, já que ele está tão
	    corrompido que a controladora interna não
	    está conseguindo corrigir e remapear os bad blocks.
	    Sugerimos que você compre um disco novo logo, e
	    realize cópia de segurança
	    (<foreignphrase>backup</foreignphrase>) dos dados,
	    enquanto o disco ainda funciona.</para>

	  <para>Se o drive de disco é SCSI e está
	    apresentando bad blocks, leia <link linkend="awre">essa
	      resposta</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bad144-3x-4x">
	  <para>Eu acabei de atualizar o sistema da série 3.X
	    para 4.X, e a minha primeira inicialização
	    (<foreignphrase>boot</foreignphrase>) falhou com a
	    mensagem <errorname>bad sector table not
	      supported</errorname></para>
	</question>

	<answer>
	  <para>O FreeBSD 3.X e anteriores suportavam o programa
	    <command>bad144</command>, que automaticamente remapeava
	    bad blocks.  O FreeBSD 4.X e posteriores não
	    suportam mais esse programa, devido ao fato que os
	    controladores de discos IDE atuais conseguem remapear bad
	    blocks automaticamente.  Leia <link
	      linkend="install-bad-blocks">essa pergunta</link> para
	    mais informações.</para>

	  <para>Para corrigir esse problema depois de uma
	    atualização, é necessário
	    mover fisicamente o disco com problemas para um outro
	    sistema FreeBSD funcional e usar o &man.disklabel.8; da
	    forma discutida a seguir.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="find-bad144">
	  <para>Como eu faço se um disco tem
	    informações criadas pelo
	    <command>bad144</command> antes de atualizar o sistema, e
	    depois de atualizado para o FreeBSD 4.0 ou posterior, a
	    inicialização falha?</para>
	</question>

	<answer>
	  <para>Use o &man.disklabel.8; para identificar esse ambiente.
	    <command>disklabel -r <replaceable>drive
		device</replaceable></command> vai te mostrar o
	    conteúdo do disco.  Procure o campo
	    <literal>flags</literal>.  Se encontrar a
	    informação <literal>flags: badsect</literal>
	    é porque esse disco está usando o bad144.
	    Por exemplo, o disco a seguir tem o
	    <command>bad144</command> habilitado:</para>

	  <screen>&prompt.root; disklabel -r wd0
# /dev/rwd0c:
type: ESDI
disk: wd0s1
label:
flags: badsect
bytes/sector: 512
sectors/track: 63</screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="disable-bad144">
	  <para>Como eu removo o <command>bad144</command> do meu
	    sistema anterior ao 4.X de forma que eu possa
	    atualizá-lo com segurança?</para>
	</question>

	<answer>
	  <para>Use o comando <command>disklabel -e -rwd0</command>
	    para editar as informações do seu disco.
	    Basta retirar a palavra <literal>badsect</literal> do seu
	    campo flags, salvar a alteração e sair do
	    programa.  O bad144 ainda estará ocupando algum
	    espaço no seu disco, mas ele estará
	    funcional para série 4.X e posteriores.</para>

	  <para>Caso seu disco tenha um número muito alto de
	    bad blocks, é recomendado a troca do disco.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="boot-floppy-strangeness">
	  <para>Coisas estranhas acontecem quando inicio o sistema com
	    o disco de instalação!  O que está
	    acontecendo?</para>
	</question>

	<answer>
	  <para>Se sua máquina está desligando ou
	    espontâneamente reiniciando sempre que você
	    tenta iniciar o sistema com o disco de
	    instalação, aqui vão algumas
	    perguntas que você deveria fazer a si mesmo:</para>

	  <orderedlist>
	    <listitem>
	      <para>O disco de instalação foi feito a
		partir de um disquete novo, recém formatado e
		completamente livre de erros (de preferência
		algum disco que acabou de sair da caixa, ao
		contrário desse seu disco que estava perdido
		há quase 3 anos debaixo da cama)?</para>
	    </listitem>

	    <listitem>
	      <para>Você baixou da rede a imagem em modo
		binário?  (não se envergonhe, até
		o melhor de nós já baixou um arquivo
		binário em modo ASCII ao menos uma vez na
		vida!)</para>
	    </listitem>

	    <listitem>
	      <para>No Windows 95 ou 98, você usou o
		<command>fdimage</command> ou o
		<command>rawrite</command> em modo DOS? Esses sistemas
		operacionais as vezes interferem na forma com que os
		programas escrevem dados diretamente no hardware,
		exatamente o que o processo de criação
		da imagem de disco faz, mesmo que você execute
		um prompt do DOS no ambiente gráfico o problema
		pode ocorrer.</para>
	    </listitem>
	  </orderedlist>

	  <para>Ainda existem notícias de arquivos de imagens
	    sendo corrompidos pelo Netscape, durante o
	    <foreignphrase>download</foreignphrase>, por isso é
	    mais seguro utilizar um cliente de FTP diferente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="no-install-cdrom">
	  <para>Eu inicializei o FreeBSD a partir do meu CDROM ATAPI,
	    mas o programa de instalação diz que o CDROM
	    não foi encontrado.  Para onde ele foi?</para>
	</question>

	<answer>
	  <para>A causa desse problema curioso é a
	    configuração errada do seu drive de CDROM.
	    Hoje em dia muitos PCs vem com o CDROM instalado como
	    escravo na segunda controladora IDE, sem nenhum disco ou
	    drive óptico do tipo mestre na mesma controladora.
	    De acordo com as especificações ATAPI esse
	    tipo de configuração é incorreta e
	    ilegal.  Alguns sistemas, como o Windows, simplesmente
	    ignoram uma série de especificações
	    legais na arquitetura de computadores pessoais, e acabam
	    oferecendo suporte a essa configuração
	    errônea - o que mais tarde pode causar outros
	    conflitos.  Depois que o sistema inicia, a BIOS passa a
	    ignorar esse drive, e por isso o FreeBSD não
	    consegue encontrá-lo, para completar a
	    instalação.</para>

	  <para>Reconfigure o seu computador de forma que o CDROM
	    esteja como mestre na sua controladora IDE, ou que exista
	    um outro periférico como mestre na controladora
	    onde o CD estiver como escravo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="install-PLIP">
	  <para>Posso instalar o FreeBSD no meu laptop via PLIP (IP em
	    Linha Paralela)?</para>
	</question>

	<answer>
	  <para>Claro.  Use o cabo laplink padrão.  Caso
	    necessário, verifique a <ulink
	      url="../handbook/plip.html">seção de
	      PLIP</ulink> do &a.ptbr.p.handbook; para obter detalhes
	    sobre a instalação do FreeBSD via rede em
	    porta paralela.</para>

	  <para>Se você está usando o FreeBSD 3.X ou
	    anterior, dê uma olhada na página de <ulink
	      url="http://www.FreeBSD.org/docs.html#PAO">Computação
	      Móvel</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="geometry">
	  <para>Qual geometria eu devo utilizar para um disco?</para>
	</question>

	<answer>
	  <note>
	    <para>Por <quote>geometria</quote>, nós entendemos
	      o número de cilindros, cabeças e
	      setores/trilhas de um disco.  Por conveniência,
	      vamos nos referir à esses dados como C/H/S
	      (Cylinders/Heads/Sectores).  É a partir dessa
	      informação que a BIOS dos PCs definem
	      quais áreas de um disco podem ser usadas para
	      leitura/escrita.</para>
	  </note>

	  <para>A geometria de disco costuma causar uma série
	    de confusões entre administradores de sistemas
	    menos experientes.  Para começar, a geometria
	    <emphasis>física</emphasis> de um disco SCSI
	    é totalmente irrelevante, pois o FreeBSD trabalha
	    com blocos de discos.  Na verdade, não existe
	    exatamente <quote>a</quote> geometria física de um
	    disco, visto que a densidade de um setor varia de acordo
	    com os discos.  Os fabricantes chamam de <quote>geometria
	      física</quote> as especificações
	    que eles definem para que o menor espaço
	    possível em disco seja desperdiçado.  Em
	    discos IDE, o FreeBSD trabalha com as
	    informações de C/H/S, mas todos os
	    dispositivos modernos, internamente convertem essa
	    informações em referências a blocos de
	    disco.</para>

	  <para>O que importa, portanto, é a geometria
	    <emphasis>lógica</emphasis>.  O valor lógico
	    é a resposta que a BIOS obtém quando
	    pergunto <quote>qual sua geometria?</quote> ao disco.
	    É esse valor, então, que é usado para
	    definir a forma de acesso ao dispositivo de armazenamento.
	    O FreeBSD usa as informações da BIOS quando
	    inicializa (<foreignphrase>boot</foreignphrase>), e por
	    isso é extremamente importante obter essa
	    informação de maneira correta.  No geral, se
	    você tem mais de um sistema operacional no mesmo
	    disco, eles devem concordar no valor lógico da
	    geometria do disco, caso contrário você
	    terá sérios problemas ao iniciar o
	    sistema.</para>

	  <para>Em discos SCSI, a geometria à ser utilizada
	    depende do suporte à tradução
	    extendida definido na sua controladora de disco
	    (normalmente esse suporte é chamado de
	    <quote>support for DOS disks &gt;1GB</quote>, que
	    identifica o suporte à discos DOS cuja capacidade
	    de armazenamento é maior que 1GB - ou alguma
	    identificação similar.).  Se essa
	    opção está desabilitada, então
	    o C/H/S do disco será de
	    <replaceable>N</replaceable> cilindros, 64 cabeças
	    e 32 setores/trilhas, onde o valor
	    <replaceable>N</replaceable> equivale a capacidade (em MB)
	    do disco.  Por exemplo, um disco de 2GB teria 2048
	    cilindros, 64 cabeças e 32 setores/trilhas.</para>

	  <para>Se a opção <emphasis>estiver</emphasis>
	    habilitada (normalmente ela é habilitada por
	    padrão, para sanar algumas limitações
	    de sistemas baseados em MSDOS), e a capacidade do disco
	    forma maior que 1GB, os valores C/H/S do disco
	    serão M cilindros, 63 setores por trilha
	    (<emphasis>não</emphasis> 64) e 255 cabeças,
	    sendo 'M' a capacidade do disco, em MB, dividido por
	    7.844238 (!).  Então, por exemplo, o mesmo disco de
	    2GB nessa situação teria 261 cilindros, 63
	    setores por trilha e 255 cabeças.</para>

	  <para>Se você não entendeu o porque disso, ou
	    se o seu FreeBSD falha no momento de reconhecer a
	    geometria correta do seu disco durante a
	    instalação, existe uma forma de tentar
	    resolver esse problema.  Crie uma pequena
	    partição do tipo DOS no seu disco, e
	    verifique se a BIOS consegue identificar corretamente a
	    geometria do mesmo.  Caso consiga, a
	    instalação vai se completar com
	    tranq&uuml;ilidade, e a pequena partição DOS
	    pode sempre ser deletada, com o editor de
	    partições do FreeBSD.</para>

	  <para>Como alternativa, existe uma aplicação
	    gratuitamente disponível com a
	    distribuição do FreeBSD, chamada de
	    <filename>pfdisk.exe</filename>.  Ela pode ser encontrada
	    sob o diretório <filename>tools</filename> no CDROM
	    do FreeBSD ou nos servidores FTP do projeto.  Esse
	    programa serve para descobrir qual a geometria usada por
	    outros sistemas operacionais no disco local.  Nesse caso,
	    esse valor pode ser definido no editor de
	    partições do FreeBSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="disk-divide-restrictions">
	  <para>Existem restrições quanto ao
	    particionamento de discos?</para>
	</question>

	<answer>
	  <para>Sim, existem.  A principal delas, é que a
	    partição <quote>root</quote> não pode
	    ter mais de 1024 cilindros, senão a BIOS não
	    consegue iniciar o <foreignphrase>kernel</foreignphrase>
	    do sistema a partir dessa partição.  (Note
	    que essa é uma limitação das BIOS dos
	    computadores pessoais, e não do FreeBSD).</para>

	  <para>Em um disco SCSI, essa limitação implica
	    que a partição raiz (root) deve estar
	    alocada nos primeiros 1024MB do disco (ou nos primeiros
	    4096MB, caso o suporte a tradução extendida
	    esteja habilitada - veja pergunta anterior).  Em discos
	    IDE, o valor correspondente equivale a 504MB para
	    partição raiz (root).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="disk-manager">
	  <para>O FreeBSD suporta programas gerenciadores de
	    discos?</para>
	</question>

	<answer>
	  <para>O FreeBSD reconhece apenas o <quote>Ontrack Disk
	      Manager</quote>.  Outros gerenciadores de discos
	    não são suportados.</para>

	  <para>Se sua intenção é usar o disco
	    com FreeBSD, você não precisa de um
	    gerenciador de discos.  Basta configurar o disco para o
	    total de espaço que a BIOS reconhece (normalmente
	    504MB) e o FreeBSD vai conseguir identificar o tamanho
	    real do disco.  Se você estiver usando um disco
	    antigo com uma controladora MFM, será
	    necessário avisar ao FreeBSD quantos cilindros o
	    disco tem.</para>

	  <para>Caso queira usar o disco com FreeBSD e algum outro
	    sistema operacional, provavelmente também
	    não será necessário um gerenciador de
	    discos.  Certifique-se apenas que a partição
	    de inicialização
	    (<foreignphrase>boot</foreignphrase>) do FreeBSD e a
	    partição do outro sistema operacional
	    estejam nos primeiros 1024 cilindros do disco.
	    Normalmente, para administradores de sistemas que tomam
	    decisões racionais, 20MB de espaço em uma
	    partição de inicialização
	    (<foreignphrase>boot</foreignphrase>) é mais que o
	    suficiente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="missing-os">
	  <para>Quando eu inicio o FreeBSD, eu obtenho a mensagem
	    <errorname>Missing Operating System</errorname>.  O que
	    está acontecendo?</para>
	</question>

	<answer>
	  <para>Esse é um caso tópico do FreeBSD e o DOS
	    ou qualquer outro sistema operacional discordando de suas
	    definições em relação a <link
	      linkend="geometry">geometria</link> do disco.
	    Provavelmente você terá que reinstalar o
	    FreeBSD, mas se seguir as instruções citadas
	    nas perguntas anteriores, raramente esse problema vai
	    acontecer.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="stop-at-boot-manager">
	  <para>Porque eu não consigo passar da tela
	    <prompt>F?</prompt> do gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>)?</para>
	</question>

	<answer>
	  <para>Esse é mais um sintoma do problema descrito na
	    pergunta anterior.  A geometria que a sua BIOS reconhece
	    não equivale ao valor definido no FreeBSD! Se a sua
	    controladora de disco ou sua BIOS suportam o modo de
	    tradução de cilindros (normalmente chamado
	    de <quote>&gt;1GB drive support</quote>), tente alterar
	    essa opção e reinstalar o FreeBSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="need-complete-sources">
	  <para>Eu preciso instalar todos os fontes do sistema
	    operacional?</para>
	</question>

	<answer>
	  <para>Geralmente não, mas é altamente
	    recomendável que você instale ao menos os
	    fontes <literal>base</literal>, que incluem
	    inúmeros arquivos mencionados ao longo desse
	    documento, como as fontes do sistema,
	    <literal>sys</literal> que inclui as fontes do
	    <foreignphrase>kernel</foreignphrase> do FreeBSD, sem os
	    quais não se pode criar um
	    <foreignphrase>kernel</foreignphrase> personalizado.
	    Não existe qualquer dependência do sistema
	    operacional em relação aos seus fontes;  com
	    a única exceção do programa
	    &man.config.8;, o resto do sistema operacional não
	    precisa dos fontes para funcionar.  Os outros fontes do
	    sistema operacional - exceto os fontes do
	    <foreignphrase>kernel</foreignphrase> - podem ser montados
	    remotamente (via NFS, por exemplo) em qualquer lugar, e
	    ainda assim novos binários podem ser compilados a
	    partir dos mesmos.  Devido a restrição
	    única dos fontes do
	    <foreignphrase>kernel</foreignphrase>, é
	    recomendável que os outros fontes não sejam
	    diretamente montados sob <filename>/usr/src</filename> mas
	    sim, que sejam montados separadamente e depois
	    interligados com links simbólicos
	    apropriados.</para>

	  <para>Tendo todos os fontes disponíveis, e sabendo
	    reconstruir o sistema a partir dos mesmos, será
	    muito mais fácil manter o FreeBSD sincronizado e
	    atualizado com futuros releases.</para>

	  <para>Para escolher um subconjunto dos fontes do sistema,
	    escolha a opção <literal>Custom</literal>
	    quando estiver na opção
	    <literal>Distributions</literal> do programa de
	    instalação do sistema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="need-kernel">
	  <para>Eu preciso criar um
	    <foreignphrase>kernel</foreignphrase>
	    personalizado?</para>
	</question>

	<answer>
	  <para>Construir um novo
	    <foreignphrase>kernel</foreignphrase> costumava ser uma
	    obrigação na instalação do
	    FreeBSD, mas hoje em dia existe uma interface de
	    configuração do
	    <foreignphrase>kernel</foreignphrase> muito mais
	    amigável, que permite a redefinição
	    de recursos do sistema.  Para acessar essa ferramenta,
	    basta inicializar (<foreignphrase>boot</foreignphrase>) o
	    sistema com a opção <option>-c</option> no
	    prompt de (<literal>boot:</literal>).  Em especial, os
	    principais periféricos ISA - normalmente os mais
	    problemáticos - podem ser facilmente configurados
	    com essa opção.</para>

	  <para>Ainda é recomendável que se construa um
	    <foreignphrase>kernel</foreignphrase> personalizado,
	    apenas com suporte aos equipamentos e
	    características do sistema que você precisa,
	    de forma a economizar recursos no sistema (especialmente
	    memória RAM), mas essa recompilação
	    não é mais uma obrigação na
	    maioria dos sistemas - mas é sem dúvida um
	    hábito saudável.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="password-encryption">
	  <para>Eu devo usar criptografia DES, Blowfish, ou MD5 para
	    senhas do sistema? Como eu defino qual delas o
	    usuário deve usar?</para>
	</question>

	<answer>
	  <para>O formato padrão para senhas no FreeBSD
	    é a criptografia <emphasis>MD5</emphasis>.  Esse
	    padrão é considerado mais seguro do que os
	    formatos tradicionais de senhas Unix, que normalmente eram
	    baseados no algorítimo <emphasis>DES</emphasis>.  O
	    FreeBSD ainda pode trabalhar com senhas em formato DES
	    caso você precise compartilhá-las com
	    sistemas que ainda armazenam suas senhas no formato antigo
	    - e menos seguro - dos sistemas Unix originais (para isso
	    você terá que instalar a
	    distribuição <quote>crypto</quote> via
	    sysinstall ou apartir do código fonte).  Instalando
	    as bibliotecas crypto ser&aacute possivel utilizar outros
	    tipos de criptografia, como o formato Blowfish, que
	    é ainda mais seguro do que o MD5.  A
	    definição de qual codificação
	    utilizar é definida no campo
	    <quote>passwd_format</quote> do arquivo de
	    configurações de login, o
	    <filename>/etc/login.conf</filename>.  Esse campo deve ter
	    o valor <quote>des</quote>, <quote>blf</quote> (caso suas
	    bibliotecas estejam disponíveis) ou
	    <quote>md5</quote>.  Veja a página de manuais do
	    &man.login.conf.5; para maiores
	    informações.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="boot-floppy-hangs">
	  <para>Por que o disco de inicialização
	    (<foreignphrase>boot</foreignphrase>) inicia, mas trava na
	    tela <literal>Probing Devices...</literal>?</para>
	</question>

	<answer>

	  <para>Se você tem um drive Zip IDE ou um Jaz conectado
	    ao seu computador, remova-o e tente de novo.  A
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) de
	    instalação do sistema se confunde as vezes
	    quando esses dispositivos estão disponíveis
	    no computador.  Depois da instalação os
	    drives são reconhecidos e controlados normalmente.
	    Provavelmente - esperamos - esse problema será
	    corrigido nas próximas versões.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="panic-on-install-reboot">
	  <para>Por que ocorre o erro <errorname>panic: can't mount
	      root</errorname>, quando eu reinicio o sistema, depois
	    de tê-lo instalado.</para>
	</question>

	<answer>
	  <para>Esse problema costuma ocorrer por conta de uma pequena
	    confusão entre os blocos do setor de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) do disco, e as
	    definições de disco no
	    <foreignphrase>kernel</foreignphrase>.  É um erro
	    típico apenas de sistemas com dois discos IDE,
	    quando os mesmos estão definidos como disco mestre
	    e escravo, mas em controladoras distintas, e com o FreeBSD
	    instalado na controladora secundária.  Os blocos de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) acham que o sistema
	    está instalado no segundo disco IDE (o segundo
	    disco reconhecido pela BIOS) enquanto o
	    <foreignphrase>kernel</foreignphrase> assume o primeiro
	    disco na segunda controladora IDE.  Depois do
	    reconhecimento dos equipamentos do sistema o
	    <foreignphrase>kernel</foreignphrase> tenta montar a
	    partição raiz no disco que o bloco de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) acredita ser o disco
	    de inicialização
	    (<foreignphrase>boot</foreignphrase>), wd1, ao
	    invés do disco correto na segunda controladora,
	    wd2, e por isso o processo de inicialização
	    falha.</para>

	  <para>Para corrigir esse problema, você tem três
	    opções:</para>

	  <orderedlist>
	    <listitem>
	      <para>No FreeBSD 3.3 e posteriores, reincie o sistema e
		aperte <keycap>Enter</keycap> na tela <literal>Booting
		  kernel in 10 seconds;  hit [Enter] to
		  interrupt</literal>.  Você será
		direcionado ao <literal>boot loader</literal>.</para>

	      <para>Depois, digite <literal> set
		  root_disk_unit="<replaceable>disk_number</replaceable>"</literal>.
		<replaceable>disk_number</replaceable> deverá
		ser <literal>0</literal> se o FreeBSD estiver
		instalado como mestre na primeira controladora IDE,
		<literal>1</literal> se for o escravo na primeira
		controladora, <literal>2</literal> se for o mestre da
		segunda controladora IDE, e <literal>3</literal> se
		for o escravo na segunda controladora.</para>

	      <para>Depois digite <literal>boot</literal>, e seu sistema deve ser iniciado corretamente.</para>

	      <para>Para tornar essa alteração
		permanente, (para que você não tenha que
		digitar isso na mão toda vez que seu FreeBSD
		tiver que reiniciar) basta colocar a linha <literal>
		  root_disk_unit="<replaceable>disk_number</replaceable>"</literal>
		no arquivo
		<filename>/boot/loader.conf.local</filename>.</para>
	      </listitem>

	    <listitem>
	      <para>Se você estiver usando o FreeBSD 3.2 ou
		alguma versão anterior, digite
		<literal>1:wd(2,a)kernel</literal> na prompt de
		inicialização do sistema e aperte
		<keycap>Enter</keycap>.  Se o sistema iniciar
		normalmente, execute o comando <command>echo
		  "1:wd(2,a)kernel" &gt; /boot.config</command> para
		tornar essa alteração permanente.</para>
	    </listitem>

	    <listitem>
	      <para>Mude o disco com o FreeBSD para primeira
		controladora IDE.</para>
	    </listitem>

	    <listitem>
	      <para><ulink
		  url="../handbook/kernelconfig.html">Recompile o
		  <foreignphrase>kernel</foreignphrase></ulink>,
		altere as linhas de configuração wd
		para: </para>

	      <programlisting>controller      wdc0    at isa? port "IO_WD1" bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk            wd1     at wdc0 drive 1 # comment out this line

controller      wdc1    at isa? port "IO_WD2" bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # change from wd2 to wd1
disk            wd2     at wdc1 drive 1 # change from wd3 to wd2</programlisting>

	      <para>E instale o novo
		<foreignphrase>kernel</foreignphrase>.  Se você
		mudou seu disco e quer voltar ele para
		configuração original, mude a ordem
		deles no PC e reinicie o sistema.  Seu sistema deve
		iniciar com sucesso.</para>
	      </listitem>
	    </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="memory-limits">
	  <para>Quais são as limitações de
	    memória?</para>
	</question>

	<answer>
	  <para>A limitação de memória é
	    de 4 gigabytes.  Essa definição foi testada,
	    veja a <ulink
	      url="ftp://ftp.cdrom.com/archive-info/configuration">configuração
	      do wcarchive</ulink> para obter mais detalhes.  Se
	    você pretende instalar essa quantidade de
	    memória no FreeBSD, seja cuidadoso.  Dê
	    preferência para memórias ECC e reduza a
	    capacidade de carga usando modules de memória de 9
	    chips, ai invés dos módulos de 18
	    chips.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ffs-limits">
	  <para>Qual a limitação para o sistema de
	    arquivos FFS?</para>
	</question>

	<answer>
	  <para>Para o sistema de arquivos FFS, o limite
	    máximo, na teoria é de 8 terabytes (para
	    blocos de 2K), ou 16TB para o tamanho padrão dos
	    blocos, que é de 8K.  Na prática os limites
	    variam de 1TB a 4TB de acordo com algumas
	    modificações no sistema de arquivos.</para>

	  <para>O tamanho máximo para um arquivo no sistema FFS
	    é de 1G de blocos (4TB) caso os blocos sejam de
	    4K.</para>

	  <table>
	    <title>Tamanho máximo dos arquivos.</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry>Tamanho do bloco</entry>

		  <entry>2.2.7-stable</entry>

		  <entry>3.0-current</entry>

		  <entry>Funciona com</entry>

		  <entry>Deve funcionar</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>4K</entry>

		  <entry>4T-1</entry>

		  <entry>4T-1</entry>

		  <entry>4T-1</entry>

		  <entry>&gt;4T</entry>
		</row>

		<row>
		  <entry>8K</entry>

		  <entry>&gt;32G</entry>

		  <entry>8T-1</entry>

		  <entry>&gt;32G</entry>

		  <entry>32T-1</entry>
		</row>

		<row>
		  <entry>16K</entry>

		  <entry>&gt;128G</entry>

		  <entry>16T-1</entry>

		  <entry>&gt;128G</entry>

		  <entry>32T-1</entry>
		</row>

		<row>
		  <entry>32K</entry>

		  <entry>&gt;512G</entry>

		  <entry>32T-1</entry>

		  <entry>&gt;512G</entry>

		  <entry>64T-1</entry>
		</row>

		<row>
		  <entry>64K</entry>

		  <entry>&gt;2048G</entry>

		  <entry>64T-1</entry>

		  <entry>&gt;2048G</entry>

		  <entry>128T-1</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Quando o sistema de arquivos possui blocos de 4K, o
	    triplo de blocos indiretores funcionam, e o limite
	    máximo do sistema de arquivos deveria ser atingido,
	    mas a triplicação dos blocos indiretores
	    (representados aproximadamente pelo resultado de 1K^3 +
	    1K^2 + 1K) se limita ao valor (errôneo) de 1G-1 no
	    número de blocos do sistema de arquivos.  O limite
	    do número de blocos deveria ser 2G-1.  Mas por
	    causa de alguns problemas com o número dos blocos
	    no sistema de arquivos, esse valor não pode ser
	    alcançado quando o tamanho dos blocos no sistema de
	    arquivos é 4K.</para>

	  <para>Em blocos com tamanho de 8K ou maiores, o limite geral
	    é de 2G-1 no número de blocos do sistema de
	    arquivos, exceto no FreeBSD -STABLE onde o triplo indireto
	    do número de blocos pode ser alcançado, de
	    forma que o limite máximo do sistema de arquivos
	    seja representado pela equação
	    ((blocksize/4)^2 + (blocksize/4)), e sob o -CURRENT onde a
	    exceção desse limite pode causar
	    problemas.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="archsw-readin-failed-error">
	  <para>Por que a mensagem de erro
	    <errorname>archsw.readin.failed</errorname> me perturba
	    sempre, depois que eu recompilo e carrego um
	    <foreignphrase>kernel</foreignphrase> novo?</para>
	</question>

	<answer>
	  <para>Você pode carregar um novo
	    <foreignphrase>kernel</foreignphrase> ao especifica-lo
	    diretamente no segundo estágio do processo de
	    inicialização, simplesmente apertando
	    qualquer tecla quando o pipe ( | ) aparecer, antes que o
	    loader seja carregado.  Provavelmente você atualizou
	    todo o sistema operacional, mas recompilou apenas o
	    <foreignphrase>kernel</foreignphrase>, <emphasis>sem dar
	      um make world</emphasis>.  Essa ação
	    é arriscada e não é suportada.
	    Faça um Make World!!!!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="upgrade-3x-4x">
	   <para>Como eu atualizo meu sistema da série 3.X para 4.X?</para>
	</question>

	<answer>
	  <para>É <emphasis>altamente</emphasis>
	    recomendável que você use
	    <foreignphrase>snapshots</foreignphrase> binários
	    para fazer isso.  <foreignphrase>Snapshots</foreignphrase>
	    binário do 4-STABLE podem ser encontrados em <ulink
	      url="ftp://releng4.FreeBSD.org/">ftp://releng4.FreeBSD.org/</ulink>.</para>

	  <para>Devido às inúmeras
	    alterações da série 3.X para
	    série 4-STABLE, uma atualização
	    direta, a partir dos fontes, corre grande riscos de
	    falhar.  A atualização dos fontes pode ser
	    feita, inclusive desde as primórdias versões
	    2.X até as mais recentes 4-STABLE ou até
	    mesmo 5-CURRENT, mas essa atualização deve
	    ser realizada em vários estágios.  Primeiro,
	    atualize a sua série 3.X pra versão mais
	    recente, a 3-STABLE (<literal>RELENG_3</literal>).  Depois
	    atualize para o 4.1.1-RELEASE
	    (<literal>RELENG_4_1_1_RELEASE</literal>).  Finalmente,
	    tente atualizar para o 4-STABLE
	    (<literal>RELENG_4</literal>).</para>

	  <para>Se você pretende atualizar seu sistema a partir
	    dos fontes, por gentileza, refira-se ao <ulink
	      url="../handbook/cutting-edge.html">&a.ptbr.p.handbook;</ulink>
	    para maiores informações.</para>

	  <caution>
	    <para>A atualização direta por meio dos
	      fontes nunca é aconselhável para
	      usuários inexperientes, a
	      atualização da série 3.X para 4.X
	      portanto é menos aconselhável ainda,
	      portanto, caso você não tenha
	      experiências com esse processo de
	      atualização, leia todas as
	      instruções disponíveis no
	      &a.ptbr.p.handbook; com cuidado.</para>
	  </caution>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="security-profiles">
	  <para>Onde estão essas
	    <quote>especificações de
	      segurança</quote>?</para>
	</question>

	<answer>
	  <para>Uma <quote>especificação de
	      segurança</quote> se refere a um conjunto de
	    configurações e de opções no
	    sistema, que tendem a garantir um nível
	    desejável de segurança, por meio de definir
	    ou desabilitar algumas opções e programas no
	    FreeBSD.  Para maiores detalhes, veja a
	    seção de <ulink
	      url="../handbook/install-post.html#SECURITYPROFILE">
	      Especificação de Segurança</ulink>
	    no <ulink
	      url="../handbook/install-post.html">capítulo de
	      pós-instalação</ulink> do
	    &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="hardware">
    <title>Compatibilidade de Hardware</title>

    <qandaset>
      <qandaentry>
	<question id="architectures">
	  <para>O FreeBSD suporta outras arquiteturas além da
	    x86?</para>
	</question>

	<answer>
	  <para>Sim.  Atualmente o FreeBSD tem suporte para
	    arquiteturas Intel x86 e DEC (agora Compaq) Alpha.
	    Também existe um interesse conhecido no
	    <literal>port</literal> FreeBSD para plataforma SPARC.
	    Caso exista interesse em participar desse projeto ou saber
	    mais informações sobre
	    <literal>port</literal> para esta arquitetura, queira
	    juntar-se à lista de discussão do &a.sparc;.
	    As plataformas IA-64 e Power-PC foram recentemente
	    adicionadas à lista de arquiteturas que
	    serão futuramente suportadas;  entre na lista do
	    &a.ia64; e/ou &a.ppc; para mais informações
	    sobre tais arquiteturas.  Para discussões gerais
	    sobre outras arquiteturas, entre na lista de
	    discussão &a.platforms;.</para>

	  <para>Caso seu computador seja de uma arquitetura não
	    suportada pelo FreeBSD e precise de uma
	    solução imediata, nós sugerimos uma
	    olhada no <ulink
	      url="http://www.netbsd.org/">NetBSD</ulink> ou <ulink
	      url="http://www.openbsd.org/">OpenBSD</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="which-hardware-to-get">
	  <para>Preciso adquirir um novo hardware para um sistema com
	    FreeBSD.  Qual o melhor modelo/marca/tipo?</para>
	</question>

	<answer>
	  <para>Essa é uma discussão tradicional nas
	    listas do FreeBSD.  Partindo do princípio que os
	    tipos de equipamentos e suas características
	    alteram-se de forma muita rápida, e que nós
	    tentamos suportar essas mudanças e torná-las
	    suportadas, é <emphasis>fortemente
	      recomendado</emphasis> que você sempre leia as
	    <ulink url="&rel.current.hardware;">Notas de
	      Hardware</ulink> e faça uma busca nos <ulink
	      url="http://www.freebsd.org/search/#mailinglists">histórico
	      das listas de discussão</ulink> antes de
	    perguntar sobre os melhores e mais novos equipamentos
	    disponíveis.  É muito provável que as
	    informações que você quer sobre
	    determinado equipamento tenham sido discutidas há
	    menos de uma semana.</para>

	  <para>Caso você esteja procurando
	    informações sobre
	    <foreignphrase>laptops</foreignphrase>, verifique o
	    histórico da lista FreeBSD-mobile.  Do
	    contrário, o histórico da FreeBSD-questions
	    será o mais indicado, ou de alguma lista
	    específica sobre o tipo de hardware em
	    questão.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="supported-hard-drives">
	  <para>Que tipos de discos rígido o FreeBSD
	    suporta?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta discos EIDE e SCSI (com alguma
	    controladora compatível;  veja a próxima
	    pergunta) e todos os outros discos que usam a interface de
	    controle original da <quote>Western Digital</quote> (MFM,
	    RLL, ESDI, e é claro IDE).  Algumas controladoras
	    ESDI que usam interfaces de controle proprietária
	    não funcionarão no FreeBSD: mude para
	    controladoras do tipo WD1002/3/6/7 ou algum clone dessa
	    interface.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="supported-scsi-controllers">
	  <para>Quais controladoras SCSI são suportadas pelo
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Veja a lista completa de equipamentos suportados nas
	    <ulink url="&rel.current.hardware;">Notas de
	      Hardware</ulink> atuais.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="supported-cdrom-drives">
	  <para>Quais drives de CDROM são suportados pelo
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Quaisquer drives SCSI ligados à controladoras
	    suportadas são controladas pelo FreeBSD.</para>

	  <para>As seguintes interfaces proprietárias de CDROM
	    também são suportadas:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Mitsumi LU002 (8bits), LU005 (16bits) e FX001D
		(16bits velocidade 2x (2x Speed)).</para>
	    </listitem>

	    <listitem>
	      <para>Sony CDU 31/33A.</para>
	    </listitem>

	    <listitem>
	      <para>CDROM Sound Blaster não-SCSI.</para>
	    </listitem>

	    <listitem>
	      <para>CDROM Matsushita/Panasonic.</para>
	    </listitem>

	    <listitem>
	      <para>CDROMs IDE compatíveis com o padrão
		ATAPI.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Todo equipamento não-SCSI é
	    reconhecidamente mais lento do que os SCSI, e alguns
	    drives de CDROM ATAPI podem não funcionar
	    corretamente.</para>

	  <para>A partir da versão 2.2, todos os CDROM do
	    FreeBSD distribuídos pela FreeBSD Mall podem ser
	    iniciados (booting) diretamente pela unidade de CD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="supported-cdrw-drives">
	  <para>Quais drives de CD-RW são suportados pelo
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta qualquer tipo de unidade CD-RW ou
	    CD-R IDE compatíveis com o padrão ATAPI.  No
	    FreeBSD 4.0 e posteriores, leia a página de manual
	    do &man.burncd.8;.Em versões anteriores, veja os
	    exemplos de utilização desses equipamentos
	    em <filename>/usr/share/examples/atapi</filename>.</para>

	  <para>O FreeBSD também suporta qualquer drive de CD-R
	    ou CD-RW do tipo SCSI.  Instale o aplicativo
	    <command>cdrecord</command> a partir da
	    coleção de <literal>ports</literal> ou como
	    pacote, e tenha certeza de ter o device
	    <devicename>pass</devicename> compilado no seu
	    <foreignphrase>kernel</foreignphrase>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="zip-support">
	  <para>O FreeBSD suporta ZIP Drives?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta ZIP Drives do tipo SCSI, é
	    claro.  Essa unidade deve ser configurada apenas nos SCSI
	    ID números 5 ou 6, mas se a sua BIOS tem suporte
	    &agrave inicializãço(boot) pela unidade
	    SCSI, essa característica pode ser usada sem
	    problemas.  Não está claro exatamente quais
	    adaptadores SCSI suportam a característica de
	    inicializãço(boot) em IDs diferentes de 0 ou
	    1, portanto será necessário consultar o
	    manual do seu equipamento para obter
	    informações mais precisas sobre esse
	    recurso.</para>

	  <para>Os ZIP Drives padrão ATAPI (IDE) são
	    suportados pelo FreeBSD desde a versão 2.2.6 e em
	    todas as posteriores.</para>

	  <para>O FreeBSD tem suporte ainda a ZIP Drives de Porta
	    Paralela desde a versão 3.0.  Caso seu sistema seja
	    dessa versão ou superior, verifique o suporte a
	    <devicename>scbus0</devicename>,
	    <devicename>da0</devicename>,
	    <devicename>ppbus0</devicename>,
	    <devicename>vp0</devicename> no seu
	    <foreignphrase>kernel</foreignphrase> (o
	    <foreignphrase>kernel</foreignphrase> GENERIC tem todos
	    esses suportes, exceto à device
	    <devicename>vp0</devicename>).  Com esses suportes
	    presentes no <foreignphrase>kernel</foreignphrase>, o
	    drive de Porta Paralela deve estar disponível em
	    <devicename>/dev/da0s4</devicename>.  Os discos ZIP podem
	    ser montados usando o comando <command>mount /dev/da0s4
	      /mnt</command> OU (discos formatados como DOS)
	    <command>mount_msdos /dev/da0s4 /mnt</command>, como
	    é de costume.</para>

	  <para>Verifique também o <link
	      linkend="jaz"><literal>FAQ</literal> sobre discos
	      removíveis</link> disponível ainda nesse
	    capítulo, e <link linkend="disklabel">as notas
	      sobre <quote>formatação</quote></link> no
	    capítulo de Administração.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="jaz-zip-removable-support">
	  <para>O FreeBSD suporta discos JAZ, EZ ou outras unidades
	    removíveis?</para>
	</question>

	<answer>
	  <para>Fora a versão IDE dos discos EZ, os outros
	    discos são todos do tipo SCSI, e portanto devem
	    todos ser reconhecidos como discos SCSI no FreeBSD.  O
	    drive EZ tipo IDE deve ser reconhecido como disco
	    IDE.</para>

	  <para><anchor id="jaz"/>Não há uma certeza
	    quanto à forma que o FreeBSD trata uma
	    alteração de mídia enquanto o sistema
	    está em pleno uso, então é
	    necessário desmontar a unidade antes de trocar de
	    disco e garantir que qualquer unidade externa esteja
	    ligada quando o sistema for bootado, de forma que o
	    FreeBSD possa reconhecê-las.</para>

	  <para>Veja essa <link linkend="disklabel">nota sobre
	      <quote>formatação</quote></link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multiport-serial-support">
	  <para>Que dispositivos seriais de múltiplas portas
	    são suportados pelo FreeBSD?</para>
	</question>

	<answer>
	  <para>Existe uma lista dessas unidades na
	    seção de <ulink
	      url="../handbook/install.html#INSTALL-MISC">Dispositivos
	      Diversos</ulink> do &a.ptbr.p.handbook;.</para>

	  <para>Alguns dispositivos clones parecem também
	    funcionar normalmente no sistema, em especial equipamentos
	    que se dizem ser AST compatíveis.</para>

	  <para>Verifique a página de manual do &man.sio.4; para
	    obter mais informações quanto à
	    configuração desses dispositivos.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="usbkbd">
	  <para>O FreeBSD suporta meu teclado USB?</para>
	</question>

	<answer>
	  <para>O suporte a dispositivos USB foi adicionado no FreeBSD
	    desde a versão 3.1.  Contudo, na versão 3.1,
	    o suporte ainda é muito preliminar, e alguns
	    equipamentos podem não funcionar antes da
	    versão 3.2.  Caso você queira usar o suporte
	    a teclados USB, tente o seguinte.</para>

	  <procedure>
	    <step>
	      <para>No FreeBSD 3.2 ou posterior.</para>
	    </step>

	    <step>
	      <para>Adicione as seguintes linhas no arquivo de
		configuração do seu
		<foreignphrase>kernel</foreignphrase>, e
		recompile-o.</para>

	      <programlisting>device  uhci
device  ohci
device  usb
device  ukbd
options KBD_INSTALL_CDEV</programlisting>

	      <para>Em versões anteriores à 4.0,
		use:</para>

	      <programlisting>controller      uhci0
controller      ohci0
controller      usb0
controller      ukbd0
options         KBD_INSTALL_CDEV</programlisting>
	    </step>

	    <step>
	      <para>No diretório <filename>/dev</filename>,
		crie os seguintes devices:</para>

	      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV kbd0 kbd1</userinput></screen>
	    </step>

	    <step>
	      <para>Edite o <filename>/etc/rc.conf</filename> e
		adicione as seguintes linhas:</para>

	      <programlisting>usbd_enable="YES"
usbd_flags=""</programlisting>
	    </step>
	  </procedure>

	  <para>Depois de reiniciado(rebooting) o sistema, o teclado
	    AT aparece como <devicename>/dev/kbd0i</devicename> e o
	    teclado USB aparece como
	    <devicename>/dev/kbd1</devicename> , se ambos estiverem
	    conectados ao sistema.  Se estiver somente o teclado USB,
	    ele estará como
	    <devicename>/dev/ukbd0</devicename>.</para>

	  <para>Caso queira usar o teclado USB no console, é
	    necessário informar explicitamente ao driver do
	    console que ele deve usar esse teclado.  Isso pode ser
	    feito com o seguinte comando em tempo de
	    inicialização do sistema:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>

	  <para>Note que se o teclado USB for o único teclado
	    disponível, ele será acessado via
	    <devicename>/dev/kbd0</devicename>, portanto a linha de
	    comando deve-se parecer com:</para>

	  <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd0 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>

	  <para>O arquivo <filename>/etc/rc.i386</filename> é
	    um bom lugar para colocar o comando acima.</para>

	  <para>Depois de configurado, o teclado USB deve funcionar
	    também no ambiente X, sem nenhuma outra
	    configuração especial.</para>

	  <para>Conectar e desconectar o teclado USB com o sistema
	    ligado ainda não é um comportamento
	    completamente suportado, portando é
	    aconselhável ligar o teclado antes de iniciar o
	    sistema e apenas desligá-lo depois que o computador
	    estiver desligado, para evitar possíveis
	    problemas.</para>

	  <para>Veja a página de manual do &man.ukbd.4; para
	    maiores informações.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="busmouse">
	  <para>Eu tenho um mouse de barramento não tradicional.
	    Como o configuro?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta o barramento de mouse tradicional do
	    tipo InPort fabricados pela Microsoft, Logitech e ATI.  O
	    suporte a esse periférico é compilado por
	    padrão no <foreignphrase>kernel</foreignphrase>
	    GENERIC do FreeBSD na versão 2.X, mas não
	    é suportado por padrão na versão 3.0
	    e posteriores.  Se você quer recompilar um
	    <foreignphrase>kernel</foreignphrase> com suporte ao
	    barramento de mouse, adicionando a linha ao seu arquivo de
	    configuração:</para>

	  <para>No FreeBSD 3.0 e anteriores, adicione:</para>

	  <programlisting>device mse0 at isa? port 0x23c tty irq5 vector mseintr</programlisting>

	  <para>Na série 3.X do FreeBSD, a linha deve
	    ser:</para>

	  <programlisting>device mse0 at isa? port 0x23c tty irq5</programlisting>

	  <para>E na série 4.X e posteriores, a linha deve
	    ser:</para>

	  <programlisting>device mse0 at isa? port 0x23c irq5</programlisting>

	  <para>Barramentos de mouse costumam ter uma interface
	    dedicada que permite definir o endereço de
	    memória e a IRQ que a placa vai funcionar.  Nesse
	    caso, refira-se ao manual do seu equipamento e à
	    página de manual do &man.mse.4; para maiores
	    informações.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ps2mouse">
	  <para>Como eu uso o meu mouse (<quote>mouse port</quote> ou
	    <quote>keyboard</quote>) PS/2?</para>
	</question>

	<answer>
	  <para>Em versões posteriores ao 2.2.5, o
	    <foreignphrase>kernel</foreignphrase> do FreeBSD inclui
	    por padrão o suporte ao device
	    <devicename>psm</devicename>, que controlará seu
	    mouse PS/2 desde o momento de inicialização
	    do sistema.</para>

	  <para>Caso seu FreeBSD seja 2.1.X ou similar, o suporte a
	    PS/2 pode ser incluído no
	    <foreignphrase>kernel</foreignphrase>, no momento da
	    instalação, ou mesmo depois desse processo,
	    com a opção <option>-c</option> na tela de
	    <command>boot:</command> do sistema.  O suporte nesse caso
	    é desabilitado por padrão e por isso deve
	    ser explicitamente habilitado.</para>

	  <para>Caso sua versão de FreeBSD seja antiga,
	    adicione a seguinte linha ao seu
	    <foreignphrase>kernel</foreignphrase> e
	    recompile-o:</para>

	  <para>No FreeBSD 3.0 e anteriores, a linha é:</para>

	  <programlisting>device psm0 at isa? port "IO_KBD" conflicts tty irq 12 vector psmintr</programlisting>

	  <para>No FreeBSD 3.1 e posteriores da mesma série, a
	    linha deve ser:</para>

	  <programlisting>device psm0 at isa? tty irq 12</programlisting>

	  <para>No FreeBSD 4.0 e posteriores, a linha é:</para>

	  <programlisting>device psm0 at atkbdc? irq 12</programlisting>

	  <para>Veja a seção de <ulink
	      url="../handbook/kernelconfig.html">configuração
	      do <foreignphrase>kernel</foreignphrase></ulink> no
	    &a.ptbr.p.handbook; caso você não tenha
	    experiência com a compilação do
	    <foreignphrase>kernel</foreignphrase>.</para>

	  <para>Uma vez detectado o <devicename>psm0</devicename>
	    durante a inicialização
	    (<foreignphrase>boot</foreignphrase>) do seu sistema,
	    tenha certeza de que existe uma entrada
	    <devicename>psm0</devicename> no
	    <filename>/dev</filename>.  Faça o seguinte:</para>

	  <screen>&prompt.root; <userinput>cd /dev; sh MAKEDEV psm0</userinput></screen>

	  <para>logado como usuário
	    <username>root</username>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="moused">
	  <para>É possível usar mouse de alguma forma,
	    fora do sistema X Windows?</para>
	</question>

	<answer>
	  <para>Se estiver utilizando o driver padrão de
	    console, o syscons, pode-se usar o mouse para copiar &amp;
	    colar texto.  Execute o mouse daemon,
	    <command>moused</command>, para habilitar o mouse nos
	    consoles virtuais da seguinte forma:</para>

	  <screen>&prompt.root; <userinput>moused -p /dev/<replaceable>xxxx</replaceable> -t <replaceable>yyyy</replaceable></userinput>
&prompt.root; <userinput>vidcontrol -m on</userinput></screen>

	  <para>Onde <replaceable>xxxx</replaceable> deve ser
	    substituído pelo nome de device do seu mouse e
	    <replaceable>yyyy</replaceable> pelo tipo de protocolo do
	    mesmo.  Veja a página de manual do &man.moused.8;
	    para maiores informações quanto aos tipos de
	    protocolos suportados.</para>

	  <para>É provável que você queira usar o
	    mouse daemon automaticamente, sempre que o FreeBSD for
	    iniciado.  Na versão 2.2.1, defina as seguintes
	    variáveis, no arquivo
	    <filename>/etc/sysconfig</filename>.</para>

	  <programlisting>mousedtype="yyyy"
mousedport="xxxx"
mousedflags=""</programlisting>

	  <para>Da versão 2.2.2 até a 3.0, defina as
	    seguintes variáveis no
	    <filename>/etc/rc.conf</filename>.</para>

	  <programlisting>moused_type="yyyy"
moused_port="xxxx"
moused_flags=""</programlisting>

	  <para>Da versão 3.1 em diante, caso você tenha
	    um mouse PS/2 é necessário apenas adicionar
	    a opção
	    <literal>moused_enable=&quot;YES&quot;</literal> no
	    arquivo <filename>/etc/rc.conf</filename>.</para>

	  <para>E se a intenção é usar o mouse em
	    todos os terminais virtuais ao invés de apenas no
	    console, insira a seguinte linha no
	    <filename>/etc/rc.conf</filename>.</para>

	  <programlisting>allscreens_flags="-m on"</programlisting>

	  <para>Desde a versão 2.2.6 do FreeBSD, o mouse daemon
	    é capaz de detectar o tipo de protocolo do mouse
	    automaticamente, a não ser que o dispositivo em
	    questão seja um mouse serial muito velho.  Defina
	    <literal>auto</literal> para que o programa identifique o
	    protocolo do mouse automaticamente.</para>

	  <para>Quando o daemon está rodando, o acesso ao
	    dispositivo deve ser coordenado entre ele e qualquer outra
	    aplicação, como o X-Windows, por exemplo.
	    Leia uma <link linkend="x-and-moused">outra
	      pergunta</link> sobre esse assunto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="text-mode-cut-paste">
	  <para>Como eu copio e colo com o mouse em um console modo
	    texto?</para>
	</question>

	<answer>
	  <para>Uma vez configurado o mouse (<link
	      linkend="moused">veja a pergunta anterior</link>),
	    aperte o botão 1 (botão esquerdo) do mouse e
	    mova o cursor por toda a região desejada,
	    selecionando o texto em questão.  Depois, basta
	    apertar o botão 2 (do meio) ou o botão 3
	    (direito) para colar o conteúdo selecionado
	    anteriormente.</para>

	  <para>A partir da versão 2.2.6 o botão 2 cola
	    o texto copiado, enquanto o botão 3 ``extende'' a
	    região selecionada.  Caso seu mouse não
	    tenha o botão do meio, é possível
	    remapear (ou emular) os botões do periférico
	    usando algumas opções específicas do
	    mouse daemon.  Veja a página de manual do
	    &man.moused.8; para maiores detalhes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="usbmouse">
	  <para>O FreeBSD suporta mouse USB?</para>
	</question>

	<answer>
	  <para>No FreeBSD 3.1 existe um suporte preliminar à
	    recursos USB que não funciona muito bem dependendo
	    da situação.  A partir da versão 4.0
	    o FreeBSD suporta dispositivos USB por padrão. Caso
	    queira usar um mouse USB no FreeBSD 3.X, siga as seguintes
	    instruções.</para>

	  <procedure>
	    <step>
	      <para>Atualize seu sistema para FreeBSD 3.2 ou
		posterior.</para>
	    </step>

	    <step>
	      <para>Adicione o seguinte suporte ao seu
		<foreignphrase>kernel</foreignphrase>, e
		recompile-o:</para>

	      <programlisting>device  uhci
device  ohci
device  usb
device  ums</programlisting>

	      <para>Em versões anteriores à 4.0 o
		suporte à ser adicionado é:</para>

	      <programlisting>controller        uhci0
controller        ohci0
controller        usb0
device            ums0</programlisting>
	    </step>

	    <step>
	      <para>Entre no diretório
		<filename>/dev</filename> e crie os devices
		necessários:</para>

	      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV ums0</userinput></screen>
	    </step>

	    <step>
	      <para>Edite o <filename>/etc/rc.conf</filename> e
		adicione as linhas:</para>

	      <programlisting>moused_enable="YES"
moused_type="auto"
moused_port="/dev/ums0"
moused_flags=""
usbd_enable="YES"
usbd_flags=""</programlisting>

	      <para>Veja a <link linkend="moused">seção
		  anterior</link> para uma discussão mais
		detalhada sobre o moused.</para>
	    </step>

	    <step>
	      <para>Para configurar o mouse USB no X, edite o
		<filename>XF86Config</filename> e, caso esteja usando
		o XFree86 3.3.2 ou posterior, adicione as seguintes
		linhas na seção
		<emphasis>Pointer</emphasis>:</para>

	      <programlisting>Device	  "/dev/sysmouse"
Protocol        "Auto"</programlisting>

	      <para>Caso esteja usando uma versão anterior do
		Xfree86, adicione também na seção
		<emphasis>Pointer</emphasis> as seguintes
		linhas:</para>

	      <programlisting>Device	  "/dev/sysmouse"
Protocol        "SysMouse"</programlisting>
	    </step>
	  </procedure>

	  <para>Leia também uma <link
	      linkend="x-and-moused">outra pergunta</link> sobre o uso
	    do mouse em ambiente X.</para>

	  <para>Conectar e desconectar o teclado USB com o sistema
	    ligado ainda não é um comportamento
	    completamente suportado, portando é
	    aconselhável ligar o teclado antes de iniciar o
	    sistema e apenas desligá-lo depois que o computador
	    estiver desligado, para evitar possíveis
	    problemas.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mouse-wheel-buttons">
	  <para>Eu tenho um mouse do tipo Wheel com uma rodinha e
	    botões adicionais.  Posso usá-lo no
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>A resposta, infelizmente é,
	    <quote>Depende</quote>.  Esse tipo de mouse tem algumas
	    características especiais que requerem o uso de
	    <foreignphrase>drivers</foreignphrase> especiais na
	    maioria dos casos.  A não ser que o device do seu
	    mouse tenha suporte específico, ou se a
	    aplicação em questão reconhecer esse
	    tipo de equipamento, ele irá funcionar simplesmente
	    como um mouse tradicional de dois ou três
	    botões.</para>

	  <para>Mais informações sobre o uso de mouse do
	    tipo Wheel em ambiente X Windows, refira-se a essa <link
	      linkend="x-and-wheel">seção</link>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="psmerr">
	  <para>Por que meu mouse PS/2 do tipo Wheel fica louco,
	    pulando pela tela?</para>
	</question>

	<answer>
	  <para>O suporte ao mouse PS/2 no FreeBSD 3.2 e anteriores
	    é falho quanto a mouses do tipo Wheel, incluindo o
	    modelo M-S48 da Logitech e seus similares OEM.  Aplique o
	    seguinte patch no arquivo
	    <filename>/sys/i386/isa/psm.c</filename> e recompile seu
	    <foreignphrase>kernel</foreignphrase>:</para>

	  <programlisting>Index: psm.c
===================================================================
RCS file: /src/CVS/src/sys/i386/isa/Attic/psm.c,v
retrieving revision 1.60.2.1
retrieving revision 1.60.2.2
diff -u -r1.60.2.1 -r1.60.2.2
--- psm.c        1999/06/03 12:41:13 1.60.2.1
+++ psm.c        1999/07/12 13:40:52 1.60.2.2
@@ -959,14 +959,28 @@
     sc->mode.packetsize = vendortype[i].packetsize;

     /* set mouse parameters */
+#if 0
+    /*
+     * A version of Logitech FirstMouse+ won't report wheel movement,
+     * if SET_DEFAULTS is sent...  Don't use this command.
+     * This fix was found by Takashi Nishida.
+     */
     i = send_aux_command(sc->kbdc, PSMC_SET_DEFAULTS);
     if (verbose >= 2)
         printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
+#endif
     if (sc->config & PSM_CONFIG_RESOLUTION) {
         sc->mode.resolution
             = set_mouse_resolution(sc->kbdc,
-                (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+                       (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+    } else if (sc->mode.resolution >= 0) {
+        sc->mode.resolution
+            = set_mouse_resolution(sc->kbdc, sc->dflt_mode.resolution);
+    }
+    if (sc->mode.rate > 0) {
+        sc->mode.rate = set_mouse_sampling_rate(sc->kbdc, sc->dflt_mode.rate);
     }
+    set_mouse_scaling(sc->kbdc, 1);

     /* request a data packet and extract sync. bits */
     if (get_mouse_status(sc->kbdc, stat, 1, 3) < 3) {</programlisting>

	  <para>Em versões posteriores à 3.2, o suporte
	    deve funcionar.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="laptop-mouse-trackball">
	  <para>Como eu uso o mouse/bolinha-de-rolagem/touchpad no meu
	    laptop?</para>
	</question>

	<answer>
	  <para>Por gentileza, <link linkend="ps2mouse">leia a
	      pergunta anterior</link>.  Verifique também a
	    <ulink
	      url="http://www.FreeBSD.org/docs.html#PAO">página
	      de Computação Móvel</ulink> do
	    Projeto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="tape-support">
	  <para>Que tipos de dispositivos de fitas são
	    suportados pelo FreeBSD?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta dispositivos de fitas do tipo SCSI e
	    QIC-36 (com interface QIC-02).  Tal suporte inclui drives
	    8-mm (também conhecidos como Exabyte) e unidades de
	    fita DAT.</para>

	  <para>Alguns dispositivos 8-mm mais antigos não
	    são compatíveis com o padrão SCSI-2 e
	    por isso podem não funcionar bem no FreeBSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="tape-changer-support">
	  <para>O FreeBSD suporta bibliotecas de fitas?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta alternadores (também
	    conhecidos com carrosséis) SCSI, usando o device
	    &man.ch.4; e o comando &man.chio.1;.  Os detalhes
	    relativos a como controlar o alternador de fitas podem ser
	    encontrados na página de manual do
	    &man.chio.1;.</para>

	  <para>Caso você não esteja usando o
	    <application>AMANDA</application> ou qualquer outro
	    produto que entenda o funcionamento dos alternadores,
	    lembre-se que tal equipamento simplesmente alterna a
	    posição da fita, de um compartimento para
	    outro, e portanto deve-se saber em qual compartimento a
	    fita está e para qual ela deve voltar.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sound-card-support">
	  <para>Quais placas de som são suportadas pelo
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta as placas SoundBlaster, SoundBlaster
	    Pro, SoundBlaster 16, Pro Audio Spectrum 16, AdLib e
	    Gravis UltraSound.  Existe ainda um suporte - limitado,
	    é verdade - para as placas MPU-401 e placas MIDI
	    compatíveis.  Placas de som que estiverem em
	    conformidade com a especificação MSS
	    (Microsoft Sound System) também são
	    suportadas pela controladora pcm do
	    <foreignphrase>kernel</foreignphrase>.</para>

	  <note>
	    <para>Esse suporte é específico para apenas
	      som! Exceto no caso das placas SoundBlaster, o suporte
	      não inclui controle de joysticks, CDROMs ou SCSI.
	      A interface SCSI da SoundBlaster e alguns CDROMs
	      não-SCSI são suportados, mas o sistema
	      não pode iniciar(booting) a partir desses
	      dispositivos.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="es1370-silent-pcm">
	  <para>Qual a solução para falta de som da
	    minha placa es1370 com o controlador pcm?</para>
	</question>

	<answer>
	  <para>Basta aumentar o volume do seu som ;-) Use os
	    seguintes comandos, sempre que o sistema iniciar:</para>

	  <screen>&prompt.root; <userinput>mixer pcm 100 vol 100 cd 100</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="network-cards">
	  <para>Quais placas de rede o FreeBSD suporta?</para>
	</question>

	<answer>
	  <para>Veja a seção de <ulink
	      url="../handbook/install.html#INSTALL-NICS">Placas
	      Ethernet</ulink> do &a.ptbr.p.handbook; para uma lista
	    detalhada dos dispostivos suportados.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="no-math-coprocessor">
	  <para>Eu não tenho um co-processador
	    matemático.  Isso é ruim?</para>
	</question>

	<answer>
	  <note>
	    <para>Vale apenas para proprietários de
	      386/486SX/486SLC - outras máquinas terão
	      um co-processador integrado à CPU.</para>
	  </note>

	  <para>No geral, a falta de um co-processador
	    matemático não traz nenhum problema, mas
	    existem algumas circunstâncias onde você
	    encontrará sérias limitações,
	    seja no desempenho ou na precisão da
	    emulação dos seus cálculos (veja a
	    seção de <link
	      linkend="emul">emulação FP</link>).  Por
	    exemplo, a renderização de círculos e
	    arcos no ambiente gráfico será uma tarefa
	    muito lenta.  É recomendável comprar um
	    co-processador matemático;  vale a pena.</para>

	  <note>
	    <para>Alguns co-processadores matemáticos
	      são melhores que outros. É estranho ter
	      que dizer isso, mas ninguém nunca se deu mal ao
	      comprar co-processadores Intel, portanto tenha certeza
	      absoluta que o produto vai funcionar com o FreeBSD antes
	      de comprar um clone.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="other-device-support">
	  <para>Que outros dispositivos o FreeBSD suporta?</para>
	</question>

	<answer>
	  <para>Veja o <ulink
	      url="../handbook/install.html#INSTALL-MISC">&a.ptbr.p.handbook;</ulink>
	    para obter uma listagem dos outros dispostivos
	    suportados.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="power-management-support">
	  <para>O FreeBSD suporta gerenciamento de energia no meu
	    laptop?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta <acronym>APM</acronym> em alguns
	    computadores.  Por gentileza, refira-se ao arquivo
	    <filename>LINT</filename> de configuração do
	    <foreignphrase>kernel</foreignphrase>;  procure pela
	    palavra <acronym>APM</acronym>.  Mais
	    informações na página de manual do
	    &man.apm.4;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="micron-hang-boot">
	  <para>Por que placas Micron travam na
	    inicialização(boot)?</para>
	</question>

	<answer>
	  <para>Algumas placas-mãe Micron não tem
	    conformidade na implementação de sua BIOS e
	    por isso confundem o FreeBSD no momento da
	    inicialização(boot), pois os equipamentos em
	    questão não foram configurados nos
	    endereços que a BIOS reportou.</para>

	  <para>Procure a opção <quote>Plug and Play
	      Operating System</quote> - ou algo parecido - na sua
	    BIOS e desabilite-a para corrigir o problema.  Mais
	    informações sobre esse problema podem ser
	    encontradas em <ulink
	      url="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="newer-adaptec-support">
	  <para>Por que o FreeBSD não reconhece nenhuma
	    controladora SCSI Adaptec?</para>
	</question>

	<answer>
	  <para>As séries mais novas (AIC789x) dos chips
	    Adaptec tem suporte no modo CAM SCSI, que será
	    redefinido na versão 3.0 do FreeBSD.  Na
	    versão 2.2-STABLE, você pode aplicar as
	    correções disponíveis em <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/">ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</ulink>.
	    Caso você precise instalar um sistema com essas
	    controladoras, existe um disquete de
	    inicialização(boot) com suporta a CAM,
	    disponível em <ulink
	      url="http://people.FreeBSD.org/~abial/cam-boot/">
	      http://people.FreeBSD.org/~abial/cam-boot/</ulink>.  Nos
	    dois casos leia o arquivo README antes de tomar qualquer
	    ação.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="internal-plugnplay-modem">
	  <para>Por que o FreeBSD não encontra o meu Modem Plug
	    &amp; Play interno?</para>
	</question>

	<answer>
	  <para>Será necessário adicionar o ID PnP do
	    modem na lista de drivers seriais do sistema para que ele
	    reconheça-o normalmente.  Isso requer hackear um
	    pouco o sistema.  Pra habilitar o suporte Plug &amp; Play,
	    compile um novo <foreignphrase>kernel</foreignphrase> com
	    a opção <literal>controller pnp0</literal> e
	    reinicie o seu FreeBSD.  O
	    <foreignphrase>kernel</foreignphrase> irá mostrar
	    os IDs PnP de todos os dispositivos que ele encontrar, no
	    momento da inicialização(boot).  Copie o ID
	    PnP do modem em questão para a tabela no arquivo
	    <filename>/sys/i386/isa/sio.c</filename>, por volta da
	    linha 2777.  Procure a expressão
	    <literal>SUP1310</literal> na estrutura
	    <literal>siopnp_ids[]</literal> para encontrar essa
	    tabela.  Recompile o seu
	    <foreignphrase>kernel</foreignphrase>, instale-o e
	    reinicie o sistema.  Seu modem deve ser encontrado.</para>

	  <para>Provavelmente será necessário configurar
	    o dispositivo PnP manualmente, usando o comando
	    <literal>pnp</literal> no momento do boot, como a
	    seguir:</para>

	  <programlisting>pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8</programlisting>

	  <para>para forçar detecção do
	    modem.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="support-winmodem">
	  <para>O FreeBSD suporta software modems, como os
	    Winmodems?</para>
	</question>

	<answer>
	  <para>O FreeBSD suporta alguns software modems por meio de
	    programas adicionais.  A aplicação <filename
	      role="package">comms/ltmdm</filename> disponível
	    na coleção de <literal>Ports</literal> do
	    FreeBSD suporta os modems baseados no popular chipset
	    Lucent LT.  A aplicação <filename
	      role="package">comms/mwavem</filename> suporta o modem
	    em laptops IBM Thinkpad 600 e 700.</para>

	  <para>Não é possível instalar o FreeBSD
	    via software modem, visto que os programas adicionais para
	    controlar esse equipamento só podem ser
	    configurados depois que o sistema operacional já
	    está instalado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="serial-console-prompt">
	  <para>Como eu faço para o interpretador(prompt) de
	    inicialização(boot): aparecer no console
	    serial?</para>
	</question>

	<answer>
	  <orderedlist>
	    <listitem>
	      <para>Construa um <foreignphrase>kernel</foreignphrase>
		com a opção <literal>options
		  COMCONSOLE</literal>.</para>
	    </listitem>

	    <listitem>
	      <para>Crie o arquivo /boot.config e coloque os
		caracteres <option>-P</option> como o único
		texto no arquivo.  </para>
	    </listitem>

	    <listitem>
	      <para>Desligue o teclado do computador.</para>
	    </listitem>
	  </orderedlist>

	  <para>Leia o arquivo
	    <filename>/usr/src/sys/i386/boot/biosboot/README.serial</filename>
	    para mais informações.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="micron-3comnic-failure">
	  <para>Por que a placa de rede PCI da 3Com não
	    funciona com motherboards Micron?</para>
	</question>

	<answer>
	  <para>Algumas placas-mãe Micron não tem
	    conformidade na implementação de sua BIOS e
	    por isso confundem o FreeBSD no momento do boot, pois os
	    equipamentos em questão não foram
	    configurados nos endereços que a BIOS
	    reportou.</para>

	  <para>Procure a opção <quote>Plug and Play
	      Operating System</quote> - ou algo parecido - na sua
	    BIOS e desabilite-a para corrigir o problema.</para>

	  <para>Mais informações sobre esse problema
	    podem ser encontradas em <ulink
	      url="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="smp-support">
	  <para>O FreeBSD suporta Multiprocessamento Simétrico
	    (SMP)?</para>
	</question>

	<answer>
	  <para>SMP é suportado a partir do FreeBSD 3.0-STABLE.
	    O suporte ao SMP (multiprocessamento simétrico)
	    não está disponível por padrão
	    no <foreignphrase>kernel</foreignphrase>
	    <emphasis>GENERIC</emphasis>, portanto é
	    necessário compilar um novo
	    <foreignphrase>kernel</foreignphrase> para habilitar o
	    suporte SMP.  Veja o arquivo
	    <filename>/sys/i386/conf/LINT</filename> para descobrir
	    quais opções são necessárias
	    adicionar ao seu
	    <foreignphrase>kernel</foreignphrase>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="asusk7v-boot-failure">
	  <para>O disquete de inicialização(boot) trava
	    em um computador cuja placa-mãe é a ASUS
	    K7V.  O que eu faço?</para>
	</question>

	<answer>
	  <para>Entre na configuração da BIOS da sua
	    placa e desligue a opção <quote>boot virus
	      protection</quote>.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="troubleshoot">
    <title>Resolução de Problemas</title>

    <qandaset>
      <qandaentry>
	<question id="awre">
	  <para>O que fazer quando meu disco rígido tiver bad
	    blocks?
	  </para>
	</question>

	<answer>
	  <para>Com controladoras SCSI, o drive (HD) deveria ser capaz
	    de remapear blocos ruins e corrigí-los
	    automaticamente.  Porém, muitos desses discos
	    mantém essa função desabilitada por
	    alguma razão misteriosa...</para>

	  <para>Para habilitar essa função é
	    necessário editar o primeiro modo de página
	    do dispositivo, o qual pode ser feito com o comando abaixo
	    (como <username>root</username>)</para>

	  <screen>&prompt.root; <userinput>scsi -f /dev/rsd0c -m 1 -e -P 3</userinput></screen>

	  <para>E mudando os valores de AWRE e ARRE de 0 para
	    1:-</para>

	  <programlisting>AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</programlisting>

	  <para>Os parágrafos seguintes foram enviados por Ted
	    Mittelstaedt <email>tedm@toybox.placo.com</email>:</para>

	  <para>Para os discos IDE, qualquer bad block é
	    considerado um sinal de dificuldade em potencial.  Todos
	    os discos IDE modernos já vêm com um
	    remapeador interno que realoca bad blocks por outros
	    blocos em bom estado, automaticamente.  Todos os disco
	    rígido IDE fabricados hoje em dia oferecem
	    garantias extensas.</para>

	  <para>Se ainda quiser tentar salvar um drive IDE com bad
	    blocks, pode fazer um download do programa de
	    diagnóstico e correção do
	    próprio fabricante do disco rígido.
	    Às vezes estes programas podem fixar e
	    forçar eletronicamente o disco a marcar estes
	    blocos ruins e desativá-los.</para>

	  <para>Em discos ESDI, RLL e MFM, a existência de bad
	    blocks é normal e não representa nenhum
	    sinal de dificuldade,geralmente.  Em um PC, a placa
	    controladora das unidades de disco e, a BIOS se encarregam
	    da tarefa de re-mapear os bad blocks.  Isso funciona em
	    sistemas operacionais como DOS que usa código da
	    BIOS para acessar o disco.  Porém, o driver
	    (software controlador) do FreeBSD não trabalha ou
	    acessa comandos da BIOS para para interagir com o drive
	    (HD), então um mecanismo chamado bad144, existente
	    no FreeBSD, acaba substituindo esta funcionalidade.  O
	    bad144 só trabalha com o drive wd (portanto,
	    não é suportado no FreeBSD 4.0), e
	    não pode ser usado com drive SCSI.  O bad144
	    trabalha marcando e organizando setores ruins encontrados
	    no HD, em um arquivo especial no disco.</para>

	  <para>Uma característica do bad144 - o bloco
	    danificado é colocado em um arquivo especial
	    situado na última trilha do disco.  Como este
	    arquivo contém uma lista de setores defeituosos que
	    pode incluir valores perto do início do disco, onde
	    o /kernel pode estar alocado, esse arquivo deverá
	    ser acessível ao bootstrap para que o programa -
	    por meio da BIOS - leia o
	    <foreignphrase>kernel</foreignphrase>;  isso significa que
	    o disco usado com bad144 não deve exceder 1024
	    cilindros, 16 cabeças, e 63 setores, logo, temos um
	    limite efetivo de 500MB para discos mapeados com o
	    bad144..</para>

	  <para>Para ativar o uso do bad144, simplesmente defina a
	    opção de procurar por <quote>Bad
	      Block</quote> como ON na tela do fdisk do FreeBSD,
	    durante a instalação.  Essas
	    instruções funcionam a partir do FreeBSD
	    2.2.7, e o disco deve ter menos que 1024 cilindros.
	    Geralmente recomenda-se que a unidade de disco esteja em
	    operação durante pelo menos 4 horas antes de
	    executar o bad144, permitindo assim a expansão
	    térmica do HD.</para>

	  <para>Se o disco tem mais de 1024 cilindros (como um disco
	    ESDI grande) a controladora ESDI usa um tipo de
	    tradução especial em modo DOS.  A device wd
	    também entende esses mesmos modos de
	    tradução e conversão, isso se o
	    <quote>tradutor</quote> de geometria for ativado como
	    <quote>geometria fixa</quote>, quando particionado pelo
	    fdisk.  Você também não deve usar o
	    modo <quote>dangerously dedicated</quote> para criar
	    partições do FreeBSD, pois isso ignora o
	    tipo de geometria.  Embora o fdisk use a geometria
	    definida pelo usuário, ele continua reconhecendo o
	    tamanho verdadeiro do disco, e tentará criar uma
	    partição maior para o FreeBSD.  Se a
	    geometria de disco for alterada para geometria
	    traduzida(translated geometry), a partição
	    DEVE ser criada manualmente, informando os números
	    de blocos do HD.</para>

	  <para>Um truque rápido é usar um disco grande
	    ESDI com uma controladora ESDI, iniciar(booting) o sistema
	    com um disco DOS e formatar uma partição
	    DOS.  Depois reiniciar o sistema com um disco de
	    instalação do FreeBSD, e anotar o
	    número e tamanho dos blocos que serão
	    apresentados na tela do fdisk para a
	    partição DOS.  Redefina a geometria do disco
	    com os valores anotados, apague a partição
	    DOS e crie uma partição FreeBSD
	    <quote>cooperativa</quote>.  Defina essa
	    partição como bootável e habilite o
	    reconhecimento de bad blocks.  Na
	    instalação, o bad144 é carregado
	    antes que qualquer outro sistema de arquivos seja criado
	    (você pode ver isso com um
	    <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F2</keycap></keycombo>).
	    Se houver problemas na criação do arquivo de
	    definições de setor danificado (o arquivo de
	    badsector) é porque a geometria definida é
	    maior do que o seu valor real - reinicie o sistema e
	    comece todos os procedimentos novamente, inclusive o
	    particionamento e formatação da
	    partição DOS.</para>

	  <para>Se o remapeamento já estiver habilitado e os
	    problemas com bad block continuarem, considere a
	    substituição imediata do disco, pois os
	    danos e os bad blocks aumentarão consideravelmente
	    com o passar do tempo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bustek742a-eisa-scsi">
	  <para>Por que o FreeBSD não reconhece a minha
	    controladora SCSI EISA Bustek 742a?</para>
	</question>

	<answer>
	  <para>As informações a seguir são para
	    o modelo 742a, mas provavelmente também servem para
	    as placas Buslogic.  (Bustek = Buslogic).</para>

	  <para>Existem duas <quote>versões</quote>
	    tradicionais da placa 742a.  São os equipamentos de
	    revisão A-G e de revisão H;  as letras de
	    cada revisão são colocadas depois do
	    número de fabricação, ao lado das
	    placas.  A placa 742a possui 2 chips ROM acoplados, o
	    primeiro é o chip da BIOS e o segundo é o do
	    Firmware.  Para o FreeBSD a versão da BIOS é
	    irrelevante, mas a versão do Firmware é uma
	    informação fundamental.  É
	    interessante dizer que, se você fizer uma chamada ao
	    departamento de suporte da Buslogic, eles irão te
	    enviar um upgrade desses ROMs, e é muito bom sempre
	    manter a versão mais recente do ROM do seu Firmware
	    para a versão de revisão do seu
	    equipamento.</para>

	  <para>As placas cuja letra de revisão é A-G
	    aceitam apenas atualizações da BIOS/Firmware
	    de versão 2.41/2.21 respectivamente.  A
	    revisão H (REV H) aceita as versões mais
	    recentes da BIOS/Firmware até a versão
	    4.70/3.37.  A principal diferença entre as
	    versões do Firmware é que a versão
	    3.37 tem suporte a<quote>round robin</quote>.</para>

	  <para>As placas Buslogic também tem um número
	    serial.  Caso seu equipamento seja antigo, tente abrir uma
	    chamada no departamento de RMA da Buslogic e informe-os o
	    número de série da sua placa.  Se ela
	    estiver entre os seriais de abrangência, a Buslogic
	    vai aceitar seu equipamento para revisão.</para>

	  <para>O FreeBSD 2.1 aceita apenas as revisões de
	    Firmware até o 2.21.  Caso o seu Firmware seja mais
	    antigo do que o 2.21 sua placa não será
	    reconhecida como Buslogic.  Contudo, é
	    possível que o equipamento seja reconhecido como
	    Adaptec 1540, já que os Firmware mais antigos da
	    Buslogic possuem um modo de
	    <quote>emulação</quote> da AHA1540, o que
	    não é uma boa coisa, para uma placa
	    EISA.</para>

	  <para>Caso seu Firmware seja antigo e você conseguiu
	    obter uma revisão para a versão 2.21,
	    não se esqueça que é
	    necessário alterar o jumper W1 da
	    posição A-B (padrão) para
	    posição B-C ao atualizar a placa.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="hpnetserver-scsi-failure">
	  <para>Por que o FreeBSD não detecta a controladora
	    SCSI do Netserver HP??</para>
	</question>

	<answer>
	  <para>Isso já é um problema conhecido.  A
	    controladora SCSI on-board EISA dos servidores HP
	    Netserver estão no slot EISA número 11,
	    portanto todos os <quote>verdadeiros</quote> slots EISA
	    estão na sua frente.  O endereço definido
	    para os slots EISA &gt;= 10 ocupa um endereço
	    compartilhado com o barramento PCI, e portanto entra em
	    conflito com seus recursos.  Essa é uma
	    situação onde a configuração
	    automática do FreeBSD não se comporta muito
	    bem.</para>

	  <para>Portanto o que você deve fazer, é fingir
	    que não existe limitação quanto ao
	    intervalo de endereços, definindo a
	    opção option <literal>EISA_SLOTS</literal>
	    do <foreignphrase>kernel</foreignphrase> para o valor 12.
	    Configure e compile um novo
	    <foreignphrase>kernel</foreignphrase>, conforme descrito
	    no <ulink
	      url="../handbook/kernelconfig.html">capítulo de
	      configuração do
	      <foreignphrase>kernel</foreignphrase> no
	      &a.ptbr.p.handbook;</ulink>.</para>

	  <para>Obviamente esse problema é ainda maior quando
	    se trata de uma nova instalação.  Para
	    corrigir esse problema é necessário uma
	    pequena alteração no modo
	    <emphasis>UserConfig</emphasis>.  Não use a
	    interface de configuração
	    <quote>visual</quote> do
	    <foreignphrase>kernel</foreignphrase>, use a Interface de
	    Linha de Comando (CLI), simplesmente digitando:</para>

	  <programlisting>eisa 12
quit</programlisting>

	  <para>na tela do modo CLI, e continue a
	    instalação do FreeBSD como de costume.  De
	    qualquer forma, é recomendável recompilar e
	    instalar um novo <foreignphrase>kernel</foreignphrase>
	    depois da instalação do sistema..</para>

	  <para>Futuras versões do FreeBSD terão esse
	    problema corrigido automaticamente.</para>

	  <note>
	    <para>Não use discos em modo <literal>dangerously
		dedicated</literal> com um HP Netserver.  Veja <link
		linkend="dedicate">essa nota</link> para maiores
	      informações.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cmd640-ide">
	  <para>O que está havendo com minha controladora IDE
	    CMD640?</para>
	</question>

	<answer>
	  <para>Está com defeito!  Não suporta mais
	    comandos nos dois canais de forma simultânea.</para>

	  <para>Existe uma correção disponível e
	    automaticamente habilitada, se você usa uma
	    controladora com esse chip.  Para maiores detalhes,
	    refira-se a página de manual da controladora de
	    disco (&man.wd.4;).</para>

	  <para>Se o FreeBSD em questão é o FreeBSD
	    2.2.1 ou 2.2.2 com essa controladora em questão, e
	    você quer usar o segundo canal, compile um novo
	    <foreignphrase>kernel</foreignphrase> com a
	    opção <literal>options "CMD640"</literal>
	    habilitada.  Essa configuração é
	    padrão para o FreeBSD 2.2.5 e posteriores.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ed1-timeout">
	  <para>Eu sempre vejo mensagens como <errorname>ed1:
	      timeout</errorname>.  O que elas significam?</para>
	</question>

	<answer>
	  <para>Normalmente esse problema é causado por um
	    conflito de interrupções (por exemplo, duas
	    placas usando a mesma IRQ).  O FreeBSD até a
	    versão 2.0.5R costumava ser tolerante quanto a esse
	    problema e a placa de rede continuava funcionando mesmo
	    com IRQ conflitantes.  Contudo desde a versão
	    2.0.5R os conflitos de interrupções
	    não são mais tolerados.  Inicie o sistema
	    com a opção de boot -c e mude as device
	    ed0/de0/...  para o valor correspondente ao da
	    placa.</para>

	  <para>Caso esteja usando um conector BNC na sua placa de
	    rede, é provável que existam device timeout
	    por causa de má terminação do
	    barramento.  Pra tirar isso a limpo coloque um terminador
	    direto na placa (sem cabos) e veja se as mensagens de erro
	    param.</para>

	  <para>Algumas placas compatíveis NE2000
	    apresentarão esse problema caso a porta UTP
	    não receba sinal de link, ou se o cabo estiver
	    desconectado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bad-3c509">
	  <para>Por que minha placa 3COM 3C509 parou de funcionar sem
	    motivo aparente?</para>
	</question>

	<answer>
	  <para>Esse cartão tem um hábito
	    horrível de perder suas informações
	    de configuração.  Redefina as
	    informações da placa usando o programa de
	    DOS chamado <command>3c5x9.exe</command>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="printer-slow">
	  <para>Minha impressora paralela está ridiculamente
	    lenta.  O que devo fazer?</para>
	</question>

	<answer>
	  <para>Se o único problema é a lerdeza
	    terrível da sua impressora, tente mudar seu <ulink
	      url="../handbook/printing-intro-setup.html#PRINTING-PARALLEL-PORT-MODE">modo
	      da porta de impressão</ulink> conforme discutido
	    na seção de <ulink
	      url="../handbook/printing-intro-setup.html">Configuração
	      de Impressoras</ulink> no &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="signal11">
	  <para>Por que alguns programas ocasionalmente morrem com
	    erro de <errorname>Signal 11</errorname> ?</para>
	</question>

	<answer>
	  <para>Erros de sinal 11 são fruto de tentativas de
	    acesso indevido a memória.  Esse acesso normalmente
	    é controlado pelo sistema operacional, e quando o
	    sistema não permite acessar determinados
	    endereços, o processo é morto com signal 11.
	    Se isso estiver acontecendo em intervalos
	    aleatórios de tempo, é preciso investigar as
	    causas com cuidado.</para>

	  <para>Esse problema normalmente é atribuído
	    a:</para>

	  <orderedlist>
	    <listitem>
	      <para>Se o problema ocorre apenas em um programa
		específico que você mesmo esta
		desenvolvendo, se trata de um bug no código do
		seu programa.</para>
	    </listitem>

	    <listitem>
	      <para>Se o problema é com algum programa que faz
		parte da base do FreeBSD, é possível que
		também seja um problema de bug no código
		em questão.  Contudo, esses problemas costumam
		ser corrigidos antes que os usuários
		tradicionais percebam sua existência - e
		necessitem ler este <literal>FAQ</literal> - afinal,
		é para isso que o -CURRENT existe.</para>
	    </listitem>
	  </orderedlist>

	  <para>Em especial, uma indicação que esse
	    problema <emphasis>não</emphasis> é um bug
	    do FreeBSD, é um erro repetitivo no mesmo instante
	    da compilação, mas o problema que o
	    compilador apresenta muda de linha a cada nova
	    compilação.</para>

	  <para>Por exemplo, suponha que você esteja executando
	    um <quote>make buildworld</quote>, e a
	    compilação falha na hora de compilar o
	    <filename>ls.c</filename> em <filename>ls.o</filename>. Se
	    você rodar o <quote>make buildworld</quote> de novo
	    e a compilação falha exatamente no mesmo
	    trecho do código, então o problema realmente
	    é com o fonte da aplicação, nesse
	    caso atualize os fontes do FreeBSD e tente novamente.
	    Agora se a compilação falhar em um trecho
	    diferente do código, é quase certo que o
	    problema seja físico, ou seja, com o seu
	    equipamento.</para>

	  <para>O que deve ser feito:</para>

	  <para>Em primeiro lugar, deve-se usar um debugador, como o
	    gdb, por exemplo, para encontrar o ponto exato do
	    código que está tentando acessar um
	    endereço problemático de memória, e
	    corrigi-lo.</para>

	  <para>Em segundo lugar, verifique se a culpa não
	    é do seu equipamento.</para>

	  <para>As causas mais comuns para o problema incluem::</para>

	  <orderedlist>
	    <listitem>
	      <para>Os seus discos rígidos podem estar
		superaquecidos: Verifique se o sistema de
		ventilação do seu PC está
		funcionando.  Verifique coolers internos (da fonte) e
		externos, e verifique se não existe
		superaquecimento de outros componentes do
		computador.</para>
	    </listitem>

	    <listitem>
	      <para>O processador está superaquecido: Pode ser
		porque foi feito um overclock no processador em
		questão, ou no caso mais tradicional, pode ser
		que o cooler tenha parado de funcionar ou que esteja
		sujo e portanto funcionando em rotação
		baixa.  Em ambos os casos, o primeiro passo é
		garantir que o processador esteja rodando sob as
		mesmas condições que ele foi
		construído para funcionar - por exemplo, com a
		velocidade do clock original e com a
		ventilação adequada.</para>

	      <para>Caso tenha sido feito overclock no processador,
		lembre-se que é mais barato usar um computador
		um pouco mais lento, do que trocar o processador da
		máquina por causa de um chip fritado ;-)
		Além do que a maioria das pessoas não
		são simpatizantes de overclock, mesmo que
		você considere a ação segura ou
		não.</para>
	    </listitem>

	    <listitem>
	      <para>Caso tenha múltiplos pentes de
		memória SIMM/DIMM, tente desligá-los e
		experimente usar cada pente de uma vez,
		indiviualmente.  Com isso é possível
		descobrir se o problema é com algum chip
		DIMM/SIMM ou se o problema é a
		combinação entre os pentes.</para>
	    </listitem>

	    <listitem>
	      <para>Configurações super otimistas na
		BIOS da sua placa mãe são outra causa
		provável.  Algumas BIOS tem
		opções que permitem alterar a velocidade
		e frequência de vários recursos.
		Normalmente os valores padrão na BIOS
		são os mais conservadores, e portanto devem ser
		o bastante para controlar corretamente o equipamento;
		contudo algumas opções como por exemplo
		<quote>RAM Speed: Turbo</quote> ou alguma
		opção parecida coloca o estado de espera
		para o acesso a memória em um valor muito
		baixo, e as vezes, por mais otimista que você
		seja, sua memória pode não ser
		rápida o bastante.  O ideal é definir os
		valores padrão da sua BIOS, mas é
		interessante anotar os valores atuais primeiro!</para>
	    </listitem>

	    <listitem>
	      <para>Alimentação insuficiente de energia
		na placa-mãe.  Caso exista alguma placa que
		não esteja sendo utilizada, algum disco
		rígido ou CDROM, é interessante
		desliga-los temporariamente do computador, ou
		simplesmente remover o cabo de energia desses
		equipamentos.  Mesmo em sub utilização,
		essas placas e discos estão sob constante
		alimentação e talvez sua fonte consiga
		suprir uma carga menor.  Ou tente trocar a fonte do
		seu PC, de preferência por uma com maior poder
		de alimentação (por exemplo, se a sua
		fonte é de 250 Watts troque por uma de 300
		Watts).</para>
	    </listitem>

	  </orderedlist>

	  <para>Leia ainda o <literal>FAQ</literal> SIG11
	    (disponível a seguir) que tem outras boas
	    explicações sobre esses problemas.  O
	    <literal>FAQ</literal> também discute como alguns
	    programas de teste de memória podem pensar que um
	    pente problemático está funcionando
	    corretamente.</para>

	  <para>Finalmente, se nenhum dos casos acima ajudou a
	    solucionar seu problema, pode ser que exista um bug no
	    FreeBSD.  Você deve seguir as
	    intruçõoes para enviar um relatório
	    de problemas para o Projeto FreeBSD.</para>

	  <para>Existe um <literal>FAQ</literal> extenso que cobre
	    esse assunto, disponível <ulink
	      url="http://www.bitwizard.nl/sig11/"> no
	      <literal>FAQ</literal> dos problemas com
	      SIG11.</ulink></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="trap-12-panic">
	  <para>O meu sistema trava com o erro <errorname>Fatal trap
	      12: page fault in kernel mode</errorname>, ou
	    <errorname>panic:</errorname>, e sai mostrando uma
	    quantidade enorme de informações.  O que eu
	    faço?</para>
	</question>

	<answer>
	  <para>A equipe de desenvolvimento do FreeBSD tem muito
	    interesse nesse tipo de erro, mas é
	    necessário obter algumas informações
	    suplementares, do que apenas o erro que você
	    está tendo.  Copie sua mensagem de erro inteira,
	    consulte o <literal>FAQ</literal> sobre <link
	      linkend="kernel-panic-troubleshooting"><foreignphrase>kernel</foreignphrase>
	      panics</link>, compile um
	    <foreignphrase>kernel</foreignphrase> em modo de
	    debugação e tente analisar o problema.
	    Parece uma tarefa difícil, mas não é
	    necessário conhecimento de
	    programação; basta seguir as
	    instruções.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="screen-loses-sync">
	  <para>Por que a tela fica preta e perde sincronia quando eu
	    inicio o sistema?</para>
	</question>

	<answer>
	  <para>Esse é um problema conhecido da placa de
	    vídeo ATI Mach 64.  O problema é que essa
	    placa usa o endereço <literal>2e8</literal>, o
	    mesmo utilizado pela quarta porta serial dos computadores
	    pessoais.  Devido a um bug (ou uma vantagem?) da
	    &man.sio.4; ,essa porta será sempre reconhecida,
	    ainda que não exista a quarta porta serial no seu
	    computador, ou <emphasis>mesmo</emphasis> se o sio3 (a
	    quarta porta) estiver desabilitado.</para>

	  <para>Até que o bug seja corrigido, você pode
	    usar essa solução:</para>

	  <orderedlist>
	    <listitem>
	      <para>Entre no modo de configuração do
		<foreignphrase>kernel</foreignphrase> com
		opção <option>-c</option> na tela de
		inicialização(boot).  (Isto colocara o
		<foreignphrase>kernel</foreignphrase> no modo de
		configuração).</para>
	    </listitem>

	    <listitem>
	      <para>Desabilite a <devicename>sio0</devicename>,
		<devicename>sio1</devicename>,
		<devicename>sio2</devicename> e
		<devicename>sio3</devicename> (todas elas).  Dessa
		forma será ativada, logo, você não
		terá -&gt; problemas.</para>
	    </listitem>

	    <listitem>
	      <para>Digite exit para continuar o boot.</para>
	    </listitem>
	  </orderedlist>

	  <para>Caso queira usar as portas seriais, será
	    necessário construir um
	    <foreignphrase>kernel</foreignphrase> customizado, com as
	    seguintes alterações: no fonte
	    <filename>/usr/src/sys/i386/isa/sio.c</filename> encontre
	    a ocorrência da expressão
	    <literal>0x2e8</literal> e apague essa expressão e
	    a vírgula que a antecede (mantenha a outra).
	    Depois compile o novo
	    <foreignphrase>kernel</foreignphrase> normalmente.</para>

	  <para>Mesmo depois dessa correção, é
	    provável que o X Windows ainda não funcione
	    como esperado.  Se for o caso, garanta que a versão
	    do Xfree86 em questão seja ao menos o XFree86 3.3.3
	    ou uma versão superior.   Esse XFree86 e os
	    posteriores tem suporte nativo às placas de
	    vídeo Mach64, e tem inclusive um X Server dedicado
	    para tal equipamento.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="reallybigram">
	  <para>Por que o FreeBSD só detecta 64MB de
	    memória RAM se eu tenho 128MB instalados?</para>
	</question>

	<answer>
	  <para>Devido à maneira que o FreeBSD obtém as
	    informações quanto ao tamanho da
	    memória disponível por intermédio da
	    BIOS, pode acontecer de apenas 16 bits válidos
	    serem detectados (65535 Kbytes = 64MB) ou até
	    menos, dependendo da BIOS (em alguns casos, apenas 16MB).
	    Mesmo nessa situação o FreeBSD tenta
	    detectar mais que 64MB de memória, mas esse
	    reconhecimento pode falhar.</para>

	  <para>Pra corrigir esse problema pode ser usada a
	    opção do
	    <foreignphrase>kernel</foreignphrase> descrita a seguir.
	    Existe uma forma de obter informações
	    completas quanto ao tamanho da memória, a partir da
	    BIOS, mas devido a algumas limitações isso
	    nem sempre é possível hoje em dia.
	    Futuramente será.  De qualquer forma, temos ainda a
	    opção do
	    <foreignphrase>kernel</foreignphrase> para
	    situações onde toda a memória
	    não puder ser reconhecida.</para>

	  <para><literal>options
	      "MAXMEM=<replaceable>n</replaceable>"</literal></para>

	  <para>Onde <replaceable>n</replaceable> equivale à
	    memória (em Kilobytes) disponível no
	    sistema.  Para 128 MB de memória, use o valor
	    <literal>131072</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="panic-kmemmap-too-small">
	  <para>Por que o FreeBSD 2.0 entre em pânico com a
	    mensagem <errorname>kmem_map too
	      small!</errorname>?</para>
	</question>

	<answer>
	  <note>
	    <para>A mensagem em questão também pode ser
	      <literal>mb_map too small!</literal></para>
	  </note>

	  <para>Essa mensagem de pânico indica que o sistema
	    ficou sem memória suficiente pros buffers de rede
	    (especificamente, os mbuf clusters).  A quantidade de
	    memória virtual disponível para os clusters
	    mbuf pode ser elevada com a opção::</para>

	  <para><literal>options
	      "NMBCLUSTERS=<replaceable>n</replaceable>"</literal></para>

	  <para>no arquivo de configuração do seu
	    <foreignphrase>kernel</foreignphrase>, onde
	    <replaceable>n</replaceable> equivale ao valor entre
	    512-4096, dependendo do número de conexões
	    TCP simultâneas que você espera poder
	    suportar.  O valor 2048 é recomendável, e
	    provavelmente será o bastante para sanar o problema
	    que causa o pânico em questão O número
	    de clusters mbuf em uso pode ser monitorado com o comando
	    <command>netstat -m</command> (veja &man.netstat.1;).  O
	    valor padrão para a variável NMBCLUSTERS no
	    <foreignphrase>kernel</foreignphrase> do FreeBSD é
	    <literal>512 + MAXUSERS * 16</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="proc-table-full">
	  <para>Por que o erro <errorname>/kernel: proc: table is
	      full</errorname>ocorre?</para>
	</question>

	<answer>
	  <para>O <foreignphrase>kernel</foreignphrase> do FreeBSD
	    limita o número máximo de processos
	    simultâneos existentes no sistema.  O número
	    em questão é baseado na opção
	    <literal>MAXUSERS</literal>.  do sistema.  A
	    opção <literal>MAXUSERS</literal> afeta
	    ainda inúmeros outros limites do
	    <foreignphrase>kernel</foreignphrase> do FreeBSD, como por
	    exemplo os buffers disponíveis para o stack de rede
	    do sistema (veja <link
	      linkend="panic-kmemmap-too-small">esta</link> resposta
	    anterior).  Se o computador estiver sob grande carga,
	    provavelmente será necessário aumentar o
	    <literal>MAXUSERS</literal>.  Essa alteração
	    aumentará os limites do sistema em
	    adição ao número de processos
	    permitido.</para>

	  <para>Desde a versão 4.4 do FreeBSD, o valor para
	    <literal>MAXUSERS</literal> se tornou configurável,
	    não sendo mais necessário recompilar o
	    <foreignphrase>kernel</foreignphrase> para
	    alterá-lo, bastando definir a variável
	    <varname>kern.maxusers</varname> no arquivo
	    <filename>/boot/loader.conf</filename>.  Em
	    versõoes mais recentes do FreeBSD, deve-se ajustar
	    o <literal>MAXUSERS</literal> em sua
	    configuração do
	    <foreignphrase>kernel</foreignphrase>.</para>

	  <para>Caso seu sistema não esteja muito carregado,
	    mas o número de processos simultâneos ainda
	    assim é alto basta definir a variável
	    <varname>kern.maxproc</varname> com o sysctl.  Em casos
	    especiais, onde esses inúmeros processos
	    estão sendo executados por um único
	    usuário, será preciso alterar ainda alterar
	    o valor da variável
	    <varname>kern.maxprocperuid</varname> para um a menos do
	    que o valor de <varname>kern.maxproc</varname>.  (deve ser
	    ao menos 1 processo a menos, visto que ao menos o
	    &man.init.8; do sistema vai estar sempre em
	    execução.)</para>

	  <para>Para tornar uma alteração de
	    variável do sysctl permanente, defina-a no arquivo
	    <filename>/etc/sysctl.conf</filename> nas versões
	    mais recentes do FreeBSD, ou então no arquivo
	    <filename>/etc/rc.local</filename> em versões mais
	    antigas do sistema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cmap-busy-panic">
	  <para>Por que acontece o erro <errorname>CMAP
	      busy</errorname> quando eu reinicio com um novo
	    <foreignphrase>kernel</foreignphrase>?</para>
	</question>

	<answer>
	  <para>A lógica que tenta detectar uma data errada nos
	    arquivos <filename>/var/db/kvm_*.db</filename> as vezes
	    é falha, o que leva o sistema a entrar em
	    pânico.</para>

	  <para>Se for o caso, reinicie seu sistema em modo
	    monousuário e faça:</para>

	  <screen>&prompt.root; <userinput>rm /var/db/kvm_*.db</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="brkadrint-illegal-host-access">
	  <para>O que a mensagem <errorname>ahc0: brkadrint, Illegal
	      Host Access at seqaddr 0x0</errorname>
	    significa??</para>
	</question>

	<answer>
	  <para>Trata-se de um conflito com o Ultrastor SCSI Host
	    Adapter.</para>

	  <para>Durante o processo de
	    inicialização(boot), entre no menu de
	    configuração do
	    <foreignphrase>kernel</foreignphrase> e desabilite a
	    <devicename>uha0</devicename>, que esta causando o
	    problema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="aci0-illegal-cable">
	  <para>Quando eu inicio o sistema, encontro o erro
	    <errorname>ahc0: illegal cable configuration</errorname>,
	    mas o meu cabo está certo.  O que está
	    havendo?</para>
	</question>

	<answer>
	  <para>A placa-mãe em questão não
	    consegue se dar bem com o suporte a
	    terminação automática do barramento.
	    Altere sua BIOS SCSI para a terminação
	    correta, de acordo com a configuração do
	    equipamento, ao invés de usar
	    terminação automática.  O driver
	    AIC7XXX não consegue descobrir se o reconhecimento
	    externo dos cabos (e conseq&uuml;ente
	    auto-terminação) está
	    disponível, e portanto ele simplesmente assume que
	    o suporte existe, caso a configuração da
	    EEPROM serial esteja definida como automatic termination.
	    Sem o reconhecimento de cabo externo o driver irá
	    sempre configurar a terminação de forma
	    incorreta, o que compromete a confiabilidade do barramento
	    SCSI.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mail-loopback">
	  <para>Por que o Sendmail retorna um erro que diz
	    <quote><errorname>mail loops back to
		myself</errorname></quote>?</para>
	</question>

	<answer>
	  <para>Essa pergunta é respondida no
	    <literal>FAQ</literal> do próprio Sendmail, e
	    diz:-</para>

<literallayout>        * Eu estou tendo problemas de configurações local "Local configuration error" como essas:

        553 relay.domain.net config error: mail loops back to myself
        554 &lt;user@domain.net&gt;...  Local configuration error

	Como posso resolver esse problema?

	Você definiu que as mensagens enviadas para o domínio
	em questão (domain.net) devem ser repassadas para uma outra
	estação específica (nesse caso para
	relay.domain.net) usando um registro MX, mas essa máquina de
	relay não se reconhece como a estação
	responsável pelas mensagens do domínio domain.net.
	Adicione domain.net no arquivo /etc/mail/local-host-names
	(caso você esteja usando FEATURE(use_cw_file)) ou então
	adicione a linha "Cw domain.net" em /etc/mail/sendmail.cf.
            </literallayout>

	  <para>Atualmente a versão mais recente do <ulink
	      url="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq"><literal>FAQ</literal>
	      do sendmail</ulink> é mantida em sincronia com as
	    versões mais atuais do MTA, mas ela ainda é
	    enviada regularmente para os grupos de notícias
	    <ulink
	      url="news:comp.mail.sendmail">comp.mail.sendmail</ulink>,
	    <ulink url="news:comp.mail.misc">comp.mail.misc</ulink>,
	    <ulink url="news:comp.mail.smail">comp.mail.smail</ulink>,
	    <ulink url="news:comp.answers">comp.answers</ulink>, e
	    <ulink url="news:news.answers">news.answers</ulink>.
	    Ainda é possível receber um cópia por
	    e-mail do <literal>FAQ</literal>, enviando uma mensagem
	    para <email>mail-server@rtfm.mit.edu</email> com o comando
	    <literal>send
	      usenet/news.answers/mail/sendmail-faq</literal> no corpo
	    da mensagem.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="remote-fullscreen">
	  <para>Porque algumas aplicações que usam tela
	    inteira não se comportam muito bem em
	    estações remotas?</para>
	</question>

	<answer>
	  <para>A estação remota deve estar definindo o
	    terminal como algum tipo diferente do
	    <literal>cons25</literal> que é o tipo de terminal
	    usado pelo console do FreeBSD.</para>

	  <para>Existem inúmeras correções para
	    esse problema:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Depois de logar-se na estação
		remota, defina a variável de ambiente TERM como
		<literal>ansi</literal> ou <literal>sco</literal> caso
		a máquina em questão tenha
		informações quanto a esse tipo de
		terminal.</para>
	    </listitem>

	    <listitem>
	      <para>Use um emulador VT100 como o
		<application>screen</application> no console do
		FreeBSD.  O <application>screen</application> oferece
		a possibilidade de usar múltiplas
		sessões concorrentes em um mesmo terminal, e
		é um grande programa.  Cada janela do
		<application>screen</application>  se comporta como um
		terminal VT100, portanto a variável TERM deve
		ser definida como <literal>vt100</literal>.</para>
	    </listitem>

	    <listitem>
	      <para>Instale a base do <literal>cons25</literal> na
		estação remota.  A maneira correta de
		faze-lo depende do sistema operacional em
		questão na estação remota.
		Consulte os manuais de administração do
		sistema remoto em questão para descobrir como
		faze-lo.</para>
	    </listitem>

	    <listitem>
	      <para>Levante um X server do lado FreeBSD da coisa e
		acesse a estação remota usando um
		terminal baseado no ambiente X, como o
		<command>xterm</command> ou o <command>rxvt</command>.
		A variável TERM deve ser definida
		como<literal>xterm</literal> ou
		<literal>vt100</literal> no lado remoto.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="calcru-negative">
	  <para>Por que meu computador apresenta a mensagem
	    <errorname>calcru: negative time...</errorname>?</para>
	</question>

	<answer>
	  <para>Esse comportamento pode ser causado por diversos
	    motivos relacionados a interrupções de
	    <foreignphrase>hardware</foreignphrase> e/ou software.
	    Pode ser devido a algum bug, mas também pode
	    acontecer por causa da natureza de alguns devices.  Por
	    exemplo, usar TCP/IP via porta paralela com uma MTU muito
	    grande é uma boa forma de provocar esse
	    comportamento.  Aceleradores gráficos também
	    são eficientes para criar esse tipo de problema,
	    nesse caso, sendo necessário analisar as
	    configurações de interrupções
	    do software.</para>

	  <para>Um efeito colateral desse problema são
	    processos que morrem<quote>SIGXCPU exceeded cpu time
	      limit</quote>.</para>

	  <para>No FreeBSD 3.0 e sistemas posteriores a 29 de Novembro
	    de 1998, caso o problema não possa ser solucionado
	    de outra forma, uma correção pode ser
	    definir a seguinte variável do sysctl:</para>

	  <screen>&prompt.root; <userinput>sysctl -w kern.timecounter.method=1</userinput></screen>

	  <para>Isso causa um impacto de performance, mas dependendo
	    do problema que causava esse comportamento, é
	    provável que nem consiga-se notar a mudança
	    nessa performance.  Se o problema continuar, mantenha a
	    variável do sysctl habilitada e defina a
	    opção <literal>NTIMECOUNTER</literal> no
	    <foreignphrase>kernel</foreignphrase> para valores
	    crescentes.  Se chegar a um ponto em que foi
	    necessário definir
	    <literal>NTIMECOUNTER=20</literal> e o problema ainda
	    não tiver sido resolvido, as
	    interrupções são serias demais e seu
	    comportamento não é confiável.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="pcm0-not-found">
	  <para>Acontece da pcm não ser encontrada, com a
	    mensagem <errorname>pcm0 not found</errorname> ou
	    então minha placa de som é encontrada na
	    <devicename>pcm1</devicename> mas no meu
	    <foreignphrase>kernel</foreignphrase> a entrada se refere
	    a <literal>device pcm0</literal>.  O que está
	    havendo?</para>
	</question>

	<answer>
	  <para>Isso acontece no FreeBSD 3.X com placas de som PCI.  A
	    <devicename>pcm0</devicename> é reservada
	    exclusivamente para placas de som ISA e por isso se a
	    placa em questão é PCI, ela será
	    reconhecida como <devicename>pcm1</devicename> e a
	    mensagem em questão pode acontecer.
	  </para>

	  <note>
	    <para>Não é possível evitar a
	      mensagem de advertência simplesmente alterando o
	      seu <foreignphrase>kernel</foreignphrase> e definindo
	      <literal>device pcm1</literal> pois isso
	      resultará na <devicename>pcm1</devicename> sendo
	      reservada para placas ISA, e o seu equipamento PCI
	      será reconhecido na <devicename>pcm2</devicename>
	      (e a mensagem de advertência <errorname>pcm1 not
		found</errorname> continuará).</para>
	  </note>

	  <para>
	    Caso sua placa de som seja PCI ainda será preciso
	    criar a device <devicename>snd1</devicename> ao
	    invés da <devicename>snd0</devicename>:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV snd1</userinput></screen>

	  <para>Esse comportamento não ocorre na série
	    4.X do FreeBSD, muito trabalho foi feito para tornar o
	    sistema mais <emphasis>PnP-centric</emphasis> e a device
	    <devicename>pcm0</devicename> não é mais
	    reservada exclusivamente para placas ISA.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="pnp-not-found">
	  <para>Porque a minha placa PnP não é mais
	    encontrada (ou é encontrada como
	    <literal>unknown</literal>) desde a
	    atualização para o FreeBSD 4.X?</para>
	</question>

	<answer>
	  <para>O FreeBSD 4.X é muito mais
	    <emphasis>PnP-centric</emphasis> do que as versões
	    anteriores, e isso causou alguns efeitos distintos em
	    algumas placas PnP (como algumas placas de som e alguns
	    modems interno por exemplo) que não funcionam mais
	    da forma como funcionavam no FreeBSD 3.X.</para>

	  <para>O motivo para esse comportamento é explicado no
	    seguinte e-mail, que foi enviada na lista
	    freebsd-questions pelo Reter Wemm, respondendo uma
	    pergunta sobre um modem interno que não era mais
	    reconhecido no FreeBSD depois de atualizar o sistema para
	    versão 4.X (os comentários entre
	    <literal>[]</literal>foram adicionados com a
	    intenção de explicar melhor o contexto da
	    mensagem).</para>

	  <note>
	    <para>Os índices dessa citação foram
	      atualizados de seu texto original</para>
	  </note>

	  <blockquote>
	    <para>A bios PNP configurou ele [o modem] e o deixou
	      conectado na porta em questão, por isso o estilo
	      antigo [no 3.X] <quote>reconhece</quote> o equipamento
	      ISA.</para>

	    <para>No FreeBSD 4 o código ISA é bem mais
	      PnP-centric.  Era possível [no 3.X] encontrar uma
	      placa ISA que funcionava com <quote>determinada</quote>
	      device e depois, o id PNP da mesma device encontrava a
	      mesma placa novamente, como se fosse uma outra usando os
	      mesmos recursos do sistema, e por isso ele falhava, como
	      se fosse um conflito de recursos.  Portanto, agora ele
	      desabilita o suporta às placas
	      programáveis de forma que essa confusão e
	      dupla detecção de
	      <foreignphrase>hardware</foreignphrase> não
	      ocorra.  Essa mudança implica também na
	      necessidade de se saber previamente os ids PnP para cada
	      tipo de equipamento suportado, aumentando um pouco mais
	      a lista de TODO do suporte PnP no sistema.</para>
	  </blockquote>

	  <para>Para fazer o equipamento voltar a funcionar, é
	    necessário encontrar seu PnP id e
	    adicioná-lo a lista de devices ISA reconhecidas
	    como PnP.  Essa informação pode ser obtida
	    usando &man.pnpinfo.8; que detecta a
	    configuração dos equipamentos.  Por exemplo,
	    veja a saída do &man.pnpinfo.8; de um modem
	    interno:</para>

	  <screen>&prompt.root; <userinput>pnpinfo</userinput>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug & Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
        Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
        [16-bit addr]
    IRQ: 4  - only one type (true/edge)</screen>

	  <para>[algumas linhas com TAG foram eliminadas]</para>

	  <screen>TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01</screen>

	  <para>A informação que você quer
	    é a linha <quote>Vendor ID</quote> no começo
	    da saída do comando.  O valor hexadecimal entre
	    parênteses (0x3024a341 esse caso) é PnP id e
	    o conjunto de caracteres que o antecede (PMC2430) é
	    a identificação ASCII única.</para>

	  <para>Alternativamente, se o &man.pnpinfo.8; não
	    listou sua placa em questão, o &man.pciconf.8; pode
	    ser usado preferivelmente.  Esta é a saída
	    do comando <command>pciconf -vl</command> de uma placa de
	    som onboard:</para>

	  <screen>&prompt.root; <userinput>pciconf -vl</userinput>
chip1@pci0:31:5:        class=0x040100 card=0x00931028 chip=0x24158086 rev=0x02 hdr=0x00
    vendor   = 'Intel Corporation'
    device   = '82801AA 8xx Chipset AC'97 Audio Controller'
    class    = multimedia
    subclass = audio</screen>

	  <para>Aqui deve-se usar o valor do <varname>chip</varname>,
	    <quote>0x24158086</quote>.</para>

	  <para>Tais informações (Vendor ID ou valor do
	    chip) precisam ser adicionadas ao arquivo
	    <filename>/usr/src/sys/isa/sio.c</filename>.</para>

	  <para>Primeiro faça uma cópia de
	    segurança do <filename>sio.c</filename> no caso de
	    algo dar errado e também para que você possa
	    fazer um patch para enviar junto com o seu
	    Relatório de Problemas (você vai enviar um
	    PR, não vai?) e depois edite o
	    <filename>sio.c</filename> e procure a linha</para>

	  <programlisting>static struct isa_pnp_id sio_ids[] = {</programlisting>

	  <para>Depois analise as linhas logo abaixo para encontrar o
	    lugar apropriado para sua placa.  As entradas na tabela
	    ficam todas parecidas com essa logo abaixo, e são
	    ordenadas de acordo com a identificação
	    ASCII do fabricante do produto a qual deve ser
	    incluída como comentário na coluna do lado
	    do código em questão, e junto com a
	    <emphasis>descrição da placa</emphasis> ou
	    parte dela, conforme identificada na saída do
	    &man.pnpinfo.8;:</para>

	  <programlisting>{0x0f804f3f, NULL},     /* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},     /* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},     /* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},     /* ROK0010 - Rockwell ? */
{0x5002734a, NULL},     /* RSS0250 - 5614Jx3(G) Internal Modem */</programlisting>

	  <para>Adicione o ID hexadecimal do fabricante da placa no
	    local apropriado, salve o arquivo e recompile o
	    <foreignphrase>kernel</foreignphrase>, depois reinicie o
	    sistema.  Agora a sua placa deve ter sido encontrada como
	    uma device <literal>sio</literal> exatamente como era
	    encontrada no FreeBSD 3.X</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="nlist-failed">
	  <para>Qual a causa do erro <errorname>nlist
	      failed</errorname> quando eu executo, por exemplo, o
	    <command>top</command> ou o
	    <command>systat</command>?</para>
	</question>

	<answer>
	  <para>O problema é que o programa que você
	    está tentando executar tenta ler alguma
	    informação específica do
	    <foreignphrase>kernel</foreignphrase>, baseando-se no
	    <foreignphrase>kernel</foreignphrase> symbol em
	    questão, mas por algum motivo, essa
	    informação não pode ser encontrada;
	    esse erro é causado por um dos seguintes
	    problemas:</para>

	  <itemizedlist>
	    <listitem>
	      <para>O <foreignphrase>kernel</foreignphrase> e o
		userland do sistema não estão em
		sincronia (por exemplo, você compilou um
		<foreignphrase>kernel</foreignphrase> novo e o
		instalou sem de dar um
		<maketarget>installworld</maketarget>, ou vice-versa),
		e por isso a tabela de informações dos
		<foreignphrase>kernel</foreignphrase> symbols é
		diferente do que o programa pensa que é.  Se
		esse for o caso basta completar os procedimentos de
		atualização do sistema (veja o arquivo
		<filename>/usr/src/UPDATING</filename> para a correta
		seq&uuml;ência de ações).</para>
	    </listitem>

	    <listitem>
	      <para>O <command>/boot/loader</command> não
		está sendo usado para carregar o
		<foreignphrase>kernel</foreignphrase> dessa
		estação, ao invés dele, o boot2
		(veja &man.boot.8;) está sendo usado
		diretamente.  Apesar de não ter problema algum
		deixar de usar o <command>/boot/loader</command>, ele
		costuma se comportar melhor na hora de tornar os
		<foreignphrase>kernel</foreignphrase> symbols
		disponíveis para aplicações em
		nível de usuário.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="connection-delay">
	  <para>Porque demora tanto para a conexão se
	    estabelecer via <command>ssh</command> ou
	    <command>telnet</command>?</para>
	</question>

	<answer>
	  <para>O sintoma: existe um atraso muito grande entre o
	    estabelecimento da conexão TCP e o momento que o
	    programa cliente pede a senha (ou no caso do
	    &man.telnet.1;, quando a tela de login aparece).</para>

	  <para>O problema: o programa servidor dessa
	    transação leva muito tempo tentando resolver
	    o nome da estação cliente que está se
	    conectando.  A maioria dos servidores, incluindo os
	    servidores Telnet e SSH que vem junto com o FreeBSD tentam
	    resolver o número IP do cliente no nome da
	    estação, para, entre outras coisas, gravar
	    essa informação em um arquivo de log para
	    referências futuras por parte do
	    administrador.</para>

	  <para>A solução: Se o problema acontece apenas
	    quando você (o cliente) tenta se conectar no
	    servidor, o problema é com o lado cliente da
	    transação; se o problema acontece com
	    qualquer estação que tente se conectar ao
	    computador (servidor) então o problema é do
	    lado servidor.</para>

	  <para>Se o problema é com o cliente, a única
	    maneira de corrigir o problema é configurar
	    corretamente o servidor DNS que responde autoritativamente
	    pelo endereço da estação.  Se for uma
	    rede local considere esse comportamento um problema do
	    servidor, e continue lendo;  se a conexão deve ser
	    estabelecida na rede global (internet) , então
	    entre em contato com o seu Provedor de Serviços
	    Internet e solicite que eles corrijam o problema.</para>

	  <para>Se o problema é do lado servidor, e a rede em
	    questão, se trata de uma rede local, será
	    necessário configurar o servidor de forma que ele
	    consiga resolver os endereços dos clientes em
	    nomes.  Veja as páginas de manual do &man.hosts.5;
	    e &man.named.8; para obter mais informações.
	    Se a conexão é na Internet, provavelmente o
	    resolvedor (lado cliente do serviço de nomes) do
	    seu servidor não está funcionando
	    corretamente.  Pra fazer o teste, tente descobrir o
	    endereço IP do site <hostid>www.yahoo.com</hostid>
	    por exemplo.  Se não funcionar, esta ai o
	    problema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="stray-irq">
	  <para>O que a mensagem <errorname>stray IRQ</errorname> quer
	    dizer?</para>
	</question>

	<answer>
	  <para>Stray IRQs são sintomas de
	    <foreignphrase>hardware</foreignphrase> que interrompe o
	    pedido de interrupção no meio de um ciclo de
	    autorização de
	    interrupção.</para>

	  <para>Existem três formas de tratar o problema:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Aprenda a conviver com as mensagens de
		advertência.  De qualquer forma, todas as
		mensagens exceto as 5 primeiras para cada IRQ
		são suprimidas pelo sistema mesmo.</para>
	    </listitem>

	    <listitem>
	      <para>Evite o inconveniente alterando de 5 para 0 na
		função
		<function>isa_strayintr()</function> o número
		de mensagens antes de suprimir as
		advertências.</para>
	    </listitem>

	    <listitem>
	      <para>Evite as advertências instalando algum
		equipamento de porta paralela que use a IRQ 7 e o
		driver PPP (é o usual, na maioria dos sistemas)
		e instale algum driver IDE ou qualquer outro
		dispositivo que use a IRQ 15 e seu respectivo
		suporte.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="file-table-full">
	  <para>Por que a mensagem <errorname>file: table is
	      full</errorname> aparece repetidas vezes no
	    dmesg?</para>
	</question>

	<answer>
	  <para>
	    Esse erro indica que você excedeu o número
	    máximo de descrevedores (descriptors) de arquivos
	    no sistema.  Leia a seção <ulink
	      url="../handbook/configtuning-kernel-limits.html#KERN-MAXFILES">
	      kern.maxfiles </ulink>da<ulink
	      url="../handbook/configtuning-kernel-limits.html">
	      capítulo de Ajuste de Limites do
	      <foreignphrase>Kernel</foreignphrase></ulink> no
	    &a.ptbr.p.handbook; do FreeBSD para obter mais
	    informações sobre o problema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="laptop-clock-skew">
	  <para>Por que o relógio do meu laptop mantem a hora
	    incorreta?</para>
	</question>

	<answer>
	  <para>Rode o comando &man.dmesg.8;, e procure algumas linhas
	    com a expressão  <literal>Timecounter</literal>.  A
	    última linha encontrada será o
	    relógio que o FreeBSD escolheu, e com certeza ele
	    será <literal>TSC</literal>.</para>

	  <screen>&prompt.root; <userinput>dmesg | grep Timecounter</userinput>
Timecounter "i8254"  frequency 1193182 Hz
Timecounter "TSC"  frequency 595573479 Hz</screen>

	  <para>Essa informação pode ser confirmada ao
	    verificar a variável
	    <varname>kern.timecounter.hardware</varname> do
	    &man.sysctl.3;.</para>

	  <screen>&prompt.root; <userinput>sysctl kern.timecounter.hardware</userinput>
kern.timecounter.hardware: TSC</screen>

	  <para>A BIOS do laptop altera a frequência do
	    relógio TSC de forma a modificar a velocidade do
	    processador quando o computador estiver sendo utilizado
	    com baterias, ou se o mesmo entrar em modo de economia de
	    energia.  O FreeBSD não faz distinção
	    entre frequência do clock e modos especiais de
	    trabalho, e por isso pode atrasar ou adiantar a hora do
	    sistema.</para>

	  <para>Esse exemplo, o laptop em questão tem dois
	    relógios; portanto o <literal>i8254</literal> pode
	    ser definido como padrão na variável
	    <varname>kern.timecounter.hardware</varname> do
	    &man.sysctl.3;.</para>

	  <screen>&prompt.root; <userinput>sysctl -w kern.timecounter.hardware=i8254</userinput>
kern.timecounter.hardware: TSC -&gt; i8254</screen>

	  <para>Agora o seu laptop deve conseguir manter a data e hora
	    de forma mais precisa.</para>

	  <para>Pra tornar essa alteração
	    automática, adicione a seguinte linha no arquivo
	    <filename>/etc/sysctl.conf</filename>.</para>

	  <programlisting>kern.timecounter.hardware=i8254</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="null-null">
	  <para>Por que o meu laptop não funciona muito bem na
	    hora de identificar cartões PCMCIA?</para>
	</question>

	<answer>
	  <para>Esse problema é comum em laptops que tem mais
	    de um sistema operacional instalado.  Alguns sistemas
	    não-BSD fazem os cartões PCMCIA ficarem em
	    um estado inconsistente, causando um reconhecimento
	    problemático dos dispositivos por parte do
	    <command>pccardd</command>, como por exemplo, detectando
	    os cartões como
	    <errorname>"(null)""(null)"</errorname> ao invés da
	    sua marca e modelo verdadeiros.</para>

	  <para>É necessário desligar completamente a
	    alimentação de energia do equipamento para
	    garantir que o mesmo seja completamente resetado.
	    Desligue completamente o laptop (não suspenda seu
	    funcionamento, não o deixe entrar em modo de
	    espera, conhecido como standby, a
	    alimentação deve ser completamente
	    interrompida), espere alguns - poucos - minutos e reinicie
	    o laptop.  Tudo deve correr bem.</para>

	  <para>Alguns laptops são grandes mentirosos quando
	    afirmam estar desligados.  Se o procedimento acima
	    não funcionar, tire a bateria do laptop, espere
	    alguns minutos e ligue o sistema novamente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="boot-read-error">
	  <para>Por que o bootloader do FreeBSD mostra a mensagem
	    <errorname>Read error</errorname> e pára
	    completamente logo após a tela da BIOS?</para>
	</question>

	<answer>
	  <para>O inicializador do FreeBSD reconheceu a geometria de
	    disco de forma incorreta e por isso esse valor deve ser
	    definido manualmente com o fdisk(8) ao criar ou modificar
	    uma partição FreeBSD.</para>

	  <para>A geometria correta do disco pode ser verificada na
	    BIOS do computador.  Procure pelo número de
	    cilindros, cabeças e de setores do disco em
	    questão.
	  </para>

	  <para>No fdisk do &man.sysinstall.8;, aperte a tecla
	    <keycap>G</keycap> para definir a geometria do disco
	    manualmente.
	  </para>

	  <para>Irá aparecer uma janela de diálogo
	    perguntando o número de cilindros, cabeças e
	    setores do disco.  Defina esses valores, conforme anotados
	    da BIOS do sistema e separados por barras.</para>

	  <para>5000 cilindros, 250 cabeças e 60 setores, por
	    exemplo, seria definido como
	    <userinput>5000/250/60.</userinput>
	  </para>

	  <para>Aperte ENTER para confirmar os valores e depois aperte
	    a tecla <keycap>W</keycap> para escrever as novas
	    informações na tabela de
	    partições do disco.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bootmanager-restore">
	  <para>Outro sistema operacional destruiu o meu gerenciador
	    de inicialização(Boot Manager).  Como eu o
	    recupero?
	  </para>
	</question>

	<answer>
	  <para>Entre no &man.sysinstall.8; e escolha o menu
	    Configure, seguido do Fdisk.  Escolha o disco onde o
	    gerenciador de boot costumava ficar e aperte a barra de
	    <keycap>espaços(space)</keycap>.  Depois aperte a
	    tecla <keycap>W</keycap> para escrever as novas
	    informações no disco.  Vai aparecer uma
	    tela, perguntando o que deve ser instalado na MBR do
	    disco.  Escolha o Gerenciador de
	    inicialização(Boot Manager), e ele
	    será reinstalado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="indefinite-wait-buffer">
	  <para>O que o erro <errorname>swap_pager: indefinite wait
	      buffer:</errorname> quer dizer?</para>
	</question>

	<answer>
	  <para>Quer dizer que existe um processo tentando paginar uma
	    área da memória para o disco, e que esse
	    processo demorou mais de 20 segundos;  portanto falhou.
	    É provável que a causa desse erro sejam
	    blocos defeituosos no disco, falha nos cabos, ou
	    até mesmo algum outro erro de I/O relacionado ao
	    <foreignphrase>hardware</foreignphrase>.  Se o disco
	    estiver danificado, serão apresentadas mensagens de
	    erro referentes ao mesmo em
	    <filename>/var/log/messages</filename>  e também na
	    saída do <command>dmesg</command>.  Do
	    contrário, verifique seus cabos e
	    conectores.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="commercial">
    <title>Aplicações Comerciais</title>

      <note>
	<para>Esta seção se encontra ainda muito
	escassa, embora esperamos, naturalmente, que as empresas
	façam adições a ela!  :) Os
	desenvolvedores do FreeBSD não tem interesses
	financeiros em nenhuma das empresas listadas aqui, mas apenas
	as listam como um serviço público (e sente que o
	interesse comercial no FreeBSD pode ter muitos efeitos
	positivos na viabilidade do uso do sistema a longo prazo).
	Nós encorajamos que os vendedores de softwares
	comerciais mandem seus softwares para inclusão.
	Consulte <ulink url="../../../../commercial/index.html"> a
	  página de Fabricantes</ulink> para obter uma lista
	maior.</para>
      </note>

    <qandaset>
      <qandaentry>
	<question id="officesuite">
	  <para>Onde eu posso conseguir <foreignphrase>Office
	      Suite</foreignphrase>) para o FreeBSD?</para>
	</question>
	<answer>
	  <itemizedlist>
  	    <listitem>
	      <para><ulink url="http://www.freebsdmall.com/">A FreeBSD
		  Mall</ulink> oferece uma versão nativa do
		<ulink
		  url="http://www.vistasource.com/">VistaSource</ulink>
		ApplixWare 5 para o FreeBSD.</para>

	      <para>O ApplixWare é uma poderosa suíte
		comercial de aplicações para
		escritório no FreeBSD.  Ela contém um
		processador de texto, planilha de cálculos, um
		programa de apresentação e um pacote
		para desenho vetorial e outros aplicativos.</para>

	      <para>O ApplixWare é vendido com parte integrante
		da edição de Desktops BSD da FreeBSD
		Mall.</para>
  	    </listitem>

	    <listitem>
	      <para>A versão para Linux do <ulink
		  url="http://www.sun.com/staroffice/">StarOffice</ulink>
		funciona sem problemas no FreeBSD.  A maneira mais
		fácil de instalar a versão para Linux do
		StarOffice é pela <ulink
		  url="../handbook/ports.html">Coleção
		  de <literal>Ports</literal> do FreeBSD</ulink>.
		Versões futuras da suíte Open-Source de
		escritório,<ulink
		  url="http://www.openoffice.org/">OpenOffice</ulink>
		deverão funcionar também.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="motif">
	  <para>Onde posso conseguir o Motif para o FreeBSD?</para>
	</question>

	<answer>
	  <para>O Open Group lançou o código fonte do
	    Motif 2.1.30, que pode ser instalado como o pacote
	    <literal>open-motif</literal>, ou então ser
	    compilado pelo <literal>Ports</literal>.  Consulte a
	    <ulink url="../handbook/ports.html"> seção
	      sobre o <literal>Ports</literal> no
	      &a.ptbr.p.handbook;</ulink> para obter mais
	    informações sobre o assunto.

	    <note>
	      <para>O Open Motif pode ser redistribuído apenas
		se sua distribuição estiver sendo usada
		em sistemas operacionais <ulink
		  url="http://www.opensource.org/">open
		  source</ulink>.</para>
	    </note>
	  </para>

	  <para>Em contrapartida, existem distribuições
	    comerciais do Motif disponíveis.  Tais
	    distribuições contudo não são
	    gratuitas, mas suas licenças permitem que ele seja
	    utilizando em softwares de código fechado.  Contate
	    a <link linkend="apps2go">Apps2go</link> para obter
	    informações quanto a versão mais
	    barata do ELF Motif 2.1.20 para FreeBSD (tanto para i386
	    quanto para Alpha).<anchor id="apps2go"/></para>

	  <para>Existem duas distribuições, a
	    <quote>development edition</quote> e a <quote>runtime
	      edition</quote> (bem mais barata).  Tais
	    distribuições incluem:</para>

	  <itemizedlist>
	    <listitem>
	      <para>OSF/Motif manager, xmbind, panner, wsm.</para>
	    </listitem>

	    <listitem>
	      <para>Kit de Desenvolvimento com uil, mrm, xm, xmcxx,
		arquivos include e arquivos.</para>
	    </listitem>

	    <listitem>
	      <para>Bibliotecas ELF estáticas e dinâmicas
		(para serem usadas com FreeBSD 3.0 e
		superiores).</para>
	    </listitem>

	    <listitem>
	      <para>Applets de demonstração.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Lembre-se de especificar que você quer a
	    versão para FreeBSD do Motif quando encomendado
	    (não esqueça de mencionar a arquitetura que
	    você quer também)!  Versões para
	    NetBSD e OpenBSD também são vendidas pela
	    <emphasis>Apps2go</emphasis>.  Atualmente o produto
	    é apenas disponível para download via
	    FTP.</para>

	  <variablelist>
	    <varlistentry>
	      <term>Mais informações:</term>
	      <listitem>
		<para><ulink url="http://www.apps2go.com/">
		    Página WWW da Apps2go</ulink></para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para>
		  <email>sales@apps2go.com</email> ou
		  <email>support@apps2go.com</email>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para>fone [EUA] (817) 431 8775 ou +1 817
		  431-8775</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Contate <link linkend="metrox">Metro Link</link> para
	    obter informações quanto a versão ELF
	    ou a versão a.out do Motif 2.1 para o
	    FreeBSD.</para>

	  <para>Tal distribuição inclui:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Gerenciador OSF/Motif, xmbind, panner, wsm.</para>
	    </listitem>

	    <listitem>
	      <para>Kit de desenvolvimento com uil, mrm, xm, xmcxx,
		arquivos include e arquivos Imake.</para>
	    </listitem>

	    <listitem>
	      <para>Bibliotecas estáticas e dinâmicas
		(não se esqueça de especificar que
		você quer o formato ELF, caso queira usar com o
		FreeBSD 3.0 e posteriores; ou o formato a.out para
		usar com FreeBSD 2.2.8 e anteriores).</para>
	    </listitem>

	    <listitem>
	      <para>Applets de Demonstração.</para>
	    </listitem>

	    <listitem>
	      <para>Páginas de manual previamente
		formatadas.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Certifique-se de especificar que você quer a
	    versão para FreeBSD do Motif quando
	    encomendá-lo!  Versões para Linux
	    também são vendidas pela <emphasis>Metro
	      Link</emphasis>.  O produto está
	    disponível em CDROM ou download via FTP.</para>

	  <para>Contate a <link linkend="xig">Xi Graphics</link> para
	    obter informações quanto a versão
	    a.out do Motif 2.0 para o FreeBSD.</para>

	  <para>A distribuição inclui:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Gerenciador OSF/Motif, xmbind, panner, wsm.</para>
	    </listitem>

	    <listitem>
	      <para>Kit de desenvolvimento com uil, mrm, xm, xmcxx,
		arquivos include e arquivos Imake.</para>
	    </listitem>

	    <listitem>
	      <para>Bibliotecas estáticas e dinâmicas
		(para o FreeBSD 2.2.8 e anteriores).</para>
	    </listitem>

	    <listitem>
	      <para>Applets de Demonstração.</para>
	    </listitem>

	    <listitem>
	      <para>Páginas de manual previamente
		formatadas.</para>
	    </listitem>
	  </itemizedlist>

	  <para>certifique-se de especificar que você quer a
	    versão para FreeBSD do Motif quando
	    encomendá-lo!  Versões para BSDI e para
	    Linux também são vendidas pela <emphasis>Xi
	      Graphics</emphasis>.  Atualmente o produto se trata de
	    um conjunto de 4 disquetes...  futuramente se
	    tornará uma distribuição única
	    em CD, como o CDE da mesma empresa.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cde">
	  <para>Onde posso adquirir o CDE para o FreeBSD?</para>
	</question>

	<answer>
	  <para><link linkend="xig">A Xi Graphics</link> costumava
	    vender o CDE para o FreeBSD, mas não o faz
	    mais.</para>

	  <para><ulink url="http://www.kde.org/">O KDE</ulink>
	    é um Desktop de código fonte aberto para X11
	    similar ao CDE em muitos aspectos.  Talvez você
	    também aprecie o visual e as características
	    do <ulink url="http://www.xfce.org/">xfce</ulink>.  KDE e
	    xfce estão ambos disponíveis no <ulink
	      url="../../../../ports/index.html">sistema de
	      <literal>ports</literal> do FreeBSD</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="commercial-xserver">
	  <para>Existe algum servidor X comercial de
	    alta-performance?</para>
	</question>

	<answer>
	  <para>Sim, a <ulink url="http://www.xig.com/">Xi
	      Graphics</ulink> e a <ulink
	      url="http://www.metrolink.com/">Metro Link</ulink>
	    vendem produtos da Accelerated-X para o FreeBSD e para
	    outros sistemas baseados em Intel.</para>

	  <para>O que a Metro Link oferece é um servidor X de
	    alta-performance que possui um esquema de
	    configuração extremamente fácil,
	    fazendo uso da suíte de ferramentas de
	    gerenciamento de pacotes do FreeBSD, com suporte a
	    múltiplas placas de vídeo simultâneas
	    e é distribuído apenas em forma
	    binária, por meio conveniente de um download via
	    FTP.  Sem esquecer que, o produto oferecido pela Metro
	    Link está disponível a um preço muito
	    razoável, $39 dólares.<anchor
	      id="metrox"/></para>

	  <para>A Metro Link vende também o Motif e formato ELF
	    e a.out para o FreeBSD (veja pergunta anterior).</para>

	  <variablelist>
	    <varlistentry>
	      <term>informações:</term>
	      <listitem>
		<para><ulink url="http://www.metrolink.com/">
		    Página WWW da Metro Link</ulink></para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para><email>sales@metrolink.com</email> ou
		  <email>tech@metrolink.com</email>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para>fone [EUA] (954) 938-0283 ou +1 954
		  938-0283</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>O produto oferecido pela Xi Graphics é um
	    servidor X de alta performance, que oferece uma interface
	    fácil de configuração e com suporte a
	    múltiplas placas de vídeo simultâneas,
	    e é distribuído apenas de forma
	    binária em uma distribuição
	    única para FreeBSD e Linux.  A Xi Graphics oferece
	    ainda um servidor X de alta performance com suporte
	    desenvolvido especificamente para laptops.<anchor
	      id="xig"/></para>

	  <para>Existe uma versão
	    de<quote>demonstração de
	      compatibilidade</quote> disponível na
	    versão 5.0 do servidor gráfico.</para>

	  <para>A Xi Graphics vende ainda o Motif e o CDE para o
	    FreeBSD (veja acima).</para>

	  <variablelist>
	    <varlistentry>
	      <term>Mais informações:</term>
	      <listitem>
		<para><ulink url="http://www.xig.com/"> Página
		    WWW da Xi Graphics</ulink></para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para><email>sales@xig.com</email> ou
		  <email>support@xig.com</email>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ou</term>
	      <listitem>
		<para>fone [EUA] (800) 946 7433 ou +1 303
		  298-7478.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="database-systems">
	  <para>Existe algum sistema de Banco de Dados para o
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Sim!  Veja a seção de <ulink
	      url="../../../../commercial/software_bycat.html#CATEGORY_DATABASE">
	      Fabricantes Comerciais</ulink> do Web site do
	    FreeBSD.</para>

	  <para>Dê uma olhada também na
	    seção de <ulink
	      url="../../../../ports/databases.html">
	      Databases</ulink> da Coleção de
	    <literal>Ports</literal> do FreeBSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="oracle-support">
	  <para>Posso rodar o Oracle no FreeBSD?</para>
	</question>

	<answer>
	  <para>Pode.  As páginas a seguir descrevem exatamente
	    como configurar o Oracle para Linux no FreeBSD:</para>

	  <itemizedlist>
	    <listitem>
	      <para><ulink
		  url="http://www.scc.nl/~marcel/howto-oracle.html">
		  http://www.scc.nl/~marcel/howto-oracle.html</ulink></para>
	    </listitem>

	    <listitem>
	      <para><ulink
		  url="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd">
		  http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</ulink></para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="applications">
    <title>Aplicações de Usuário</title>

    <qandaset>
      <qandaentry>
	<question id="user-apps">
	  <para>Então, onde estão todas as
	    aplicações de usuários?</para>
	</question>

	<answer>
	  <para>Por gentileza, dê uma olhada <ulink
	      url="../../../../ports/index.html">na página do
	      <literal>Ports</literal></ulink> para
	    informações sobre pacotes de programas
	    disponíveis na Coleção de
	    <literal>Ports</literal> do FreeBSD.  A lista atualmente
	    ultrapassa &os.numports; aplicações e
	    está crescendo diariamente, então retorne
	    à página e verifique freq&uuml;entemente as
	    aplicações, ou entã inscreva-se na
	    lista de discussão
	    <literal>freebsd-announce</literal> <link
	      linkend="mailing">mailing list</link> para
	    atualizações periódicas ou novas
	    adições.</para>

	  <para>A maioria dos <literal>ports</literal> devem estar
	    disponíveis para as versões 2.2, 3.x e 4.x,
	    e muitos deles devem funcionar também em sistemas
	    2.1.x.  Cada vez que um lançamento do FreeBSD
	    é produzido, um
	    <foreignphrase>snapshot</foreignphrase> da árvore
	    do <literal>ports</literal> do momento da
	    lançamento também é incluída
	    no diretório <filename>ports/</filename>.</para>

	  <para>O FreeBSD também suporta o conceito de
	    <quote>pacote</quote>, que essencialmente nada mais
	    é do que uma distribuição
	    binária compactada com o gzip e com um pouco de
	    inteligência extra embutido nesse pacote, para fazer
	    o trabalho que é requerido para uma
	    instalação customizada.  Um pacote pode ser
	    instalado e desinstalado repetidas vezes de forma
	    fácil, sem ter que se conhecer os detalhes
	    horrendos dos arquivos que ele inclui.</para>

	  <para>Use o menu de instalação de pacotes em
	    <filename>/stand/sysinstall</filename> (sobre a
	    opção do pos-configuration menu) ou invoque
	    o comando &man.pkg.add.1; nos arquivos de pacotes
	    específicos  que voc;ê quer instalar.  Os
	    pacotes podem ser identificados normalmente pelo sufixo
	    <filename>.tgz</filename> e o pessoal da
	    distribuição em CDROM tem um
	    diretório <filename>/packages/All </filename> no cd
	    que conté esses arquivos.  Eles podem também
	    ser baixados pela rede para várias versões
	    do FreeBSD nos seguintes endereços: do (sobre a
	    opção PostConfiguration do menu) ou invoque
	    o comando &man.pkg.add.1;</para>

	  <variablelist>
	    <varlistentry>
	      <term>para o 2.2.8-RELEASE/2.2.8-STABLE </term>
	      <listitem>
		<para><ulink
		    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</ulink></para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>para o 3.X-RELEASE/3.X-STABLE</term>
	      <listitem>
		<para><ulink
		    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/</ulink></para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>para o 4.X-RELEASE/4-STABLE</term>
	      <listitem>
		<para><ulink
		    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/</ulink></para>

	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>para o 5.X-CURRENT</term>
	      <listitem>
		<para><ulink
		    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current/">
		    ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current</ulink></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>ou em um sítio espelho mais perto de
	    você.</para>

	  <para>Note que nem todos os <literal>Ports</literal> podem
	    estar disponíveis em formato de pacotes, visto que
	    a atualização da Coleção de
	    <literal>Ports</literal> do FreeBSD é muito
	    freq&uuml;ente, e novos programas são
	    constantemente adicionados, e outros são
	    atualizados.  É sempre bom verificar periodicamente
	    quais pacotes estão disponíveis no servidor
	    FTP mestre do projeto FreeBSD, o <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org.</ulink>
	   </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="missing-libcso30">
	  <para>Onde eu encontro a libc.so.3.0?</para>
	</question>

	<answer>
	  <para>Você está tentando usar um pacote
	    construído para o FreeBSD 2.2 ou para
	    versões posteriores, em um sistema 2.1.X.  Por
	    gentileza, dê uma olhada na seção
	    anterior e pegue o <literal>port</literal>/pacote correto
	    para o seu sistema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="missing-libcso40">
	  <para> Por que eu estou tendo problemas cuja mensagem de
	    erro mostra <quote>Error: can't find
	      libc.so.4.0</quote>?.</para>
	</question>

	<answer>
	  <para>Acidentalmente você pegou um pacote
	    construído para FreeBSD 4.X ou para o 5.X e
	    está tentando instala-lo no seu FreeBSD 2.X ou 3.X.
	    Por favor, pegue a versão correta dos
	    pacotes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="emul">
	  <para> Por que o ghostscript gera um monte de erros no meu
	    386/486SX?</para>
	</question>

	<answer>
	  <para>Deixe-me adivinhar.  Você não tem um
	    co-processador matemático, certo?  Será
	    necessário adicionar um co-processador
	    matemático alternativo ao seu
	    <foreignphrase>kernel</foreignphrase>; você pode
	    fazer isso adicionando a seguinte linha no arquivo de
	    configuração do seu
	    <foreignphrase>kernel</foreignphrase>, e depois
	    recompilá-lo:</para>

	  <programlisting>options GPL_MATH_EMULATE</programlisting>

	  <note>
	    <para>Quando voc&ecirc fizer isto, será
	      necessário remover a opção
	      <literal>MATH_EMULATE</literal></para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sco-socksys">
	  <para>Por que aplicações do SCO/iBCS2
	    bombardeiam o ``socksys''? (FreeBSD 3.0 e anteriores,
	    apenas).</para>
	</question>

	<answer>
	  <para>Primeiro, é necessário editar o arquivo
	    <filename>/etc/sysconfig</filename> (ou
	    <filename>/etc/rc.conf</filename>, veja o &man.rc.conf.5;)
	    e modificar a última seção, alterando
	    para <literal>YES</literal> a seguinte
	    variável:</para>

	  <programlisting># Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO</programlisting>

	  <para>Essa alteração fará o sistema
	    carregar os módulos de
	    <foreignphrase>kernel</foreignphrase> do ibcs2 na
	    inicialização.</para>

	  <para>Depois, será necessário alterar o
	    /compat/ibcs2/dev para parecer com:</para>

	  <screen>lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx</screen>

	  <para>É necessário que o socksys aponte para
	    <devicename>/dev/null</devicename> (veja &man.null.4;) para
	    fingir o processo de abertura e fechamento do device.  O
	    código mais recente (<literal>-CURRENT</literal>)
	    se encarregará dos outros detalhes.  Essa maneira
	    de trabalhar o socksys é bem mais limpa do que a
	    forma que era usada anteriormente.  Se você quer que
	    o driver <devicename>spx</devicename> fique
	    disponível para um socket X local, defina a
	    opção <literal>SPX_HACK</literal> no
	    <foreignphrase>kernel</foreignphrase> do FreeBSD quando
	    você o recompilar.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="configure-inn">
	  <para> Como eu configuro um sistema de INN (Internet News)
	    na minha estação?
	  </para>
	</question>

	<answer>
	  <para>Depois de instalar o pacote <filename
	      role="package">news/inn</filename> ou o
	    <literal>port</literal>, um excelente lugar para iniciar
	    é  <ulink
	      url="http://www.cis.ohio-state.edu/~barr/INN.html">Dave
	      Barr's INN Page</ulink> onde voçe
	    encontrar&aacute o <literal>FAQ</literal> do INN.
	  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ms-frontpage">
	  <para>Qual versão do Microsoft FrontPage eu devo
	    usar?</para>
	</question>

	<answer>
	  <para>Use os <literal>Ports</literal>, Luke!  Uma
	    versão previamente corrigida do Apache,<filename
	      role="package">apache13-fp</filename>, está
	    disponível na árvore do
	    <literal>Ports</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="java">
	  <para>O FreeBSD suporta Java?</para>
	</question>

	<answer>
	  <para>Veja a página  <ulink
	      url="../../../../java/index.html">
	      http://www.FreeBSD.org/java/</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ports-3x">
	  <para>Por que eu não consigo compilar determinado
	    <literal>port</literal> na minha estação
	    3.X-STABLE?</para>
	</question>

	<answer>
	  <para>Caso esteja usando uma versão do FreeBSD
	    significativamente mais velha do que o -CURRENT ou o
	    -STABLE, será necessário usar o kit de
	    atualização dos <literal>Ports</literal>,
	    disponível em  <ulink
	      url="../../../../ports/index.html">http://www.FreeBSD.org/ports/</ulink>.
	    Caso esteja atualizado mas ainda assim você tem
	    dificuldades, é provável que alguém
	    disponibilizou uma versão do programa que funciona
	    perfeitamente no -CURRENT mas que não compila
	    corretamente no -STABLE.  Por gentileza, envie um
	    Relatório de Problemas com o comando &man.send-pr.1;
	    porque a coleção de <literal>Ports</literal>
	    deve funcionar tanto no -STABLE quanto no -CURRENT.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="find-ldso">
	  <para>Onde posso encontrar o arquivo ld.so?</para>
	</question>

	<answer>
	  <para>Algumas aplicações cujo formato
	    binário é o a.out, como o Netscape
	    Navigator, necessitam das bibliotecas a.out.  Uma
	    versão do FreeBSD nativamente construído com
	    bibliotecas ELF não instala as bibliotecas a.out
	    por padrão.  Você terá problemas por
	    não ter o <filename>/usr/libexec/ld.so</filename>,
	    se esse for o caso do seu sistema.  Estas bibliotecas
	    estão disponíveis embutidas na
	    distribuição compat22.  Utilize o
	    &man.sysinstall.8; para instalá-los.  Pode-se
	    instalá-lo apartir do código fonte do
	    FreeBSD:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/compat/compat22</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	  <para>Se quiser instalar as bibliotecas mais recentes do
	    compat22 sempre que executar o <command>make
	      world</command>, edite
	    <filename>/etc/make.conf</filename> para incluir
	    <varname>COMPAT22=YES</varname>.  Bibliotecas de
	    compatibilidade antigas raramente sofrem mudanças ,
	    as vezes nunca, então geralmente não
	    é necessário.</para>
	  <para> Também veja as páginas de ERRATAS para
	    o 3.1-RELEASE e 3.2-RELEASE.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ports-update">
	  <para>Eu atualizei meus fontes.  E agora, como eu atualizo
	    meus <literal>Ports</literal> instalados?</para>
	</question>

	<answer>
	  <para>FreeBSD não inclui uma ferramenta de
	    atualização do <literal>ports</literal>, mas
	    existem algumas ferramentas que tornam o processo de
	    atualização dos <literal>Ports</literal> uma
	    tarefa, digamos, fácil.  É possível
	    ainda instalar algumas ferramentas adicionais que
	    facilitam o gerenciamento dos <literal>Ports</literal>
	    instalados</para>

	  <para>O comando &man.pkg.version.1; pode gerar um script que
	    atualizará os <literal>ports</literal> instalados
	    para as últimas versões da árvore de
	    <literal>Ports</literal>.</para>

	  <screen>&prompt.root; <userinput>pkg_version <option>-c</option> > <replaceable>/tmp/myscript</replaceable></userinput></screen>

	  <para>O script de saída <emphasis>deve</emphasis> ser
	    editado manualmente antes de ser usado.  As versões
	    mais recentes do &man.pkg.version.1; forçam a
	    edição do arquivo, colocando um  &man.exit.1;
	    no começo do script.</para>

	  <para>A saída do script deve ser salva pois ela gera
	    informações sobre os pacotes que são
	    dependências dos que estão sendo atualizados.
	    Tais dependências podem precisar ser atualizadas ou
	    não, dependendo de cada uma delas.  Os casos comuns
	    onde as dependências precisam ser atualizadas
	    é quando a versão das bibliotecas
	    compartilhadas foram alteradas, portanto o
	    <literal>port</literal> que usava aquela biblioteca
	    precisa ser atualizado para que a nova versão seja
	    usada.</para>

	  <para>Caso tenha espaço o bastante em disco , pode
	    ser interessante usar a ferramenta
	    <command>portupgrade</command> para automatizar o processo
	    de atualização das aplicações
	    instalados por meio de <literal>ports</literal> ou
	    pacotes.  Posto que ele foi programado em Ruby, o
	    <command>portupgrade</command> é um candidato
	    improvável à se tornar parte da
	    árvore principal do FreeBSD.  Mas isso não
	    evita que qualquer pessoa use o programa.  Alias, ele
	    é uma ótima ferramenta.  Ele está
	    disponível em <filename
	      role="package">sysutils/portupgrade</filename>.</para>

	  <para>Se a estação fica constantemente
	    conectada, é interessante usar o sistema
	    &man.periodic.8; para gerar um relatório semanal
	    sobre as versões do <literal>Ports</literal> que
	    podem ser atualizadas.  Pra configurar o sistema para
	    isso, insira a linha
	    <literal>weekly_status_pkg_enable="YES"</literal> no
	    <filename>/etc/periodic.conf</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="minimal-sh">
	  <para>Por que o <command>/bin/sh</command> é
	    tão pequeno?  Por que o FreeBSD não usa o
	    <command>bash</command> ou outro interpretador de comandos
	    (<foreignphrase>shell</foreignphrase>)?</para>
	</question>

	<answer>
	  <para>Porque o POSIX diz que é assim que deve ser um
	    interpretador de comandos
	    (<foreignphrase>shell</foreignphrase>)?</para>

	  <para>A reposta mais complicada: muitas pessoas precisam
	    escrever scripts <foreignphrase>shell</foreignphrase> que
	    sejam portáveis através de muitos sistemas.
	    É por isso que o POSIX especifica o interpretador
	    de comandos (<foreignphrase>shell</foreignphrase>) e
	    comandos utilitários com tanto detalhe.  A maioria
	    dos scripts são escritos para o interpretador de
	    comandos Bourne (Bourne
	    <foreignphrase>shell</foreignphrase>), e várias
	    interfaces importantes de programação
	    (&man.make.1;, &man.system.3;, &man.popen.3; e
	    análogos em linguagens de alto-nível como
	    Perl e Tcl) o usam como interpretador de comandos
	    (<foreignphrase>shell</foreignphrase>) padrão.  Por
	    ser tão amplamente utilizado é importante
	    que o interpretador de comandos
	    (<foreignphrase>shell</foreignphrase>) Bourne seja
	    rápido para carregar, seja determinístico em
	    seu comportamento, e que tenha uma pequena
	    alocação de memória.
	   </para>

	  <para>A implementação atual é o nosso
	    melhor esforço para encontrar a maior parte destes
	    requerimentos simultaneamente.  Como forma de manter o
	    <command>/bin/sh</command> do menor tamanho
	    possível, não incluímos muitas das
	    características convenientes que outros
	    interpretadores de comando
	    (<foreignphrase>shell</foreignphrase>) possuem.  É
	    por isso que a Coleção de
	    <literal>Ports</literal> disponibiliza outros
	    interpretadores de comandos
	    (<foreignphrase>shell</foreignphrase>) com
	    características mais abrangentes, como o bash, o
	    csh, o tcsh, e o zsh. (Você pode comparar a
	    utilização de memória entre todos
	    esses interpretadores de comandos
	    (<foreignphrase>shell</foreignphrase>), analisando as
	    colunas <quote>VSZ</quote> e <quote>RSS</quote> na
	    saída do comando <command>ps -u</command>.)</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="netscape-slow-startup">
	  <para>Por que o Netscape e o Opera demoram tanto para
	    iniciar?</para>
	</question>

	<answer>
	  <para>A resposta tradicional é que o DNS no seu
	    computador está mal configurado.  O Netscape e o
	    Opera fazem verificação de DNS ao iniciar, e
	    por isso não se tornarão disponíveis
	    até que obtenham uma resposta do servidor DNS ou
	    até que eles determinem que a estação
	    não está conectada na rede.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="kernelconfig">
    <title>Configuraçãao do
      <foreignphrase>Kernel</foreignphrase></title>

    <qandaset>
      <qandaentry>
	<question id="make-kernel">
	  <para>Eu gostaria de configurar meu
	    <foreignphrase>kernel</foreignphrase>.  É
	    difícil?</para>
	</question>

	<answer>
	  <para>De modo algum!  Veja a <ulink
	      url="../handbook/kernelconfig.html">seção
	      "kernel config" do &a.ptbr.p.handbook;</ulink>.</para>

	  <note>
	    <para>Recomenda-se que você faça uma
	      cópia datada do seu <filename>kernel</filename>
	      na forma <filename>/kernel.AAMMDD</filename> e o
	      diretório <filename>/modules</filename> para
	      <filename>/modules.AAMMDD</filename> depois que estiver
	      tudo funcionando.  Desta forma se você fizer
	      alguma bobagem quando mexer com a sua
	      configuração, pode-se iniciar aquele
	      <foreignphrase>kernel</foreignphrase> ao invés de
	      ter que desfazer tudo novamente no
	      <filename>kernel.GENERIC</filename>.  Isso é
	      particularmente importante se você estiver dando
	      boot em um equipamento não suportado pelo
	      <foreignphrase>kernel</foreignphrase> genérico
	      (<literal>GENERIC</literal>).</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="missing-hw-float">
	  <para>A compilação do meu
	    <foreignphrase>kernel</foreignphrase> falha porque
	    está faltando o <literal>_hw_float</literal>.  Como
	    eu resolvo o problema?</para>
	</question>

	<answer>
	  <para>Deixa eu adivinhar.  Você removeu o
	    <devicename>npx0</devicename> (veja &man.npx.4;) do
	    arquivo de configuração do
	    <foreignphrase>kernel</foreignphrase> porque você
	    não possui um co-processador aritmético,
	    certo?  Errado!  :-) O <devicename>npx0</devicename>
	    é <emphasis>OBRIGATÓRIO</emphasis>.  Mesmo
	    que você não tenha um co-processador
	    aritmético, o dispositivo
	    <devicename>npx0</devicename> <emphasis>deve</emphasis>
	    ser incluido.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="why-kernel-big">
	  <para>Por que meu <foreignphrase>kernel</foreignphrase>
	    é tão grande (cerca de 10MB)?</para>
	</question>

	<answer>
	  <para>Provavelmente, seu
	    <foreignphrase>kernel</foreignphrase> foi compilado em
	    <emphasis>modo de depuração
	      (<literal>debug</literal>)</emphasis>.  Um
	    <foreignphrase>kernel</foreignphrase> construído em
	    modo de depuração (<literal>debug</literal>)
	    contêm muitos símbolos usados para
	    depuração que aumentam muito o seu tamanho.
	    Note que se você está executando um FreeBSD
	    3.0 ou superior, terá pouca, ou nenhuma,  perda de
	    performance por usar um
	    <foreignphrase>kernel</foreignphrase> em modo de
	    depuração (<literal>debug</literal>), sendo
	    útil ter um para o caso de pane no sistema.
	  </para>

	  <para>Entretanto, se você possui pouco espaço
	    em disco, ou simplesmente não quer executar um
	    <foreignphrase>kernel</foreignphrase> para
	    depuração,  certifique-se que os dois itens
	    abaixo sejam verdadeiros:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Não existe a seguinte linha no arquivo de
		configuração do
		<foreignphrase>kernel</foreignphrase></para>

	      <programlisting>makeoptions DEBUG=-g</programlisting>
	    </listitem>

	    <listitem>
	      <para>Você não está executando
		&man.config.8; com a opção
		<option>-g</option>.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Ambas as situações acima fazem com que o
	    <foreignphrase>kernel</foreignphrase> seja compilado no
	    modo de depuração
	    (<literal>debug</literal>).  Tão logo você
	    tenha certeza que não se enquadra naqueles itens, o
	    <foreignphrase>kernel</foreignphrase> poderá ser
	    compilado normalmente e notadamente diminuirá o
	    tamanho;  a maioria dos
	    <foreignphrase>kernels</foreignphrase> tendem a ficar em
	    torno de 1.5MB a 2MB.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multiport-serial-interrupts">
	  <para>Porque estão ocorrendo conflitos de
	    interrupção com portas multi-seriais?</para>
	</question>

	<answer>
	  <para>Quando se compila um
	    <foreignphrase>kernel</foreignphrase> com suporte a porta
	    multi-serial, ele avisa que somente a primeira porta
	    é testada e as demais são ignoradas devido a
	    conflitos de interrupção.  Como eu conserto
	    isto?</para>

	  <para>O problema, neste caso, é que o FreeBSD possui
	    código para evitar que o
	    <foreignphrase>kernel</foreignphrase> fique com lixo
	    (<foreignphrase>trashed kernel</foreignphrase>) por causa
	    de conflitos de hardware ou software.  A maneira de
	    corrigir isto é excluindo as
	    definiçõs de IRQ em todas as portas exceto
	    uma.  Veja o exemplo:</para>

	  <programlisting>#
# Multiport high-speed serial line - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="generic-kernel-build-failure">
	  <para>Porque todo <foreignphrase>kernel</foreignphrase> que
	    eu tento construir falha na compilação,
	    mesmo o GENERIC?</para>
	</question>

	<answer>
	  <para>Existem várias causas possíveis para
	    esse problema.  Elas são, sem uma ordem particular:
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>Você não está usando os
		comandos <command>make buildkernel</command> e
		<command>make installkernel</command>, e seus fontes
		estão estruturados de forma diferente daqueles
		usados para construir o sistema atual (por exemplo,
		está sendo um 4.3-RELEASE em um sistema
		4.0-RELEASE).  Se estiver sendo feita uma
		atualização, leia o arquivo
		<filename>/usr/src/UPDATING</filename>, prestando
		atenção ao final da seção
		<quote>COMMON ITEMS</quote>.</para>
	    </listitem>

	    <listitem>
	      <para>Você está usando os comandos
		<command>make buildkernel</command> e <command>make
		  installkernel</command>, mas não garantiu a
		correta finalização do comando
		<command>make buildworld</command>.  O <command>make
		  buildkernel</command> depende de arquivos gerados
		pelo <command>make buildworld</command> para fazer seu
		trabalho corretamente.</para>
	    </listitem>

	    <listitem>
	      <para>Mesmo que você esteja tentando construir um
		<link linkend="stable">FreeBSD-STABLE</link>, é
		possível que os fontes tenham sido pegos quando
		estavam sendo modificados, ou inconsistentes por
		alguma outra razão; somente os releases
		são absolutamente garantidos de serem
		compilados, embora o <link
		  linkend="stable">FreeBSD-STABLE</link> possa ser
		compilado com sucesso na grande maioria das vezes.
		Caso já não tenha conseguido,  tente
		buscar os fontes novamente e veja se o problema
		já não foi resolvido.  Tente um servidor
		diferente, para o caso daquele que está sendo
		usado estar com problemas.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="disks">
    <title>Discos, Sistemas de Arquivos e Carregadores de
      Inicialização (<foreignphrase>Boot
	Loaders</foreignphrase>)</title>

    <qandaset>
      <qandaentry>
	<question id="adding-disks">
	  <para>Como procedo para adicionar um novo disco
	    rígido no FreeBSD?</para>
	</question>

	<answer>
	  <para>Veja o Tutorial sobre a Formatação de
	    Discos no sítio<ulink
	      url="../../articles/formatting-media/index.html">
	      www.FreeBSD.org</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="new-huge-disk">
	  <para>Como eu mudo todo o meu sistema operacional para um
	    disco novo?</para>
	</question>

	<answer>
	  <para>A melhor maneira de migrar seu sistema de um disco
	    para o outro é reinstalar completamente o SO na
	    nova unidade de armazenamento e depois migrar os dados dos
	    usuários do disco antigo para nova
	    instalação.  Essa forma é a mais
	    recomendada, caso o sistema tenha sido -STABLE por mais de
	    uma versão, ou caso tenha atualizado um Release ao
	    invés de ter instalado um novo sistema.  O booteasy
	    pode ser facilmente instalado com o comando
	    &man.boot0cfg.8;, de forma a permitir que o sistema possa
	    iniciar dois sistemas distintos, até que você
	    esteja satisfeito com o novo sistema.  Pule o
	    próximo parágrafo para saber algumas formas
	    seguras de migrar os dados dos usuários para o novo
	    disco.</para>

	  <para>Você pode ter decidido por não refazer
	    uma nova instalação; nesse caso será
	    necessário reparticionar o novo disco com o
	    <filename>/stand/sysinstall</filename>, ou &man.fdisk.8;
	    ou &man.disklabel.8;.  Também é
	    necessário instalar o booteasy em ambas as unidades
	    com o comando &man.boot0cfg.8;, de forma que você
	    possa alternar a inicialização entre o novo
	    sistema e a configuração atual do mesmo,
	    até que a cópia dos dados tenha sido
	    efetuada.  Veja o artigo <ulink
	      url="../../articles/formatting-media/index.html">
	    </ulink>referente a formatação de
	    mídias para obter mais detalhes quanto a esse
	    processo.</para>

	  <para>Agora, com um novo disco configurado, você
	    está pronto para começar a mover os dados da
	    antiga para nova unidade de armazenamento.  Infelizmente
	    os dados não podem simplesmente ser copiados ao
	    acaso.  Existem alguns arquivos especiais (como os
	    arquivos de dispositivos <filename>/dev</filename>),
	    flags, e links que tendem a não funcionar no novo
	    sistema, visto que esses arquivos ocupam inodes ou tem
	    informações específicas da unidade, e
	    por isso não podem ser copiados como um arquivo
	    comum.  É necessário usar ferramentas que
	    entendam esse comportamento.  Isso significa que
	    você terá que usar o &man.dump.8;.  É
	    sempre uma boa idéia realizar esse processo de
	    cópia de dados em modo mono-usuário, contudo
	    tal precaução não é
	    obrigatória - é apenas sinal de
	    cuidado.</para>

	  <para>Não é aconselhável usar nenhuma
	    outra ferramenta a não ser o &man.dump.8; e
	    &man.restore.8; para copiar o sistema de arquivos da
	    partição raiz (&quot;/&quot;).  O
	    &man.tar.1; pode funcionar de forma satisfatória,
	    mas pode ser que não.  Também é
	    ótima idéia usar o &man.dump.8; e
	    &man.restore.8; para copiar (ou mover completamente) os
	    dados em uma partição para uma outra
	    partição vazia.  Os passos
	    necessários para usar o dump para copiar os dados
	    de uma partição existente para uma nova
	    partição são:</para>

	  <procedure>
	    <step>
	      <para>Crie um novo sistema de arquivos com o
		&man.newfs.8 na nova partição.</para>
	    </step>

	    <step>
	      <para>Monte a partição em um ponto de
		montagem temporário.</para>
	    </step>

	    <step>
	      <para>Entre (cd) no ponto de montagem em
		questão.</para>
	    </step>

	    <step>
	      <para>Finalmente mova os dados da partição
		existente para a nova partição com o
		&man.dump.8;.</para>
	    </step>
	  </procedure>

	  <para>Por exemplo, se a intenção é
	    copiar os dados da partição raiz para a
	    partição
	    <devicename>/dev/ad1s1a</devicename>, cujo ponto de
	    montagem temporário é o
	    <filename>/mnt</filename>, faça o seguinte:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput></screen>

	  <para>Redefinir a estrutura das partições com
	    o &man.dump.8 é um processo um pouco mais
	    trabalhoso.  Caso você queira, por exemplo, unir o
	    conteúdo da partição
	    <filename>/var</filename> com as partições
	    de nível acima, crie uma partição que
	    seja grande o bastante para alocar o conteúdo de
	    ambas, copie a partição principal como no
	    exemplo descrito acima e depois copie as
	    sub-partições para os diretórios
	    vazios que o primeiro comando deve ter criado:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput>
&prompt.root; <userinput>cd var</userinput>
&prompt.root; <userinput>dump 0af - /var | restore xf -</userinput></screen>

	  <para>Para separar um diretório de sua estrutura
	    atual, ou seja, no mesmo exemplo ainda, alocar os dados de
	    <filename>/var</filename> em uma partição
	    própria quando na definição atual o
	    /var é apenas um diretório comum, é
	    necessário montar a sub partição no
	    diretório apropriado do ponto de montagem
	    temporário, simulando assim o sistema de arquivos a
	    ser criado a partir da raiz (montada no diretório
	    temporário), depois basta copiar os dados do
	    diretório antigo para nova
	    partição:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>newfs /dev/ad1s1d</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a /mnt</userinput>
&prompt.root; <userinput>mkdir /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/ad1s1d /mnt/var</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0af - / | restore xf -</userinput></screen>

	  <para>Talvez você prefira usar &man.cpio.1;,
	    &man.pax.1;, &man.tar.1; ao invés de &man.dump.8;
	    na hora de copiar os dados de usuários.  Quando
	    este <literal>FAQ</literal> foi escrito, esses comandos
	    costumavam perder atributos especiais dos arquivos ou
	    mesmo alterar algumas permissões ou autoridade
	    (dono dos arquivos), portanto use esses comandos com
	    cuidado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dangerously-dedicated">
	  <para>Um disco no modo <quote>dangerously dedicated</quote>
	    pode ser prejudicial a minha saúde?</para>
	</question>

	<answer>
	  <para><anchor id="dedicate"/>O processo de
	    instalação permite a escolha entre dois
	    modos distintos de particionar o(s) disco(s)
	    rígido.  A maneira tradicional permite que outros
	    sistemas operacionais na mesma estação
	    possam acessar essas partições, criando
	    entradas na tabela do fdisk (entradas chamadas de
	    <quote>slices</quote> no FreeBSD) sob uma
	    partição FreeBSD própria.  Uma
	    característica desse particionamento é
	    permitir múltiplos sistemas operacionais e permitir
	    a instalação de um gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) para alternar entre
	    esses sistemas.  A segunda maneira, a alternativa ao modo
	    tradicional faz uso do disco todo para o FreeBSD e
	    não faz esforços para se tornar
	    compatível com outros sistemas operacionais.</para>

	  <para>Então, por que esse modo é chamado de
	    <quote>modo perigosamente dedicado</quote>?  Um disco
	    particionado dessa forma não tem algumas
	    características tradicionais que os PCs poderiam
	    considerar entradas válidas do fdisk.  Dependendo
	    das circunstâncias o PC pode reclamar e gerar
	    advertências sobre o disco em questão, assim
	    que o primeiro contato com essa unidade seja feito, ou
	    pior, o PC pode ainda danificar o processo de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) do BSD
	    (<foreignphrase>bootstrap</foreignphrase>) sem pedir
	    confirmação da alteração ou
	    até mesmo sem avisar o usuário dessa
	    mudança.  O <quote>modo perigosamente
	      dedicado</quote> ainda costuma confundir várias
	    BIOS, inclusive as BIOS AWARD (encontradas, por exemplo no
	    HP Netserver e em sistemas Micronics assim como em muitos
	    outros) e as BIOS Symbios/NCR (da popular série
	    53C8xx de controladoras SCSI).  Não são
	    apenas esses dois modelos que podem apresentar
	    dificuldades com esse modo de particionamento de disco, a
	    lista completa é ainda maior.  O principal sintoma
	    desse tipo de confusão é a presença
	    de mensagens de <errorname>read error</errorname>
	    apresentada pelo <foreignphrase>bootstrap</foreignphrase>
	    do FreeBSD quando ele tem dificuldades de encontrar-se;
	    outro sintoma é a falta de sistema operacional no
	    momento da inicialização do PC.</para>

	  <para>Então porque esse modo de particionamento de
	    disco existe?  Esse modo economiza o uso de alguns poucos
	    kbytes de espaço em disco, e pode, em contrapartida
	    gerar grandes problemas em uma nova
	    instalação do sistema.  O modo
	    <quote>perigosamente dedicado</quote> em sua origem
	    é um desejo antigo dos usuários do FreeBSD,
	    especialmente durante a instalação, que
	    é simplesmente poder ignorar a
	    <quote>geometria</quote> de disco reconhecida pela BIOS e
	    usar o disco todo de forma independente, sem prestar
	    satisfação ao sistema básico de
	    entrada/saída do PC.</para>

	  <para>O conceito de <quote>Geometria</quote> é
	    ultrapassado, mas infelizmente ainda faz parte do
	    coração da BIOS dos Computadores Pessoais,
	    sendo extremamente necessário para a
	    interação do computador com seus discos.
	    Quando o FreeBSD cria as partições, ele tem
	    que gravar sua localização de forma
	    correspondente a maneira que a BIOS irá
	    procurá-la.  Se essa informação
	    não é acessível à BIOS, pode
	    ser que o sistema não consiga iniciar-se.</para>

	  <para><quote>O modo Dangerously dedicated</quote> tenta
	    evitar esse desconforto fazendo a operação
	    se tornar mais simples.  Em muitos casos essa forma de
	    particionamento funciona, mas ela foi criada para ser
	    usada como última alternativa à necessidade
	    de definir a geometria do disco - em 99% dos casos existem
	    formas mais vantajosas de resolver problemas com
	    geometria.</para>

	  <para>Mas então, como evitar a necessidade do modo
	    <quote>DD</quote> na instalação do sistema?
	    Comece anotando os valores pra geometria que a BIOS diz
	    estar usando pros discos locais.  Esses valores podem ser
	    apresentados pelo kernel do FreeBSD, especificando a
	    opção <option>-v</option> no prompt de
	    <literal>boot:</literal> usando <command>boot
	      -v</command> nas configurações do loader
	    do sistema operacional.  Antes do programa de
	    instalação ser carregado o kernel apresenta
	    a listagem dos valores para a Geometria de discos
	    reconhecida pela BIOS do computador;  não se
	    precipite nem se preocupe, essas informações
	    podem ser visualizadas paginando a tela para as
	    notações anteriores, sendo possível
	    assim verificar esses valores.  Normalmente as unidades de
	    disco da BIOS são apresentadas na mesma ordem que o
	    FreeBSD as encontra, sendo primeiro as unidades IDE
	    seguido das SCSI.</para>

	  <para>No momento do particionamento do disco, verifique se a
	    geometria apresentada pelo FDISK corresponde ao valor
	    apresentado pela BIOS;  caso não corresponda use a
	    tecla <keycap>g</keycap> para redefinir esses valores.
	    Também pode ser necessário definir a
	    geometria manualmente em casos onde o disco em
	    questão está vazio e sem nenhum outro tipo
	    de partição criada, ou se o disco foi
	    instalado em um outro computador e foi colocado na
	    estação atual recentemente.  Note que esse
	    tipo de complicação não é
	    comum, e quando acontece, acontece apenas com o disco onde
	    o FreeBSD está iniciando;  Qualquer outro disco
	    existente no computador será controlado
	    perfeitamente pelo FreeBSD em qualquer
	    situação.</para>

	  <para>Uma vez existindo a concordância de Geometria
	    entre a BIOS e o FreeBSD, com certeza seus problemas
	    terão acabado, e não existia a necessidade
	    de usar o modo <quote>DD</quote>.  Contudo, se em casos
	    extremos ainda ocorrerem erros de <errorname>read
	      error</errorname> então pode cruzar os dedos e
	    usar o modo dedicado (DD), afinal não há
	    nada a perder, visto que das formas tradicionais sua BIOS
	    insiste em não cooperar de forma correta.</para>

	  <para>Para voltar um disco particionado em modo
	    <quote>dangerously dedicated</quote> para uso normal em um
	    PC existem duas alternativas.  A primeira é alocar
	    dados nulos (NULL bytes) o bastante na MBR do disco, de
	    forma que qualquer instalação posterior
	    acredite que o disco está vazio.  Isso pode ser
	    feito, por exemplo, da seguinte maneira:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda0 count=15</userinput></screen>

	  <para>E a segunda forma, a
	    <quote>opção</quote> não documentada
	    do DOS:</para>

	  <screen><prompt>C:\&gt;</prompt> <userinput>fdisk /mbr</userinput></screen>

	  <para>instalará um novo registro mestre de
	    inicialização no disco em questão,
	    sobrepondo inclusive o
	    <foreignphrase>bootstrap</foreignphrase> do BSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="safe-softupdates">
	  <para>Em quais partições podemos seguramente
	    usar o softupdates?  Eu tenho ouvido falar de problemas em
	    se usar o softupdates na partição
	    <filename>/</filename>?</para>
	</question>

	<answer>
	  <para>A resposta breve: o softupdates pode ser usado com
	    segurança em todas as
	    partições.</para>

	  <para>A resposta mais completa: existiam algumas
	    restrições quanto ao uso do softupdates na
	    partição raiz do sistema.  Tais
	    restrições se deviam a duas
	    características causadas pelo softupdates, que eram
	    a pouquíssima chance de perder alguns dados da
	    partição raiz se acontecesse algum system
	    crash;   apesar das probabilidades de perda de dados serem
	    mínimas, elas existem;   não existe uma
	    danificação ou corrosão do sistema de
	    arquivos, apenas alguns arquivos podem ser simplesmente
	    perdidos.  E a segunda característica é a
	    diminuição temporária de
	    espaço em disco.</para>

	  <para>Quando o softupdates está ativado o kernel pode
	    levar até trinta segundos para realmente escrever
	    alguns dados fisicamente em disco.  Caso algum arquivo
	    grande seja apagado, ela permanece temporariamente em
	    disco até que o kernel realmente o apague, o que
	    pode causar uma condição de corrida
	    simples(simple race condition).  Imagine, apenas para
	    ilustrar, que você apague um arquivo enorme do
	    disco, e logo em seguida crie um outro arquivo tão
	    grande quanto o primeiro;  a gravação de
	    metadados no disco pode não ter sido realizada
	    ainda quando o segundo arquivo é criado, ou seja o
	    primeiro não foi realmente definido como um arquivo
	    apagado.  Nesse caso é provável que
	    você receba uma mensagem dizendo que não
	    existe espaço o bastante em disco para o segundo
	    arquivo, quando você tem certeza absoluta que o
	    espaço que acabou de ser liberado ao apagar o
	    primeiro arquivo é o suficiente para alocar o
	    segundo!  Aí você tenta gravar o segundo
	    arquivo mais uma vez, alguns meros segundos depois, e o
	    processo de criação do mesmo, simplesmente
	    funciona como esperado.  Esse tipo de comportamento
	    já levou mais de um usuário a
	    balançar sua cabeça e duvidar de sua
	    própria sanidade, ou mesmo da sanidade do sistema
	    de arquivos do FreeBSD;  em caso extremos, de
	    dúvidas do bom estado de ambos, a sanidade do
	    sistema de arquivos e do próprio usuário
	    ;-)</para>

	  <para>Se o sistema falhar antes do kernel aceitar um
	    conjunto de dados que tem que ser escrito no disco antes
	    do mesmo ser gravado, é provável que exista
	    perda dos dados em questão.  Esse risco é
	    extremamente baixo, e geralmente é
	    contornável.  O uso, por exemplo, das
	    opções de cache de gravação
	    das unidades de disco IDE é um fator que causa a
	    possibilidade desse tipo de desconforto, portanto é
	    altamente recomendável que essa opção
	    seja desativada nos discos IDE quando for usar o
	    softupdates.</para>

	  <para>Esse comportamento afeta todas as
	    partições que estiverem com softupdates.
	    Portanto, o que isso implica para a partição
	    raiz?</para>

	  <para>A maioria das informações vitais da
	    partição raiz mudam com pouquíssima
	    freq&uuml;ência.  Arquivos como o
	    <filename>/kernel</filename> e o conteúdo do
	    <filename>/etc</filename> são alterados apenas
	    durante a manutenção do sistema operacional,
	    ou quando os usuários alteram suas senhas.  Caso o
	    sistema falhe durante essa janela de trinta segundos,
	    depois que uma dessas alterações foi feita,
	    é possível que alguns dados sejam perdidos.
	    Esse risco é baixíssimo e praticamente
	    indiferente para maioria das aplicações, mas
	    deve-se atentar que o risco existe.  Caso seu sistema
	    não tolere nem uma possibilidade tão baixa
	    de riscos, não use o softupdates na
	    partição raiz!</para>

	  <para>A <filename>/</filename> normalmente é uma das
	    menores partições do sistema.  Por
	    padrão o FreeBSD coloca o diretório
	    <filename>/tmp</filename> na partição
	    <filename>/</filename>, comportamento este que pode ser
	    modificado por administradores de sistemas mais
	    experientes.  Caso seu <filename>/tmp</filename> costume
	    ocupar muito espaço, pode ser criado um link
	    simbólico para o <filename>/var/tmp</filename>, o
	    comportamento inverso também é válido
	    e bastante seguro, caso o /tmp seja uma
	    partição grande o bastante para alocar os
	    dados do /var/tmp também.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="inappropriate-ccd">
	  <para>O que é inapropriado no meu ccd?</para>
	</question>

	<answer>
	  <para>Os sintomas desse tipo de dúvida:</para>

	  <screen>&prompt.root; <userinput>ccdconfig -C</userinput>
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format</screen>

	  <para>Esse problema normalmente ocorre quando se tenta
	    concatenar as partições <literal>c</literal>
	    cujo tipo padrão é
	    <literal>unused</literal>.  O ccd requer que a
	    partição que ele esteja usando seja do tipo
	    FS_BSDFFS.  Edite o disklabel dos discos em questão
	    e altere o tipo das partições para
	    <literal>4.2BSD</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ccd-disklabel">
	  <para>Porque eu não posso editar o disklabel do meu
	    ccd?</para>
	</question>

	<answer>
	  <para>Os sintomas desse tipo de dúvida:</para>

	  <screen>&prompt.root; <userinput>disklabel ccd0</userinput>
(it prints something sensible here, so let us try to edit it)
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(edit, save, quit)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label</screen>

	  <para>Isso acontece por que o disklabel que o ccd retorna
	    é na verdade um valor <quote>falso</quote>, que
	    não está realmente gravado no disco.  Esse
	    problema pode ser resolvido ao reescrever explicitamente
	    esse dado, da seguinte forma:</para>

	  <screen>&prompt.root; <userinput>disklabel ccd0 &gt; /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -Rr ccd0 /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(agora ir&aacute funcionar)</screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mount-foreign-fs">
	  <para>Posso montar outros tipos de partições
	    externas sobre FreeBSD?</para>
	</question>

	<answer>
	  <variablelist>
	    <varlistentry>
	      <term>Digital UNIX</term>

	      <listitem>
		<para>CDROMs do tipo UFS podem ser montados
		  diretamente no FreeBSD, já a montagem de
		  partições de disco do Digital UNIX que
		  usam o UFS pode ser um pouco mais complexa,
		  dependendo dos detalhes do particionamento de disco
		  para o sistema operacional em questão.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>Linux</term>

	      <listitem>
		<para>A partir do 2.2, o FreeBSD suporta
		  partições do tipo
		  <literal>ext2fs</literal>.  Veja o
		  &man.mount.ext2fs.8; para obter mais
		  informações.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>NT</term>

	      <listitem>
		<para>Existe suporte somente-leitura as
		  partições NTFS no FreeBSD.  Para obter
		  mais informações leia esse tutorial,
		  escrito por Mark Ovens em <ulink
		    url="http://ukug.uk.FreeBSD.org/~mark/ntfs_install.html">http://ukug.uk.FreeBSD.org/~mark/ntfs_install.html</ulink>.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Mais informações sobre esse assunto
	    seriam bem vindas :-)</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mount-dos">
	  <para>Como montar uma partição DOS
	    secundária?</para>
	</question>

	<answer>
	  <para>As partições secundárias do DOS
	    são encontradas depois que TODAS as
	    partições primárias foram definidas.
	    Por exemplo, se você tem a partição
	    <quote>E</quote> como a segunda partição
	    DOS no segundo disco SCSI, será necessário
	    criar um arquivo especial para essa <quote>quinta
	      partição</quote> (slice 5) no /dev, depois
	    montar /dev/da1s5:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV da1s5</userinput>
&prompt.root; <userinput>mount -t msdos /dev/da1s5 /dos/e</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="crypto-filesystem">
	  <para>Existe um sistema de arquivos criptografado para o
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Sim, veja o <literal>port</literal> <filename
	      role="package">security/cfs</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="nt-bootloader">
	  <para>Como posso usar o carregador do NT para iniciar o
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Esse procedimento é um pouco diferente entre o
	    FreeBSD 2.2.X e o 3.X (que tem um sistema de inicío
	    (<foreignphrase>boot</foreignphrase>) de 3 fases).</para>

	  <para>A idéia geral se consiste em copiar os
	    primeiros setores da partição raiz nativa do
	    FreeBSD e transforma-los em um arquivo, para ser colocado
	    dentro da partição DOS/NT.  Se assumir-mos
	    que você vai chamar esse arquivo de
	    <filename>c:\bootsect.bsd</filename> (inspirado por
	    <filename>c:\bootsect.dos</filename>), pode-se
	    então editar o arquivo
	    <filename>c:\boot.ini</filename> de forma a
	    carregá, mais ou menos assim:</para>

	  <programlisting>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"</programlisting>

	  <para>No 2.2.X esse procedimento assume que o DOS, o NT, o
	    FreeBSD, ou o que quer que seja, tenha sido instalado em
	    suas partições respectivas do fdisk no
	    <emphasis>mesmo</emphasis> disco.  Esse exemplo foi
	    testado em um sistema onde o DOS &amp; NT estavam
	    instalados na primeira partição do fdisk, e
	    o FreeBSD na segunda.  O FreeBSD havia sido configurado
	    para iniciar a partir de sua partição
	    nativa, e não pela MBR do disco.</para>

	  <para>Monte um disquete formatado em DOS (caso ele tenha
	    sido convertido para NTFS) ou em FAT, por exemplo, sob o
	    ponto de montagem <filename>/mnt</filename>.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</userinput></screen>

	  <para>Reinicie o computador no DOS ou NT.  Sobre o NTFS,
	    copie o arquivo <filename>bootsect.bsd</filename> e/ou
	    arquivo <filename>bootsect.lnx</filename> do disquete para
	    <filename>C:\</filename>.  Modifique os atributos
	    originais(permissões) do
	    <filename>boot.ini</filename> com:</para>

	  <screen><prompt>C:\&gt;</prompt> <userinput>attrib -s -r c:\boot.ini</userinput></screen>

	  <para>Edite e adicione as entradas apropriadas no
	    <filename>boot.ini</filename> seguindo o exemplo anterior
	    e volte os atributos originais:</para>

	  <screen><prompt>C:\&gt;</prompt> <userinput>attrib +s +r c:\boot.ini</userinput></screen>

	  <para>Se o FreeBSD estiver inicializando pela MBR,
	    reconstrua-a com o comando <command>fdisk</command> do DOS
	    depois de configurar os sistemas para iniciar a partir de
	    suas partições nativas.</para>

	  <para>No FreeBSD 3.X esse procedimento é mais
	    simples.</para>

	  <para>Se o FreeBSD estiver instalado no mesmo disco que a
	    partição de inicialização
	    (<foreignphrase>boot</foreignphrase>) do NT está
	    instalada, copie o <filename>/boot/boot1</filename> para
	    <filename>C:\BOOTSECT.BSD</filename>.  Contundo, se o
	    FreeBSD estiver em uma partição distinta, o
	    <filename>/boot/boot1</filename> não irá
	    funcionar, nesse caso, o <filename>/boot/boot0</filename>
	    será necessário.

	    <warning>
	      <para>N&Atilde;O COPIE SIMPLESMENTE O
		<filename>/boot/boot0</filename> NO LUGAR DO
		<filename>/boot/boot1</filename>, POIS A TABELA DE
		PARTI&Ccedil;&Atilde;O SERÁ REESCRITA, E O
		COMPUTADOR SE TORNARÁ N&Atilde;O
		INICIALIZÁVEL!!</para>
	    </warning> O <filename>/boot/boot0</filename> precisa ser
	    instalado com o sysinstall, selecionando o gerenciador de
	    inicialização
	    (<foreignphrase>boot</foreignphrase>) do FreeBSD na tela
	    que o programa pergunta se você deseja usar um
	    gerenciador de inicialização(boot manager).
	    Isso se deve ao fato que o
	    <filename>/boot/boot0</filename> contém
	    informações sobre a área da tabela de
	    partições definidas como caracteres nulos,
	    mas o sysinstall copia a tabela de partições
	    antes de copiar o <filename>/boot/boot0</filename> para a
	    MBR.</para>

	  <para>Quando o gerenciador de inicialização
	    (<foreignphrase>boot</foreignphrase>) do FreeBSD é
	    executado, ele grava qual último sistema
	    operacional foi carregado, definindo uma flag de sistema
	    ativo na tabela de partição referente aquele
	    sistema, e depois ele escreve todos os 512 bytes do
	    próprio gerenciador de inicialização
	    (<foreignphrase>boot</foreignphrase>) de volta na MBR,
	    portanto se o <filename>/boot/boot0</filename>
	    simplesmente for copiado para
	    <filename>C:\BOOTSECT.BSD</filename> será definida
	    uma tabela de partição vazia com a flag de
	    partição ativa, na MBR.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="lilo-bootloader">
	  <para>Como posso iniciar o FreeBSD e o Linux com o
	    LILO?</para>
	</question>

	<answer>
	  <para>Caso o FreeBSD e o Linux estejam no mesmo disco, basta
	    seguir as instruções de
	    instalação do LILO para carregar sistemas
	    operacionais não-Linux.  De forma breve, tais
	    instruções são</para>

	  <para>Carregue o Linux e adicione as seguintes linhas no
	    <filename>/etc/lilo.conf</filename>:</para>

	  <programlisting>other=/dev/hda2
	table=/dev/hda
	label=FreeBSD</programlisting>

	  <para>(A definição acima assume que a sua
	    partição FreeBSD é conhecida pelo
	    Linux como <devicename>/dev/hda2</devicename>; altere esse
	    valor para sua necessidade).  Depois basta executar o
	    comando <command>lilo</command> como usuário
	    <username>root</username> e deve estar pronto.</para>

	  <para>Caso o FreeBSD esteja em um outro disco, será
	    preciso criar uma entrada
	    <literal>loader=/boot/chain.b</literal> no LILO.  Por
	    exemplo:</para>

	  <programlisting>other=/dev/dab4
        table=/dev/dab
        loader=/boot/chain.b
        label=FreeBSD</programlisting>

	  <para>Em alguns casos é necessário especificar
	    o número da unidade da BIOS para que o loader do
	    FreeBSD consiga carregar o sistema com sucesso, a partir
	    do segundo disco.  Por exemplo, caso o disco SCSI com o
	    FreeBSD seja reconhecido pela BIOS como o disco 1, na tela
	    do carregadir de inicialização
	    (<foreignphrase>boot loader</foreignphrase>) do FreeBSD
	    será necessário definir:</para>

	  <screen>Boot: <userinput>1:da(0,a)/kernel</userinput></screen>

	  <para>No FreeBSD 2.2.5 e posteriores, o &man.boot.8;  pode
	    ser configurado para que ele automaticamente defina essa
	    informação na hora da
	    inicialização
	    (<foreignphrase>boot</foreignphrase>).</para>

	  <para>The <ulink
	      url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html">
	      Linux+FreeBSD mini-HOWTO</ulink> é uma boa
	    referência sobre a utilização do
	    FreeBSD com o Linux.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="booteasy-loader">
	  <para>Como eu inicio o FreeBSD e o Linux usando o
	    BootEasy?</para>
	</question>

	<answer>
	  <para>Instale o LILO no começo da sua
	    partição de inicialização
	    (<foreignphrase>boot</foreignphrase>) do Linux ao
	    invés de instala-lo na MBR.  Agora o LILO pode ser
	    carregado a partir do BootEasy.</para>

	  <para>Com Windows 9x e Linux essa é uma
	    ação recomendada sempre, para garantir que o
	    Linux possa ser iniciado de forma mais fácil caso
	    seja necessário reinstalar o Windows (que é
	    um sistema operacional que não espera nenhum outro
	    sistema na MBR).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="changing-bootprompt">
	  <para>Como eu altero a tela de inicialização
	    (<foreignphrase>boot</foreignphrase>) de
	    <literal>???</literal> para algo mais
	    significativo?</para>
	</question>

	<answer>
	  <para>Você não pode alterar esse comportamento
	    no gerenciador de inicialização
	    (<foreignphrase>boot</foreignphrase>) padrão sem
	    reescreve-lo.  Existem inúmeros outros
	    gerenciadores de inicialização
	    (<foreignphrase>boot</foreignphrase>) na categoria
	    <filename>sysutils</filename> da da coleção
	    de <literal>ports</literal>, que oferecem esse
	    recurso.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="removable-drives">
	  <para>Possuo uma nova unidade de disco removível,
	    como posso usa-la?</para>
	</question>

	<answer>
	  <para>Ainda que seja uma unidade removível como um
	    ZIP Drive, um EZ Drive (ou até um disquete, caso
	    queira usa-lo dessa maneira), ou um novo disco, uma vez
	    instalado e reconhecido pelo sistema e assim que o
	    cartucho/disquete/outra-coisa esteja ligado a unidade em
	    questão, as coisas passam a funcionar da mesma
	    forma para qualquer tipo de dispositivo.</para>

	  <para><anchor id="disklabel"/>(essa seção
	    é baseada no <ulink
	      url="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html">ZIP
	      <literal>FAQ</literal> de Mark Mayo</ulink>)</para>

	  <para>Caso o dispositivo seja um ZIP Drive ou um disquete
	    cujo sistema de arquivos já tenha sido criado como
	    sendo do tipo DOS, o seguinte comando é o bastante
	    para montá-lo:</para>

	  <screen>&prompt.root; <userinput>mount -t msdos /dev/fd0c /floppy</userinput></screen>

	  <para>caso seja um disquete, ou então:</para>

	  <screen>&prompt.root; <userinput>mount -t msdos /dev/da2s4 /zip</userinput></screen>

	  <para>caso seja um disco ZIP com as
	    configurações de fábrica.</para>

	  <para>Para outros tipos de disco, veja como eles são
	    tratados, usando o &man.fdisk.8; ou
	    &man.sysinstall.8;.</para>

	  <para>Os próximos exemplos serão para um ZIP
	    Drive controlado pela device da2, ou seja, correspondente
	    ao terceiro disco SCSI.</para>

	  <para>A não ser que se trate de um disquete ou de um
	    disco removível que se planeje compartilhar com
	    outras pessoas, provavelmente é mais sensata a
	    idéia de colocar um sistema de arquivos do tipo BSD
	    nesse disco.  Um sistema de arquivos desse tipo
	    possibilita usar o suporte a nomes longos de arquivos, ter
	    uma performance de, pelo menos 2x, e oferece muito mais
	    estabilidade e confiança.  O primeiro passo
	    é redefinir a partição DOS da unidade
	    removível de forma que a mesma passe a ser do tipo
	    BSD;  o &man.fdisk.8; ou
	    <filename>/stand/sysinstall</filename> podem ser usados
	    para esse fim, em um disco pequeno onde não se
	    queira preocupações quanto a possibilidade
	    de manter suporte a múltiplos sistemas
	    operacionais.  Nesse caso simplesmente elimine toda a
	    partição FAT do disco e use o particionador
	    do BSD:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda2 count=2</userinput>
&prompt.root; <userinput>disklabel -Brw da2 auto</userinput></screen>

	  <para>O disklabel ou <filename>/stand/sysinstall</filename>
	    podem ser usados para criar múltiplas
	    partições do tipo BSD.  Certamente o
	    usuário vai querer criar mais de uma
	    partição BSD se a intenção for
	    criar espaço de Swap.  De qualquer forma, esse tipo
	    de ação é irrelevante em um disco
	    removível do tipo ZIP.</para>

	  <para>Finalmente, crie um novo sistema de arquivos como
	    esse, que usa todo o disco em um ZIP Drive:</para>

	  <screen>&prompt.root; <userinput>newfs /dev/rda2c</userinput></screen>

	  <para>e monte-o:</para>

	  <screen>&prompt.root; <userinput>mount /dev/da2c /zip</userinput></screen>

	  <para>provavelmente é uma boa idéia adicionar
	    uma entrada no <filename>/etc/fstab</filename> para
	    facilitar o processo de montagem dessa unidade(veja
	    &man.fstab.5;)de forma que seja apenas necessário
	    digitar o comando <command>mount /zip</command> no
	    futuro:</para>

	  <programlisting>/dev/da2c /zip ffs rw,noauto 0 0</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mount-cd-superblock">
	  <para>Por que eu tive o erro <errorname>Incorrect super
	      block</errorname> na hora de montar um CDROM?</para>
	</question>

	<answer>
	  <para>É necessário avisar ao &man.mount.8; que
	    tipo de unidade está sendo montada.  Essa
	    definição é tratada com mais detalhes
	    em <ulink url="../handbook/creating-cds.html"> na
	      seção de mídias ópticas do
	      &a.ptbr.p.handbook; </ulink>, mais precisamente na
	    seção <ulink
	      url="../handbook/creating-cds.html#MOUNTING-CD">Usando
	      CDs de Dados</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cdrom-not-configured">
	  <para><errorname>Device not configured</errorname> ocorre na
	    hora de montar o CDROM?</para>
	</question>

	<answer>
	  <para>Geralmente esse tipo de comportamento indica que
	    não existe nenhum CD na unidade de CDROM, ou
	    então, que o CD em questão não
	    é visível ao barramento de dados do seu PC,
	    comum quando um CD-RW não pode ser lido por um
	    drive tradicional.  Por gentileza, queira referir-se a
	    <ulink
	      url="../handbook/creating-cds.html#MOUNTING-CD">Usando
	      CDs de Dados </ulink> da seção do
	    &a.ptbr.p.handbook; para uma discussão mais
	    detalhada sobre esse assunto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cdrom-unicode-filenames">
	  <para>Porque todos caracteres não-Inglês
	    são apresentados como <quote>?</quote> no sistema
	    de arquivos do CD que acabou de ser montado no
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Provavelmente seu CDROM usa extensões
	    <quote>Joliet</quote> para armazenar
	    informações sobre tipos de arquivos e
	    diretórios.  Esse assunto é discutido no
	    capítulo de <ulink
	      url="../handbook/creating-cds.html">
	      Criação e Uso de CDROMs do
	      &a.ptbr.p.handbook;</ulink>, mais precisamente na
	    seção <ulink
	      url="../handbook/creating-cds.html#MOUNTING-CD">de Uso
	      de CDs de Dados</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="burncd-isofs">
	  <para>Eu queimei um CD no FreeBSD e agora esse disco
	    não pode ser lido em nenhum outro sistema
	    operacional.  Por que?</para>
	</question>

	<answer>
	  <para>Provavelmente você queimou um CD de forma crua
	    (usando raw mode) no seu sistema, ao invés de criar
	    um sistema de arquivos do tipo ISO 9660.  Dê uma
	    olhada no <ulink url="../handbook/creating-cds.html">
	      Capítulo de Criação de CDROMs do
	      &a.ptbr.p.handbook;</ulink>, em específico na
	    seção <ulink
	      url="../handbook/creating-cds.html#RAWDATA-CD">criando
	      CDS de dados puros</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="copy-cd">
	  <para>Como posso criar uma imagem de um CD de dados?</para>
	</question>

	<answer>
	  <para>A criação de imagens de CDs de dados
	    é discutida na seção <ulink
	      url="../handbook/creating-cds.html#IMAGING-CD">duplicando
	      CDs de dados do &a.ptbr.p.handbook;</ulink>.  Para mais
	    informações sobre unidades ópticas,
	    por gentileza, queira referir-se a seção
	    <ulink url="../handbook/creating-cds.html">
	      Criação de CDs</ulink> no capítulo
	    de Armazenamento do &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mount-audio-CD">
	  <para>Por que um CD de áudio não pode ser
	    montado com o comando <command>mount</command>?</para>
	</question>

	<answer>
	  <para>Ao tentar montar um CD de áudio, o mais
	    provável é que ocorra um erro do tipo
	    <errorname>cd9660: /dev/acd0c: Invalid
	      argument</errorname>.  Isso se deve ao fato que o
	    comando <command>mount</command> trabalha exclusivamente
	    com sistema de arquivos, o que não é o caso
	    de CDs de áudio.  CDs de áudio contém
	    apenas dados, e por isso é necessário alguma
	    aplicação capaz de ler tais CDs.  Use algum
	    programa como o <filename
	      role="package">audio/xmcd</filename>na
	    coleção de <literal>Ports</literal> do
	    FreeBSD para ler dados em CDs desse tipo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multi-session-CD">
	  <para>Como eu monto um CD com múltiplas
	    sessões de gravação?</para>
	</question>

	<answer>
	  <para>Por padrão, o &man.mount.8; tenta montar a
	    última trilha de dados (sessão) de um CD.
	    Caso queira montar uma sessão anterior pode-se usar
	    o argumento <option>-s</option> na linha de comando em
	    questão.  Por gentileza, refira-se a página
	    de manual do comando &man.mount.cd9660.8; para obter
	    exemplos específicos do uso dessa e de outras
	    opções.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="user-floppymount">
	  <para>Como posso permitir que usuários comuns montem
	    disquetes, CDROMs e outros tipos de mídia
	    removível?</para>
	</question>

	<answer>
	  <para>Usuários comuns podem ter a permissão de
	    montar dispositivos.  Veja como:</para>

	  <procedure>
	    <step>
	      <para>Como <username>root</username> defina a
		variável <varname>vfs.usermount</varname> do
		sysctl para <literal>1</literal>.</para>

	      <screen>&prompt.root; <userinput>sysctl -w vfs.usermount=1</userinput></screen>
	    </step>

	    <step>
	      <para>Como <username>root</username> defina as
		permissões apropriadas nos dispositivos
		associados ao controle da mídia
		removível.</para>

	      <para>Por exemplo, para permitir que os usuários
		possam montar a primeira unidade de disquete,
		use:</para>

	      <screen>&prompt.root; <userinput>chmod 666 /dev/fd0</userinput></screen>

	      <para>Para permitir que os usuários do grupo
		<groupname>operator</groupname> montem a unidade de
		CDROM, use:</para>

	      <screen>&prompt.root; <userinput>chgrp operator /dev/cd0c</userinput>
&prompt.root; <userinput>chmod 640 /dev/cd0c</userinput></screen>
	    </step>

	    <step>
	      <para>Finalmente, para tornar essa
		alteração permanente, adicione a linha
		<literal><varname> vfs.usermount</varname>=1</literal>
		no arquivo
		<filename>/etc/sysctl.conf</filename>.</para>
	    </step>
	  </procedure>

	  <para>Agora todos os usuários podem montar qualquer
	    disquete no <devicename>/dev/fd0</devicename> em algum
	    ponto de montagem que lhes pertença:</para>

	  <screen>&prompt.user; <userinput>mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput>mount -t msdos /dev/fd0 ~/my-mount-point</userinput></screen>

	  <para>Os usuários no grupo
	    <groupname>operator</groupname> agora tem permissão
	    para montar os CDs no <devicename>/dev/cd0c</devicename>
	    em qualquer ponto de montagem que lhes
	    pertença:</para>

	  <screen>&prompt.user; <userinput>mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput>mount -t msdos /dev/cd0c ~/my-mount-point</userinput></screen>

	  <para>Desmontar o dispositivo é extremamente
	    simples:</para>

	  <screen>&prompt.user; <userinput>umount <filename>~/my-mount-point</filename></userinput></screen>

	  <para>Contudo, habilitar a opção
	    <varname>vfs.usermount</varname>, contudo, causa algumas
	    implicâncias quanto ao quesito segurança;.  A
	    forma mais racional de acessar mídia do tipo MSDOS
	    no FreeBSD é usando a aplicação
	    <ulink
	      url="http://www.FreeBSD.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name">mtools
	    </ulink>, disponível na Coleção de
	    <literal>Ports</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="du-vs-df">
	  <para>Os comandos <command>du</command> e
	    <command>df</command> apresentam quantias distintas de
	    espaço em disco disponível.  O que
	    está havendo?</para>
	</question>

	<answer>
	  <para>É necessário entender o que os comandos
	    <command>du</command> e <command>df</command> realmente
	    fazem.  O <command>du</command> percorre a árvore
	    de diretórios medindo o tamanho de cada arquivo e
	    apresentando o total da soma de todos os arquivos
	    encontrados em um dado diretório, e posteriormente
	    apresentando a soma de ambos subdiretórios no
	    diretório de nível seguinte,
	    <command>df</command> simplesmente pergunta ao sistema de
	    arquivos quanto espaço ainda lhe resta.  Parece o
	    mesmo comportamento, mas um arquivo alocado fora de um
	    diretório, por exemplo, afeta os dados apresentados
	    pelo <command>df</command>, mas não afeta o
	    <command>du</command>.</para>

	  <para>Quando um programa está usando algum arquivo, e
	    este é apagado, o arquivo não é
	    retirado do sistema de arquivos até que o programa
	    em questão pare de usá-lo.  Contudo, esse
	    arquivo é imediatamente deletado da listagem de
	    diretórios; isso pode ser mais bem observado com
	    algum paginador como o <command>more</command>.  Por
	    exemplo, assuma que existe um arquivo grande o bastante
	    que sua presença seja perceptível claramente
	    na saída dos comandos <command>du</command> e
	    <command>df</command>.  (Considerando que hoje em dia os
	    discos são bem grandes, o arquivo em questão
	    deve ser um arquivo de tamanho <emphasis>extremamente
	      considerável!</emphasis>) Caso o arquivo seja
	    apagado em quanto ele esteja sendo paginado com o
	    <command>more</command>, pode-se perceber que o
	    <command>more</command> não passa a reclamar que o
	    arquivo não pode mais ser visualizado no mesmo
	    instante.  Contudo, a listagem, do diretório em
	    questão não apresentará mais esse
	    arquivo, de forma que nenhum usuário ou outro
	    programa possa acessá-lo.  A entrada do arquivo no
	    diretório é simplesmente removida.  O
	    <command>du</command> vai mostrar que esse arquivo
	    não existe mais &mdash; -- afinal, o du percorreu
	    todo o diretório e não encontrou esse
	    arquivo listado -- contudo o <command>df</command> mostra
	    que o arquivo continua no disco, pois o sistema de
	    arquivos sabe que o <command>more</command> continua
	    usando aquele espaço de dados que se encontram no
	    disco.  Uma vez terminada a sessão do
	    <command>more</command>,<command>du</command> e
	    <command>df</command> concordarão entre si.</para>

	  <para>Note que em sistemas de arquivos com softupdates, a
	    liberação de espaço em disco
	    também pode ser atrasada em até 30 segundos
	    dependendo da situação; apenas depois desse
	    tempo, a alteração em disco será
	    visível!</para>

	  <para>Esse comportamento é comum e fácil de
	    ser observado em Servidores Web.  Muitos usuários
	    configuram algum Servidor Web no FreeBSD e se esquecem de
	    rotacionar os arquivos de log da aplicação,
	    os quais entopem o <filename>/var</filename>.  O novo
	    administrador do sistema deleta os arquivos de log em
	    questão, mas o sistema operacional continua
	    reclamando que a partição está cheia,
	    até que o Servidor Web seja desligado e religado,
	    de forma que a aplicação libera o arquivo e
	    permite que o sistema apague o arquivo, recuperando o
	    espaço em disco em questão.  Para prevenir
	    que isso ocorra, configure o &man.newsyslog.8;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="add-swap-space">
	  <para>Como eu posso adicionar mais espaço para
	    <foreignphrase>swap</foreignphrase>?</para>
	</question>

	<answer>
	  <para>No capítulo <ulink
	      url="../handbook/config-tuning.html">Configuração
	      e Ajuste Fino
	      (<foreignphrase>Tuning</foreignphrase>)</ulink> do
	    &a.ptbr.p.handbook;, pode ser encontrada uma <ulink
	      url="../handbook/adding-swap-space.html">seção
	    </ulink> descrevendo como fazer isto.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="admin">
    <title>Administração do Sistema</title>

    <qandaset>
      <qandaentry>
	<question id="startup-config-files">
	  <para>Onde estão os arquivos que configuram a
	    inicialização do sistema ?</para>
	</question>

	<answer>
	  <para>Do FreeBSD 2.0.5R até o 2.2.1R, o arquivo de
	    configurações primário é o
	    <filename>/etc/sysconfig</filename>.  Todas as
	    opções devem ser definidas nesse arquivo ou
	    então em outros, como o
	    <filename>/etc/rc</filename> (veja o manual para o
	    &man.rc.8;) e o <filename>/etc/netstart</filename></para>

	  <para>Dê uma olhada no
	    <filename>/etc/sysconfig</filename> e altere as
	    variáveis de acordo com o que você quer
	    configurar no seu sistema.  O arquivo é repleto de
	    comentários que auxiliam a correta
	    definição dos valores a serem
	    definidos.</para>

	  <para>A partir do 2.2.1 até o 3.0, o
	    <filename>/etc/sysconfig</filename> foi renomeado para
	    &man.rc.conf.5;, que é auto-descritivo, e cuja
	    sintaxe foi melhorada no processo de
	    substituição.  O
	    <filename>/etc/netstart</filename> agora se chama
	    <filename>/etc/rc.network</filename>, de forma que todos
	    os arquivos possam ser copiados com um simples comando
	    como um <command>cp /usr/src/etc/rc* /etc</command></para>

	  <para>E depois, a partir do FreeBSD 3.1, o
	    <filename>/etc/rc.conf</filename> foi alterado para o
	    <filename>/etc/defaults/rc.conf</filename>.
	    <emphasis>Não edite esse arquivo!</emphasis> Ao
	    invés disso, para todas as entradas que você
	    queira alterar no
	    <filename>/etc/defaults/rc.conf</filename>, basta apenas
	    copiar a linha relativa à essa entrada para o
	    <filename>/etc/rc.conf</filename> e depois modificar seu
	    valor.</para>

	  <para>Por exemplo, caso deseje iniciar o named, o servidor
	    DNS disponível no FreeBSD, a partir do FreeBSD 3.1
	    basta fazer isso:</para>

	  <screen>&prompt.root; <userinput>echo named_enable="YES" &gt;&gt; /etc/rc.conf</userinput></screen>

	  <para>Para iniciar serviços locais no FreeBSD 3.1 e
	    posteriores, basta colocar os scripts shell de
	    inicialização desses serviços no
	    diretório <filename>/usr/local/etc/rc.d</filename>.
	    Tais shell scripts devem ser executáveis e
	    terminarem com a extensão .sh.  No FreeBSD 3.0 ou
	    anteriores, o arquivo <filename>/etc/rc.local</filename>
	    era a única opção para iniciar
	    serviços/processos locais automaticamente.</para>

	  <para>O arquivo <filename>/etc/rc.serial</filename> é
	    usado para a inicialização de portas seriais
	    (por exemplo, para definir as características das
	    portas, e assim por diante).</para>

	  <para>O arquivo <filename>/etc/rc.i386</filename> é
	    usado para configurações específicas
	    de sistemas Intel e compatíveis, como por exemplo,
	    emulação iBCS2 ou definições
	    do sistema de console dos PC.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="adding-users">
	  <para>Como posso adicionar um usuário de forma
	    simples?</para>
	</question>

	<answer>
	  <para>Use o comando &man.adduser.8;.  Caso prefira uma forma
	    mais complexa (e mais completa), use o comando
	    &man.pw.8;.</para>

	  <para>Para remover o usuário do sistema, use o
	    comando &man.rmuser.8;.  Mais uma vez, o &man.pw.8;
	    também funciona muito bem nesse caso.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="root-not-found-cron-errors">
	  <para>Depois de editar o crontab, mensagens como
	    <errorname>root: not found</errorname> ficam aparecendo
	    sempre.  Por que?</para>
	</question>

	<answer>
	  <para>Normalmente esse é um problema causado ao se
	    editar o crontab do sistema
	    (<filename>/etc/crontab</filename>) e depois usar o
	    &man.crontab.1; para instala-lo:</para>

	  <screen>&prompt.root; <userinput>crontab /etc/crontab</userinput></screen>

	  <para>Essa não é a forma correta de fazer as
	    coisas.  O crontab do sistema tem um formato distinto do
	    crontab dos usuários, o qual o &man.crontab.1;
	    atualiza (o manual do &man.crontab.5; explica tais
	    diferenças de forma mais detalhada).</para>

	  <para>Caso você tenha cometido esse engano, o novo
	    crontab é uma simples cópia do
	    <filename>/etc/crontab</filename>, ou seja, com um formato
	    errado.  Apague-o com o comando:</para>

	  <screen>&prompt.root; <userinput>crontab -r</userinput></screen>

	  <para>Da próxima vez que editar o
	    <filename>/etc/crontab</filename>, nenhuma
	    ação precisa ser tomada para avisar o
	    &man.cron.8; das alterações.  Ele vai
	    perceber as mudanças automaticamente.</para>

	  <para>Caso queira executar alguma tarefa diária,
	    semanal ou mensal, é mais indicado adicionar alguns
	    scripts de shell sob o
	    <filename>/usr/local/etc/periodic</filename> e deixar o
	    programa &man.periodic.8;, chamado a partir da tabela cron
	    do sistema, cuidar das suas tarefas assim como ele faz com
	    as outras tarefas pertinentes ao sistema.</para>

	  <para>A única razão para esse erro é
	    que a tabela de cron do sistema tem um campo a mais, que
	    especifica o usuário que deve executar o comando.
	    No crontab do sistema padrão do FreeBSD, esse
	    usuário é o <username>root</username>, em
	    todas as entradas.  Quando essa crontab é usada
	    como a tabela de cron do <username>root</username> (que
	    é diferente da tabela de cron do sistema), o
	    &man.cron.8; assume que a string <username>root</username>
	    fosse um primeiro comando, mas esse comando não
	    existe, por isso ocorre o erro.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="su-wheel-group">
	  <para>Porque o erro <errorname>you are not in the correct
	      group to su root</errorname> ocorre, quando eu tento
	    virar <username>root</username> com o su ?</para>
	</question>

	<answer>
	  <para>Essa é uma característica de
	    segurança do FreeBSD.  Para se tornar
	    <username>root</username> com o su (ou qualquer outro
	    usuário com privilégios de super
	    usuário), é preciso fazer parte do grupo
	    <groupname>wheel</groupname>.  Sem essa
	    característica, qualquer usuário com uma
	    conta válida no sistema que soubesse a senha de
	    <username>root</username> poderia obter privilégios
	    de super usuário.  Por causa do comportamento
	    atual, essa afirmação não é
	    verdadeira, uma vez que o su não vai nem permitir
	    que o usuário dê a senha de
	    <username>root</username>, caso ele não esteja no
	    grupo <groupname>wheel</groupname>.</para>

	  <para>Para permitir que algum usuário se torne
	    <username>root</username>, basta que ele faça parte
	    do grupo <groupname>wheel</groupname>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="rcconf-readonly">
	  <para>Cometi um erro no <filename>rc.conf</filename>, ou em
	    algum outro arquivo de inicialização, e
	    agora não posso corrigir essa
	    alteração porque o sistema de arquivos
	    é apenas-leitura.  O que devo fazer?</para>
	</question>

	<answer>
	  <para>Nessa situação, o comportamento esperado
	    é que o sistema entre em modo monousuário e
	    peça o caminho completo para o seu interpretador de
	    comandos (sua shell).  Basta confirmar a shell
	    padrão, que ele oferece, com um simples
	    <literal>ENTER</literal>, e depois executar um
	    <command>mount /</command> para remontar o sistema de
	    arquivos raiz ( / ) em modo leitura/escrita (rw).
	    Também pode ser necessário executar um
	    <command>mount -a -t ufs</command> para montar o sistema
	    de arquivos onde o seu editor de texto preferido vai estar
	    disponível.  Caso seu editor esteja em um sistema
	    de arquivos da rede, será necessário
	    configurar a rede manualmente, ou usar um editor
	    disponível localmente, como o &man.ed.1;.</para>

	  <para>Caso queira usar um editor de tela inteira como o
	    &man.vi.1; ou &man.emacs.1;, será necessário
	    definir a variável de ambiente TERM como do tipo
	    cons25, bastando um simples export TERM=cons25, de forma
	    que tais editores possam carregar as
	    informações corretas da base de dados do
	    &man.termcap.5;.</para>

	  <para>Depois disso, o <filename>/etc/rc.conf</filename> pode
	    ser editado normalmente, e a sintaxe problemática,
	    corrigida.  A mensagem de erro apresentada imediatamente
	    após o carregamento do
	    <foreignphrase>kernel</foreignphrase> indica o
	    número da linha e o arquivo onde o erro
	    aconteceu.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="printer-setup">
	  <para>Porque estou tendo problemas ao configurar minha
	    impressora?</para>
	</question>

	<answer>
	  <para>Por gentileza, dê uma olhada nas páginas
	    sobre impressão do &a.ptbr.p.handbook;.  O
	    documento deve responder a maioria de suas dúvidas.
	    Veja a entrada sobre <ulink
	      url="../handbook/printing.html">Impressão no
	      &a.ptbr.p.handbook;</ulink>.</para>

	  <para>Algumas impressoras precisam de um driver local,
	    baseado em estações, para prover qualquer
	    tipo de impressão.  Essas impressoras são
	    chamadas de <quote>WinPrinters</quote> e não
	    são suportadas nativamente pelo FreeBSD.  Se sua
	    impressora não funciona sob DOS ou com Windows NT
	    4.0, provavelmente ela é uma WinPrinter.  A
	    única esperança de se obter uma impressora
	    desse tipo funcionando, é verificar se o
	    <literal>port</literal> <filename
	      role="package">print/pnm2ppa</filename> tem suporte para
	    ela.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="keyboard-mappings">
	  <para>Como posso corrigir o mapeamento de teclados do meu
	    sistema?</para>
	</question>

	<answer>
	  <para>Por gentileza, refira-se à seção
	    usando <ulink
	      url="../handbook/using-localization.html">localização
	      do &a.ptbr.p.handbook;</ulink>, mais precisamente na
	    parte sobre a <ulink
	      url="../handbook/using-localization.html#SETTING-CONSOLE">configuração
	      do console</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="pnp-resources">
	  <para>O que causa mensagens como: <errorname>unknown:
	      &lt;PNP0303&gt; can't assign resources</errorname> na
	    inicialização do sistema?</para>
	</question>

	<answer>
	  <para>O trecho a seguir é citação de
	    uma mensagem enviada na lista freebsd-current.</para>

	  <blockquote>
	    <attribution>&a.wollman;, 24 Abril 2001</attribution>

	    <para>A mensagem <quote>can't assign resources</quote>
	      indica que os equipamentos em questão são
	      do tipo ISA, e que não existem entradas indicando
	      drivers não-PnP compiladas no
	      <foreignphrase>kernel</foreignphrase>.  Esses
	      equipamentos podem ser controladoras de teclados,
	      controladora de interrupção
	      programável e várias outras peças
	      da infra-estrutura padrão do sistema.  Os
	      recursos não podem ser atribuídos por
	      já existirem drivers usando tais
	      endereços.</para>
	  </blockquote>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="user-quotas">
	  <para>Porque eu não consigo fazer as quotas de
	    usuários funcionarem de forma correta?</para>
	</question>

	<answer>
	  <orderedlist>
	    <listitem>
	      <para>Não habilite quotas na
		<filename>/</filename>,</para>
	    </listitem>

	    <listitem>
	      <para>Coloque o arquivo de quotas indicando o sistema de
		arquivos onde se deseja estabelecer as quotas, por
		exemplo:</para>

	      <informaltable frame="none">
		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Sistemas de arquivos</entry>

		      <entry>Arquivos de quotas</entry>
		    </row>
		  </thead>

		  <tbody>
		    <row>
		      <entry><filename>/usr</filename></entry>

		      <entry><filename>/usr/admin/quotas</filename></entry>
		    </row>

		    <row>
		      <entry><filename>/home</filename></entry>

		      <entry><filename>/home/admin/quotas</filename></entry>
		    </row>

		    <row>
		      <entry>&hellip;</entry>

		      <entry>&hellip;</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </informaltable>
	    </listitem>
	  </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sysv-ipc">
	  <para>O FreeBSD suporta as primitivas de IPC do System
	    V?</para>
	</question>

	<answer>
	  <para>Sim, o FreeBSD suporta IPC ao estilo do System V.
	    Esse suporte inclui compartilhamento de memória,
	    mensagens e semáforos.  É necessário
	    adicionar as seguintes linhas no arquivo de
	    configurações do seu
	    <foreignphrase>kernel</foreignphrase>, para ativar o
	    suporte:</para>

	  <programlisting>options    SYSVSHM	  # habilita memória compartilhada
options    SYSVSEM          # habilita semáforos
options    SYSVMSG          # habilita mensagens</programlisting>

	  <note>
	    <para>No FreeBSD 3.2 e posteriores, tais
	      opções já fazem parte do
	      <foreignphrase>kernel</foreignphrase>
	      <emphasis>GENERIC</emphasis>, o que significa que tal
	      suporte já deve estar compilado no seu
	      sistema.</para>
	  </note>

	  <para>Recompile e instale o novo
	    <foreignphrase>kernel</foreignphrase>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="uucpmail">
	  <para>Como posso usar o sendmail para entregar mensagens com
	    UUCP?</para>
	</question>

	<answer>
	  <para>A configuração do sendmail
	    disponível por padrão no FreeBSD é
	    direcionada para sites que estejam conectados à
	    Internet.  Servidores que pretendem entregar suas
	    mensagens via UUCP devem instalar um novo arquivo de
	    configurações do sendmail.</para>

	  <para>Alterar o <filename>/etc/mail/sendmail.cf</filename>
	    manualmente é considerado tarefa para os mais
	    puristas.  A versão 8 do sendmail tem uma nova
	    abordagem de arquivos de configuração por
	    meio de pré processamento com o &man.m4.1;, onde os
	    modelos de configuração são
	    manipulados em um nível mais alto de
	    abstração.  Use os arquivos de
	    configuração disponíveis sob
	    /usr/src/usr.sbin/sendmail/cf.</para>

	  <para>Caso seu sistema não tenha sido instalado com
	    os fontes, os arquivos de configuração do
	    sendmail foram divididos em pacotes separados.  Assumindo
	    que você tenha o CDROM do FreeBSD montado,
	    faça o seguinte:</para>

	  <screen>&prompt.root; <userinput>cd /cdrom/src</userinput>
&prompt.root; <userinput>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</userinput></screen>

	  <para>Não se desespere, são apenas algumas
	    centenas de Kilobytes em tamanho.  O arquivo README no
	    diretório cf serve de introdução
	    básica ao uso do m4.</para>

	  <para>Para entregar mensagens via UUCP, o melhor conselho
	    é usar o <literal>mailtertable</literal>.  Trata-se
	    de uma base de dados que o sendmail usa para basear suas
	    decisões de roteamento de mensagens.</para>

	  <para>Primeiro, é necessário criar seu arquivo
	    <filename>.mc</filename>.  O diretório
	    <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename>
	    é o diretório home para esse tipo de
	    arquivo.  Dê uma olhada, já existem alguns
	    exemplos disponíveis por lá.  Se assumirmos
	    que você chamou o arquivo de
	    <filename>foo.mc</filename>, para converte-lo para um
	    arquivo <filename>sendmail.cf</filename> válido
	    basta:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail/cf/cf</userinput>
&prompt.root; <userinput>make foo.cf</userinput>
&prompt.root; <userinput>cp foo.cf /etc/mail/sendmail.cf</userinput></screen>

	  <para>Um arquivo <filename>.mc</filename> típico, se
	    parece com algo mais ou menos assim:</para>

	 <programlisting>VERSIONID(`<replaceable>Número da sua versão</replaceable>')
OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable')

define(`UUCP_RELAY', <replaceable>your.uucp.relay</replaceable>)
define(`UUCP_MAX_SIZE', 200000)
define(`confDONT_PROBE_INTERFACES')

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <replaceable>your.alias.host.name</replaceable>
Cw    <replaceable>youruucpnodename.UUCP</replaceable></programlisting>

	  <para>As linhas contendo as entradas
	    <literal>accept_unresolvable_domains</literal>,
	    <literal>nocanonify</literal>, e
	    <literal>confDONT_PROBE_INTERFACES</literal> previnem o
	    uso do DNS durante a entrega das mensagens.  A
	    cláusula <literal>UUCP_RELAY</literal> é
	    necessária por razões bizarras, nem pergunte
	    quais.  Apenas coloque o nome de uma estação
	    que possa manipular endereços com
	    pseudo-domínio .UUCP;  normalmente o
	    endereço de relay de e-mail do seu Provedor de
	    Serviço Internet deve servir.</para>

	  <para>Depois disso, é necessário usar o
	    arquivo <filename>/etc/mail/mailertable</filename>.  Caso
	    exista apenas um link para fora, por onde todos os e-mails
	    são roteados, as seguintes definições
	    são o bastante:</para>

	  <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.	 uucp-dom:<replaceable>your.uucp.relay</replaceable></programlisting>

	  <para>Um exemplo mais complexo, se pareceria com:</para>

	  <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</programlisting>

	  <para>Como pode-se perceber, se trata de um arquivo usado na
	    vida real.  As primeiras três linhas tratam
	    situações especiais onde as mensagens
	    endereçadas aquele domínio não devem
	    ser roteadas pela saída padrão, mas ao
	    invés disso, ser entregues para algum servidor UUCP
	    vizinho, de forma a encurtar o caminho para entrega dos
	    e-mails.  A linha seguinte trata mensagens para rede
	    Ethernet local, para domínios onde os mails possam
	    ser entregues via SMTP.  Finalmente, os vizinhos UUCP
	    são mencionados na notação do
	    pseudo-domínio .UUCP, que permite um
	    <literal><replaceable>uucp-neighbor</replaceable>!<replaceable>recipient</replaceable></literal>
	    sobrescrever as regras padrão.  A última
	    linha é sempre um ponto, que indica que todos os
	    e-mails que não foram tratados pelas entradas
	    anteriores cuja entrega seja do tipo UUCP, devem ser
	    tratados por um dos vizinhos UUCP que sirva como gateway
	    universal com o resto do mundo.  Todas as
	    estações antecedendo a entrada
	    <literal>uucp-dom:</literal> devem ser nomes de vizinhos
	    UUCP válidos, que podem ser checados com o comando
	    <literal>uuname</literal>.</para>

	  <para>Para lembrar que esse arquivo precisa ser convertido
	    em base de dados do tipo DBM, o comando necessário
	    para tomar essa ação está comentado
	    no início do arquivo mailertable.  Esse comando
	    deve ser executado sempre que o mailertable for
	    alterado.</para>

	  <para>Dica final: caso tenha dúvidas se uma rota de
	    e-mail em particular irá funcionar, lembre-se que a
	    opção <option>-bt</option> do sendmail
	    permite que ele seja iniciado em modo de testes de
	    endereço; simplesmente digite
	    <literal>3,0</literal> seguido do endereço que
	    você quer testar o roteamento de mensagens.  A
	    última linha irá indicar o agente de
	    transferência interno que foi usado, a
	    estação de destino com a qual esse agente de
	    entrega irá se comunicar, e o seu endereço.
	    Para sair desse modo, digite Control-D.</para>

	  <screen>&prompt.user; <userinput>sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<prompt>&gt;</prompt> <userinput>3,0 foo@example.com</userinput>
canonify           input: foo @ example . com
...
parse            returns: $# uucp-dom $@ <replaceable>your.uucp.relay</replaceable> $: foo &lt; @ example . com . &gt;
<prompt>&gt;</prompt> <userinput>^D</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ispmail">
	  <para>Como eu configuro e-mail em uma conexão dialup
	    com a rede?</para>
	</question>

	<answer>
	  <para>Se a sua conexão discada lhe atribui um
	    endereço IP estático, não é
	    necessário configurar nenhuma opção
	    extra.  Ajuste o nome da sua estação para o
	    nome que a identifica na Internet, e o sendmail
	    fará o resto.</para>

	  <para>Mas se a conexão PPP lhe atribui
	    endereços dinâmicos, provavelmente o seu
	    Provedor de Serviço Internet oferece uma conta de
	    correio eletrônico em seus servidores.  Vamos
	    assumir que o nome do domínio do seu provedor
	    é <hostid role="domainname">example.net</hostid>, e
	    que o nome do seu usuário é
	    <username>user</username>.  Vamos assumir também
	    que o nome da sua estação seja <hostid
	      role="fqdn">bsd.home</hostid> e que o Provedor de
	    Serviço Internet defina que o endereço
	    <hostid role="fqdn">relay.example.net</hostid> deva ser
	    usado para relay de mensagens eletrônicas.</para>

	  <para>Para acessar as mensagens da sua caixa de correio,
	    é necessário usar um agente de busca.  O
	    <application>Fetchmail</application> é uma boa
	    escolha, já que ele suporta vários
	    protocolos distintos.  Normalmente o provedor em
	    questão oferece serviço de POP3.  Caso sua
	    conexão PPP seja estabelecida à nível
	    de usuário (user-PPP), para acessar suas mensagens
	    automaticamente ao estabelecer-se uma conexão com a
	    rede, basta adicionar a seguinte entrada no arquivo
	    <filename>/etc/ppp/ppp/linkup</filename>:</para>

	  <programlisting>MYADDR:
  !bg su user -c fetchmail</programlisting>

	  <para>Caso esteja usando o
	    <application>sendmail</application> (como foi descrito
	    anteriormente) para entregar suas mensagens para
	    endereços não-locais, insira o
	    comando:</para>

	  <programlisting>  !bg su user -c "sendmail -q"</programlisting>

	  <para>depois da entrada apresentada anteriormente.  Esse
	    comando irá forçar o
	    <application>sendmail</application> a processar sua fila
	    de e-mail tão logo uma conexão com a&nbsp;
	    rede seja estabelecida.</para>

	  <para>Assumindo que exista uma conta para o
	    <username>user</username> na máquina <hostid
	      role="fqdn">bsd.home</hostid>.  No diretório home
	    do <username>user</username> na estação
	    <hostid role="fqdn">bsd.home</hostid>, crie um arquivo
	    <filename>.fetchmailrc</filename>  com o seguinte
	    conteúdo:</para>

	  <programlisting>poll example.net protocol pop3 fetchall pass MySecret</programlisting>

	  <para>Esse arquivo não deve ter permissão de
	    leitura para nenhum outro usuário, a não ser
	    o <username>user</username> já que ele
	    contém a <literal>sua senha</literal>.</para>

	  <para>Para garantir que o cabeçalho
	    <literal>from:</literal> esteja sempre correto, é
	    necessário indicar ao
	    <application>sendmail</application> que o endereço
	    <literal>user@example.net</literal>  deve ser usado ao
	    invés de <literal>user@bsd.home</literal>.
	    Também é interessante configurar o
	    <application>sendmail</application> para entregar suas
	    mensagens via <hostid
	      role="fqdn">relay.example.net</hostid>, permitindo
	    transmissão de mensagens de forma mais
	    rápida.</para>

	  <para>O seguinte arquivo <filename>.mc</filename> deve ser o
	    bastante:</para>

	  <programlisting>VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl</programlisting>

	  <para>Por gentileza, refira-se à seção
	    anterior para obter detalhes sobre como transformar esse
	    arquivo <filename>.mc</filename> em um arquivo
	    <filename>sendmail.cf</filename>.  Não se
	    esqueça também de reiniciar o
	    <application>sendmail</application> depois de alterar o
	    <filename>sendmail.cf</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sendmail-alternative">
	  <para>Que outros servidores de correio eletrônico
	    posso usar no lugar do Sendmail?</para>
	</question>

	<answer>
	  <para>O <ulink
	      url="http://www.sendmail.org/">Sendmail</ulink> é
	    o programa servidor de correio eletrônico
	    padrão no FreeBSD, mas ele pode ser facilmente
	    substituído por qualquer outro MTA (por
	    instância, um MTA instalado a partir do
	    <literal>ports</literal>).</para>

	  <para>Existem vários MTA's que servem de alternativa
	    ao Sendmail na Coleção de
	    <literal>Ports</literal> do FreeBSD, sendo o <filename
	      role="package">mail/exim</filename>, <filename
	      role="package">mail/postfix</filename>, <filename
	      role="package">mail/qmail</filename>, <filename
	      role="package">mail/zmailer</filename>, os mais
	    populares.</para>

	  <para>A diversidade é sempre uma boa
	    indicação, e o fato de ter vários
	    servidores de e-mail disponíveis é
	    ótimo.  Conteúdo, evite perguntas como
	    <quote>O Sendmail é melhor que o Qmail?</quote> nas
	    listas de discussão.  Se você realmente quer
	    saber, procure no histórico das listas.  As
	    vantagens e desvantagens de cada MTA já foram
	    discutidas inúmeras vezes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="forgot-root-pw">
	  <para>Esqueci a senha de root!  O que eu faço?</para>
	</question>

	<answer>
	  <para>Em primeiro lugar, não entre em pânico!
	    Reinicie o seu FreeBSD, digite <userinput>boot
	      -s</userinput> na tela do Boot: (ou apenas
	    <userinput>-s</userinput> para as versões
	    anteriores à 3.2 do FreeBSD) para entrar e modo
	    monousuário.  Quando o sistema perguntar sobre que
	    shell usar, aperte ENTER.  Você estará em uma
	    prompt de comandos;  digite <command>mount -u /</command>
	    para montar o sistema de arquivos raiz com
	    leitura/escrita, e depois <command>mount -a</command> para
	    remontar todos os seus sistemas de arquivos.  Execute o
	    comando <command>passwd root</command> para modificar a
	    senha de root do sistema, e depois digite &man.exit.1;
	    para continuar &nbsp;a inicialização em modo
	    multiusuário.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="CAD-reboot">
	  <para>Como posso evitar que a seq&uuml;ência de teclas
	    <keycombo
	      action="simul"><keycap>Control</keycap><keycap>Alt</keycap><keycap>Delete</keycap></keycombo>
	    reinicie o sistema?</para>
       </question>

	<answer>
	  <para>Caso esteja usando o syscons (o driver padrão
	    para o console) em um sistema FreeBSD 2.2.7 ou posterior,
	    construa e instale um novo
	    <foreignphrase>kernel</foreignphrase> com a
	    opção:</para>

	  <programlisting>options SC_DISABLE_REBOOT</programlisting>

	  <para>Caso use o driver de console PCVT em um FreeBSD 2.2.5
	    ou posterior, use a seguinte linha:</para>

	  <programlisting>options PCVT_CTRL_ALT_DEL</programlisting>

	  <para>Em versões anteriores às citadas, edite
	    o mapeamento do seu teclado, usado para o console, e
	    substitua a palavra <literal>boot</literal> por
	    <literal>nop</literal>.  O mapeamento de teclado
	    padrão está em
	    <filename>/usr/share/syscons/keymaps/us.iso.kbd</filename>.
	    O <filename>/etc/rc.conf</filename> deve ser
	    instruído de forma que esse arquivo seja lido.  Se
	    você estiver usando um outro mapa específico
	    para o seu país, edite esse mapa ao invés do
	    padrão.</para>
      </answer>
      </qandaentry>

      <qandaentry>
	<question id="dos-to-unix-txt">
	  <para>Como posso converter arquivos de texto do DOS para o
	    formato do Unix?</para>
       </question>

	<answer>
	  <para>Use esse comando do perl:</para>

	  <screen>&prompt.user; <userinput>perl -i.bak -npe 's/\r\n/\n/g' file...  </userinput></screen>

	  <para>onde <literal>file</literal> indica o arquivo ou
	    arquivos a serem processados.  As
	    modificações são feitas no
	    próprio arquivo e o original é salvo com a
	    extensão .bak.</para>

	  <para>O comando &man.tr.1; também pode ser
	    usado:</para>

	  <screen>&prompt.user; <userinput>tr -d '\r' &lt; <replaceable>dos-text-file</replaceable> &gt; <replaceable>unix-file</replaceable></userinput></screen>

	  <para>Onde <replaceable>dos-text-file</replaceable> é
	    o arquivo com o texto em formato DOS, enquanto o
	    <replaceable>unix-file</replaceable> armazenará a
	    saída convertida.  Usar o &man.tr.1; é um
	    pouco mais rápido do que usar o perl.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="kill-by-name">
	  <para>Como eu mato processos pelo seu nome?</para>
	</question>

	<answer>
	  <para>Use o comando &man.killall.1;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="root-acl">
	  <para>Por que motivos o su está me atazanando pelo
	    fato de não pertencer à ACL do
	    <username>root</username>?</para>
	</question>

	<answer>
	  <para>Esse erro é proveniente do sistema de
	    autenticação da distrição do
	    Kerberos.  O problema não é uma
	    perturbação fatal.  Basta executar o su com
	    a opção -K ou então desinstalar o
	    Kerberos, como será descrito na próxima
	    questão.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="uninstall-kerberos">
	  <para>Como eu desinstalo o Kerberos?</para>
	</question>

	<answer>
	  <para>Para remover o Kerberos do sistema, reinstale a
	    distribuição <literal>bin</literal> da
	    versão que está sendo usada.  Caso tenha o
	    CDROM do FreeBSD, monte-o (vamos assumir, em /cdrom) e
	    execute os comandos:</para>

	  <screen>&prompt.root; <userinput>cd /cdrom/bin</userinput>
&prompt.root; <userinput>./install.sh</userinput></screen>

	  <para>Ou então, apague todas as opções
	    <quote>MAKE_KERBEROS</quote> do
	    <filename>/etc/make.conf</filename> e recompile todo o
	    sistema com um build world.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="add-pty">
	  <para>Como posso adicionar pseudo-terminais ao
	    sistema?</para>
	</question>

	<answer>
	  <para>Caso tenha inúmeras conexões telnet,
	    ssh, X, ou tela de usuário, é
	    provável que você atingirá o limite
	    dos seus pseudo-terminais.  Aqui estão as
	    instruções de como adicionar mais
	    pseudo-terminais:</para>

	  <procedure>
	    <step>
	      <para>Construa e instale um novo
		<foreignphrase>kernel</foreignphrase> com a
		linha</para>
	      <programlisting>pseudo-device pty 256</programlisting>
	      <para>em seu arquivo de
		configurações.</para>
	    </step>

	    <step>
	      <para>Execute os comandos</para>
	      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV pty{1,2,3,4,5,6,7}</userinput></screen>
	      <para>de forma a criar 256 novos devices para os novos
		terminais.</para>
	    </step>

	    <step>
	      <para>Edite o <filename>/etc/ttys</filename>  e adicione
		uma linha para cada um dos 256 terminais.  Tais
		entradas devem ter o formato correspondente às
		entradas já existentes, por exemplo:</para>
	      <programlisting>ttyqc none network</programlisting>
	      <para>A ordem de definição das letras
		é expressa como
		<literal>tty[pqrsPQRS][0-9a-v]</literal>, ao
		ilustrarmos em expressões regulares.</para>
	    </step>

	    <step>
	      <para>Reinicie o sistema com o novo
		<foreignphrase>kernel</foreignphrase>, e
		pronto.</para>
	    </step>
	  </procedure>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="create-snd0">
	  <para>Por que motivo não consigo criar a device
	    snd0?</para>
	</question>

	<answer>
	  <para>Simples, porque não existe a device
	    <devicename>snd</devicename>.  Esse nome é usado
	    para identificar o conjunto de devices que compõem
	    os drivers de som do FreeBSD, como as devices
	    <devicename>mixer</devicename>,
	    <devicename>sequencer</devicename>, e
	    <devicename>dsp</devicename>.</para>

	  <para>Para criar tais devices, basta executar:</para>

	 <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="reread-rc">
	  <para>Como posso reler o <filename>/etc/rc.conf</filename> e
	    reiniciar o <filename>/etc/rc</filename> sem rebootar o
	    sistema?</para>
	</question>

	<answer>
	  <para>Vá para o modo monousuário e volte para
	    o modo multiusuário.</para>

	  <para>É simples; no console, faça:</para>

	  <screen>&prompt.root; <userinput>shutdown now</userinput>
(Note: without -r or -h)

&prompt.root; <userinput>return</userinput>
&prompt.root; <userinput>exit</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sandbox">
	  <para>O que é uma sandbox?</para>
	</question>

	<answer>
	  <para><quote>Sandbox</quote> é um jargão usado
	    em discussões pertinentes à segurança
	    de sistemas.  Pode significar duas coisas:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Um processo enquadrado em um conjunto de paredes
		virtuais que são criadas para prevenir que
		algum usuário, ao explorar alguma
		inconformidade do processo, possa também
		explorar e obter privilégios no sistema
		operacional como um todo.</para>

	      <para>O processo deve conseguir <quote>rodar</quote>
		dentro dessas paredes, ou seja, nada que o processo
		possa fazer ao executar seu código, pode ser
		capaz de violar tais paredes.  Dessa forma não
		é necessária uma auditoria detalhada do
		código e das ações do processo
		para que se possa realizar algumas
		afirmações pertinentes à
		segurança de tal sistema.</para>

	      <para>Tais paredes podem ser a
		identificação de um usuário
		(userid), por exemplo.  Essa é a
		definição de sandbox usada nas
		páginas de manuais do named e de
		security.</para>

	      <para>Observe o serviço <literal>ntalk</literal>,
		como exemplo (veja o /etc/inetd.conf).  Esse
		serviço costumava ser executado com userid do
		<username>root</username>.  Hoje em dia o processo
		roda com o userid do <username>tty</username>.  O
		usuário <username>tty</username>, portanto,
		é uma sandbox criada para dificultar qualquer
		atividade de um usuário malicioso que por
		ventura consiga acesso ao sistema por meio do ntalk.
		Com essa sandbox, uma violação de
		segurança bem sucedida via
		<literal>ntalk</literal> dificultaria qualquer
		ação tomada além das
		possíveis com o userid do
		<username>tty</username>.</para>
	    </listitem>

	    <listitem>
	      <para>Um processo criado dentro de um ambiente de
		simulação.  Essa é uma
		situação mais complexa.  Basicamente
		implica que qualquer pessoa má intencionada que
		consiga explorar tal processo, acreditará que
		pode obter acesso à todo o ambiente, nas na
		verdade, estará apenas acessando um sistema de
		simulação, não alterando nenhum
		dado real.</para>

	      <para>A forma mais comum de conseguir criar um ambiente
		simulado como esse, é criando um
		subdiretório à partir de onde o processo
		consiga acessar (uma cópia de) qualquer arquivo
		do sistema que por ventura ele precise, e executar
		esse processo simulando um diretório raiz (ou
		seja, para o processo, o <filename>/</filename>
		será o subdiretório determinado, e
		não o verdadeiro <filename>/</filename> do
		sistema).</para>

	      <para>Outra situação comum é montar
		um sistema de arquivos base com apenas
		permissão de leitura, e depois criar um outro
		sistema de arquivos em uma camada superior, com acesso
		de escrita/leitura, dando ao processo a
		impressão de poder ler/escrever em todo o
		sistema de arquivos.  Apenas o processo em
		questão percebe esse ambiente, enquanto os
		outros não são necessariamente
		ludibriados.</para>

	      <para>A intenção é que tais sandbox
		sejam tão transparentes que qualquer
		usuário (ou hacker) não consiga perceber
		que está dentro de uma.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Os sistemas Unix costumam implementar esses dois
	    principais tipos de sandbox, um em nível de
	    processo e o outro, muito comum, em nível de
	    userid.</para>

	  <para>Cada processo Unix é completamente separado dos
	    outros, por meio de algum tipo de parede de
	    segurança.  Um processo nunca modifica o
	    espaço de endereçamento de outro, diferente
	    do ambiente Windows onde cada processo pode facilmente
	    sobrescrever endereços de outros processos, fazendo
	    o sistema travar.</para>

	  <para>Cada processo Unix é de propriedade de um
	    userid em particular.  Caso o userid não seja do
	    <username>root</username>, ele serve de parede de
	    segurança em relação aos processos
	    pertencentes a outros usuários.  Os userid
	    também são usados para proteger dados
	    armazenados em disco.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="securelevel">
	  <para>O que é <literal>securelevel</literal>
	    (nível de segurança do sistema)?</para>
	</question>

	<answer>
	  <para><literal>securelevel</literal> (nível de
	    segurança do sistema) é um mecanismo de
	    segurança implementado no
	    <foreignphrase>kernel</foreignphrase> do FreeBSD.
	    Basicamente, quando o <literal>securelevel</literal>
	    é positivo, o <foreignphrase>kernel</foreignphrase>
	    restringe algumas tarefas do sistema;  nem mesmo o
	    superusuário (por exemplo, o
	    <username>root</username>) tem permissão de
	    realizar tais tarefas.  Na data que este
	    <literal>FAQ</literal> foi escrito, o mecanismo de
	    <literal>securelevel</literal> do FreeBSD era capaz de,
	    entre outras coisas, limitar as habilidades de:</para>

	  <itemizedlist>
	    <listitem>
	      <para>retirar algumas flags de arquivos, como a
		<literal>schg</literal> (flag de imutabilidade do
		sistema),</para>
	    </listitem>

	    <listitem>
	      <para>escrever na memória do
		<foreignphrase>kernel</foreignphrase> por meio do
		<devicename>/dev/mem</devicename> e
		<devicename>/dev/kmem</devicename>,</para>
	    </listitem>

	    <listitem>
	      <para>carregar módulos do
		<foreignphrase>kernel</foreignphrase>, e</para>
	    </listitem>

	    <listitem>
	      <para>alterar regras de Firewall do
		&man.ipfirewall.4;.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Para verificar o estado do
	    <literal>securelevel</literal> (nível de
	    segurança do sistema) em um sistema em funcionando,
	    simplesmente execute o seguinte comando:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>A saída apresentará o nome da
	    variável do &man.sysctl.8; (nesse caso,
	    <varname>kern.securelevel</varname>) e um número.
	    Esse último será o valor atual do
	    nível de segurança do
	    <foreignphrase>kernel</foreignphrase> do FreeBSD.  Caso
	    esse valor seja positivo (maior que 0), ao menos algumas
	    das características dos níveis de
	    segurança estarão habilitadas.</para>

	  <para>Os níveis de segurança não podem
	    ser diminuídos em um sistema que está
	    funcionando se isso fosse possível o
	    <literal>securelevel</literal> (nível de
	    segurança do sistema) perderia sua funcionalidade.
	    Caso seja necessário executar alguma tarefa que
	    necessite que o nível de segurança seja
	    não-positivo (por exemplo, um
	    <maketarget>installworld</maketarget> ou alterar a data do
	    sistema) será preciso alterar as
	    definições de <literal>securelevel</literal>
	    (nível de segurança do sistema) no
	    <filename>/etc/rc.conf</filename> (mais precisamente, as
	    variáveis <varname>kern_securelevel</varname> e
	    <varname>kern_securelevel_enable</varname>) e reiniciar o
	    sistema.</para>

	  <para>Para obter mais informações quanto aos
	    níveis de segurança e sobre as
	    funções específicas de cada
	    nível, por gentileza, consulte a página de
	    manual do &man.init.8;.</para>

	  <warning>
	    <para>O <literal>securelevel</literal> (nível de
	      segurança do sistema) não é uma
	      bala de prata;  ele tem várias deficiências
	      óbvias.  A mais frequênte é provocar
	      uma falsa sensação de
	      segurança.</para>

	    <para>Um dos maiores problemas, e portanto que deve ser
	      bem observada pelo administrador do sistema, é
	      que, para que o <literal>securelevel</literal>
	      (nível de segurança do sistema) se torne
	      efetivo, todos os arquivos usados pelo processo de
	      inicialização até que os
	      níveis de segurança se tornem positivos,
	      devem estar seguros.  Se um usuário que deseja
	      atacar o sistema, conseguir que seu código seja
	      executado antes que o nível de segurança
	      seja definido (o que ocorre pouco depois do processo de
	      inicialização, visto que algumas
	      funções que o sistema precisa realizar,
	      não podem ser iniciadas com um nível
	      elevado de segurança), a proteção
	      do <literal>securelevel</literal> (nível de
	      segurança do sistema) será invalidada.
	      Por outro lado, a tarefa de assegurar que todos os
	      arquivos necessários pelo processo de
	      inicialização estejam em conformidade,
	      não é tecnicamente impossível, mas,
	      O processo de manutenção de um ambiente em
	      tais condições se tornaria um pesadelo,
	      visto que seria necessário baixar o sistema, no
	      mínimo para modo monousuário sempre que
	      fosse necessário modificar os arquivos de
	      configuração do mesmo.</para>

	    <para>Esse e outros pontos são freq&uuml;entemente
	      discutidos nas listas do FreeBSD, em especial na
	      freebsd-security.  Por gentileza, queira fazer uma busca
	      no histórico da lista, <ulink
		url="../../../../search/index.html">clicando
		aqui</ulink>, para uma discussão extensa sobre
	      o assunto.  Algumas pessoas estão
	      esperançosas de que o securelevel logo
	      será afastado, em favor de um mecanismo de
	      segurança mais refinado, mas as coisas ainda
	      estão confusas a este respeito.</para>

	    <para>Considere-se advertido.</para>
	  </warning>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="release-candidate">
	  <para>Tentei atualizar meu sistema para o último
	    -STABLE, mas ele se tornou -RC ou -PRERELEASE!  O que
	    está havendo?</para>
	</question>

	<answer>
	  <para>A resposta mais curta: É só um nome, RC
	    é um acrônimo para <quote>Release
	      Candidate</quote>.  Significa que uma nova versão
	    está eminente.  No FreeBSD, -PRERELEASE é
	    tipicamente um sinonimo de código congelado antes
	    de uma nova versão.  (Em algumas versões, o
	    título -BETA foi usado sob as mesmas
	    circunstâncias em que o -PRERELEASE seria).</para>

	  <para>A resposta longa: O FreeBSD normalmente deriva suas
	    versões de duas fontes de origem.  As
	    versões principais, ponto-zero, como o 3.0-RELEASE
	    e o 4.0-RELEASE que são marcadas inicialmente como
	    o topo da cadeia de desenvolvimento, normalmente chamados
	    de <link linkend="current">-CURRENT</link>.  As
	    versões menores (como 3.1-RELEASE ou 4.2-RELEASE),
	    são criados a partir do
	    <foreignphrase>snapshot</foreignphrase> mais recente da
	    ramificação ativa marcada como <link
	      linkend="stable">-STABLE</link>.  A partir do
	    4.3-RELEASE, cada versão conta também com
	    sua própria ramificação, que pode ser
	    acessada por usuários que queiram apenas um
	    nível extremamente conservador de desenvolvimento
	    (tipicamente, apenas consultores de
	    segurança).</para>

	  <para>Quando uma versão está para ser criada,
	    a ramificação de onde ela se derivará
	    deve passar por um certo processo.  Parte desse processo
	    é o congelamento do código.  Quando o
	    processo de congelamento do código se inicia, o
	    nome desta ramificação é alterado
	    para indicar que ela está para se tornar uma
	    versão.  Por exemplo, se a
	    ramificação usada chamava-se 4.5-STABLE, ela
	    passa a se chamar 4.6-PRERELEASE para indicar que o
	    código está congelado, e indicar que testes
	    extras, pré versão, estão
	    acontecendo.  Durante esse período
	    alterações pertinentes a
	    correções de problemas são
	    realizadas.  Quando o novo código está
	    pronto para ser lançado, ele passa a ser chamado de
	    -RC (nesse exemplo, 4.6-RC), indicando que provavelmente a
	    nova versão será criada a partir do
	    código atual.  Nesse estágio, apenas os
	    problemas mais sérios são corrigidos.
	    Depois que a versão é finalmente
	    lançado (4.6-RELEASE nesse exemplo) e a nova
	    ramificação com o nome dessa versão
	    foi criada, ela passa a se chamar -STABLE;  4.6-STABLE no
	    nosso exemplo.</para>

	  <para>Para obter mais informações sobre a
	    numeração das versões e sobre as
	    várias ramificações CVS, por
	    gentileza, refira-se ao artigo sobre a <ulink
	      url="../../articles/releng/article.html">Engenharia de
	      Releases</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="kernel-chflag-failure">
	  <para>Tentei instalar um novo
	    <foreignphrase>kernel</foreignphrase>, mas a rotina de
	    chflags falhou.  O que posso fazer?</para>
	</question>

	<answer>
	  <para>A resposta curta: provavelmente você está
	    com o <literal>securelevel</literal> (nível de
	    segurança do sistema) acima do 0.  Reinicie o
	    sistema em modo mono usuário e instale o
	    <foreignphrase>kernel</foreignphrase>.</para>

	  <para>A resposta mais completa: O FreeBSD não permite
	    que as flags do sistema sejam alteradas caso o
	    <literal>securelevel</literal> (nível de
	    segurança do sistema) seja maior que 0.  O
	    nível atual do <literal>securelevel</literal>
	    (nível de segurança do sistema) pode ser
	    verificado com o comando:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>O <literal>securelevel</literal> (nível de
	    segurança do sistema) não pode ser
	    diminuído; é necessário iniciar o
	    sistema em modo mono usuário, ou alterar o
	    nível de segurança em
	    <filename>/etc/rc.conf</filename>, depois reiniciar.  Veja
	    a página de manual do &man.init.8; para obter
	    informações mais detalhadas sobre o
	    <literal>securelevel</literal> (nível de
	    segurança do sistema), e veja também o
	    <filename>/etc/defaults/rc.conf</filename> e a
	    página de manual do &man.rc.conf.5; para obter mais
	    informações quanto ao rc.conf.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="kernel-securelevel-time">
	  <para>Não consigo alterar mais de um segundo na hora
	    no meu sistema.  O que posso fazer?</para>
	</question>

	<answer>
	  <para>A resposta curta: provavelmente o sistema está
	    com <literal>securelevel</literal> (nível de
	    segurança do sistema) acima do 1.  Reinicie o
	    sistema em modo mono usuário e altere a
	    data.</para>

	  <para>A resposta mais completa: O FreeBSD não permite
	    que a hora do sistema seja alterada por mais de um segundo
	    quando o <literal>securelevel</literal> (nível de
	    segurança do sistema) do
	    <foreignphrase>kernel</foreignphrase> é maior que
	    1.  O nível atual do <literal>securelevel</literal>
	    (nível de segurança do sistema) pode ser
	    verificado com o comando:</para>

	  <screen>&prompt.root; <userinput>sysctl kern.securelevel</userinput></screen>

	  <para>O <literal>securelevel</literal> (nível de
	    segurança do sistema) não pode ser
	    diminuído; é necessário iniciar o
	    sistema em modo mono usuário, ou alterar o
	    nível de segurança em
	    <filename>/etc/rc.conf</filename>, depois reiniciar.  Veja
	    a página de manual do &man.init.8; para obter
	    informações mais detalhadas sobre o
	    <literal>securelevel</literal> (nível de
	    segurança do sistema), e veja também o
	    <filename>/etc/defaults/rc.conf</filename> e a
	    página de manual do &man.rc.conf.5; para obter mais
	    informações quanto ao rc.conf.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="statd-mem-leak">
	  <para>Por que motivo o <command>rpc.statd</command>
	    está usando 256 megabytes de memória?</para>
	</question>

	<answer>
	  <para>Não, mão existe nenhuma falha no uso da
	    memória, e ele nã é usando 256MB de
	    RAM.  Ele simplesmente gosta de (ele sempre faz isso)
	    mapear uma quantia obscena de memória em seu
	    endereçamento, simplesmente por conveniência.
	    Não existe nada terrivelmente errado com esse
	    comportamento, de um ponto de vista técnico;  a
	    única questão é que assim o
	    &man.top.1; e o &man.ps.1; ficam completamente
	    perdidos.</para>

	  <para>O &man.rpc.statd.8; mapeia seu arquivo de status
	    (localizado sob o <filename>/var</filename>) no seu
	    endereçamento para economiza
	    preocupações sobre esse remapeamento em um
	    segundo momento, quando o arquivo precisa crescer.  O
	    mapeamento é feito a um valor enorme.  Analisando o
	    código fonte, podemos evidenciar que o tamanho do
	    argumento do &man.mmap.2; é
	    <literal>0x10000000</literal>, ou exatos 256MB em sistemas
	    de arquitetura IA32.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="unsetting-schg">
	  <para>Por que eu não posso retirar a flag
	    <literal>schg</literal> dos arquivos?</para>
	</question>

	<answer>
	  <para>O sistema está sendo executado em um
	    nível de segurança elevado (maior que 0).
	    Diminua o nível de segurança e tente
	    novamente.  Para obter mais informações, por
	    gentileza, refira-se à seção sobre
	    <link linkend="securelevel"><literal>securelevel</literal>
	      (nível de segurança do sistema)</link> do
	    <literal>FAQ</literal>, e à página de manual
	    do &man.init.8;</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ssh-shosts">
	  <para>Por que a autenticação do SSH via
	    <filename>.shosts</filename> não funciona por
	    padrão nas versões recentes do
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O motivo é simples.  A
	    autenticação via
	    <filename>.shosts</filename> não funciona mais por
	    padrão porque o &man.ssh.1; não está
	    instalado com suid de root por padrão.
	    Razões óbvias de segurança.  Para
	    <quote>corrigir</quote> isto, pode-se fazer o
	    seguinte:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Para uma alteração permanente,
		defina <makevar>ENABLE_SUID_SSH</makevar> como
		<literal>true</literal> no arquivo
		<filename>/etc/make.conf</filename> e recompile o ssh
		(ou execute um make world).</para>
	    </listitem>

	    <listitem>
	      <para>Uma correção temporária pode
		ser mudar os modos de permissão do&nbsp;
		<filename>/usr/bin/ssh</filename> para
		<literal>4555</literal> simplesmente executando o
		comando <command>chmod 4555 /usr/bin/ssh</command>
		logado como <username>root</username>.  Depois, defina
		<makevar>ENABLE_SUID_SSH= true</makevar> no
		<filename>/etc/make.conf</filename> para que as
		alterações tenham efeito todas as vezes
		que um make world for feito.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="vnlru">
	  <para>O que é o <literal>vnlru</literal>?</para>
	</question>

	<answer>
	  <para>O <literal>vnlru</literal> limpa e libera os vnodes
	    quando o sistema atinge o limite do
	    <varname>kern.maxvnodes</varname>.  Essa thread do
	    <foreignphrase>kernel</foreignphrase> se mantém
	    inativa a maior parte do tempo, e só se inicia caso
	    exista uma grande quantidade de memória RAM, e o
	    sistema esteja acessando dezenas de milhares de arquivos
	    pequenos.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="x">
    <title>O sistema X, sistema de interface gráfica e os
      Consoles Virtuais</title>

    <qandaset>
      <qandaentry>
	<question id="running-X">
	  <para>Quero rodar a interface gráfica X, como
	    procedo?</para>
	</question>

	<answer>
	  <para>A maneira mais fácil é simplesmente
	    especificar o desejo de usar o X durante o processo de
	    instalação do FreeBSD.</para>

	  <para>Depois disso, leia e siga as instruções
	    documentadas na ferramenta <command>xf86config</command>,
	    que auxilia o usuário a configurar o XFree86 para
	    os diversos monitores, placas de vídeo, mouse e
	    etc, suportados pelo X, sistema de interface
	    gráfica.</para>

	  <para>Também pode ser interessante dar uma olhada no
	    servidor Xaccel.  Confira a seção do
	    <literal>FAQ</literal> pertinente à <link
	      linkend="xig">Xi Graphics</link> ou <link
	      linkend="metrox">Metro Link</link> para obter mais
	    detalhes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="running-X-securelevels">
	  <para><emphasis>Tentei</emphasis> rodar o X, mas o erro
	    <errorname>KDENABIO failed (Operation not
	      permitted)</errorname> sempre aparece, quando eu digito
	    o comando <command>startx</command>.  O que posso
	    fazer?</para>
	</question>

	<answer>
	  <para>Seu sistema está rodando com um
	    <literal>securelevel</literal> (nível de
	    segurança do sistema) elevado, não
	    está? É impossível iniciar o X com um
	    secureleve elevado.  Para saber exatamente os motivos
	    dessa inviabilidade, por gentileza, de uma olhada na
	    página de manual do &man.init.8;.</para>

	  <para>Então, a pergunta pode ser sobre o que
	    você deve fazer nesse caso; basicamente, existem
	    duas escolhas: diminua seu <literal>securelevel</literal>
	    (nível de segurança do sistema), colocando-o
	    de volta para zero (normalente via
	    <filename>/etc/rc.conf</filename>), ou então inicie
	    o &man.xdm.1; durante o processo de
	    inicialização do sistema (antes que o
	    <literal>securelevel</literal> (nível de
	    segurança do sistema) seja elevado).</para>

	  <para>Veja a pergunta <xref linkend="xdm-boot"/>, para obter
	    mais informações sobre como iniciar o
	    &man.xdm.1; durante o boot.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="x-and-moused">
	  <para>Por que meu mouse não funciona com o X?</para>
	</question>

	<answer>
	  <para>Caso esteja usando o syscons (o driver padrão
	    do console), o FreeBSD pode ser configurado para suportar
	    um cursor de mouse em cada tela virtual.  Com o
	    intúito de evitar conflitos com o X, o syscons
	    suporta um dispositivo virtual, chamado
	    <devicename>/dev/sysmouse</devicename>.  Todos os eventos
	    relacionados ao mouse, que o sistema recebe, são
	    antes enviados para o device sysmouse, por meio do moused.
	    Se a intenção é usar o mouse em um ou
	    mais consoles virtuais, e também usar o X, leia
	    <xref linkend="moused" remap="another section"/> e
	    configure o moused.</para>

	  <para>Depois, edite o <filename>/etc/XF86Config</filename> e
	    garanta que existam as seguintes linhas no arquivo:</para>

          <programlisting>Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
.....</programlisting>

	  <para>O exemplo acima refere-se ao XFree86 3.3.2 e
	    posteriores.  Para versões anteriores, a
	    cláusula <emphasis>Protocol</emphasis> deve ser
	    substituída por
	    <emphasis>MouseSystems</emphasis>.</para>

	  <para>Alguns preferem usar a device
	    <devicename>/dev/mouse</devicename> sob o X.  Para que
	    isso funcione, faça um link de
	    <devicename>/dev/mouse</devicename> para
	    <devicename>/dev/sysmouse</devicename> (veja a
	    página de manual do &man.sysmouse.4;).</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>rm -f mouse</userinput>
&prompt.root; <userinput>ln -s sysmouse mouse</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="x-and-wheel">
	  <para>Meu mouse possui aquela bolinha (esfera)
	    simpática de scroll.  Posso usa-lo no X?</para>
	</question>

	<answer>
	  <para>Pode, mas é necessário customizar os
	    programas do X.  Veja a página do Colas Nahaboo
	    sobre o assunto (<ulink
	      url="http://www.inria.fr/koala/colas/mouse-wheel-scroll/">
	      http://www.inria.fr/koala/colas/mouse-wheel-scroll/</ulink>.</para>

	  <para>Caso queira usar o programa
	    <application>imwheel</application>, simplesmente siga os
	    seguintes passos:</para>

	  <orderedlist>
	    <listitem>
	      <para>Traduza os eventos da esfera de scroll:</para>
	      <para>O programa <application>imwheel</application>
		funciona assim: ele traduz os botões 4 e 5 do
		mouse em eventos do teclado do computador.  Dessa
		forma é necessário assegurar que o
		driver do mouse esteja traduzindo os eventos da esfera
		de scroll para os eventos dos botões 4 e 5, ou
		seja assimilar suas funções.  Existem
		duas formas de fazer isso, a primeira é usando
		o &man.moused.8; para fazer essas
		assimilações, e a segunda, é usar
		o próprio X para traduzir os eventos.</para>

	      <orderedlist>
		<listitem>
		  <para>Usando o &man.moused.8; para traduzir os
		    eventos da bolinha de scroll.</para>

		  <para>Para que o &man.moused.8; faça as
		    assimilações de eventos, basta
		    adicionar as opções <option>-z
		      4</option> nas opções de linhas de
		    comando, usadas para iniciar o &man.moused.8;.
		    Por exemplo, se normalmente você inicia o
		    &man.moused.8; via <command>moused -p
		      /dev/psm0</command> basta substituir o comando
		    por <command>moused -p /dev/psm0 -z 4</command>.
		    Se o &man.moused.8; é executado
		    automaticamente durante o processo de
		    inicialização do FreeBSD, por meio
		    das entradas definidas no
		    <filename>/etc/rc.conf</filename>, basta adicionar
		    <option>-z 4</option> na variável
		    <varname>moused_flags</varname> do
		    <filename>/etc/rc.conf</filename>.</para>

		  <para>Você precisa agora dizer para o X que
		    você tem o botão 5 no mouse.  Para
		    fazer isto, simplesmente adicione a linha
		    <literal>Buttons 5</literal> para a
		    seção <quote>Pointer</quote> do
		    <filename>/etc/XF86Config</filename>.  Por
		    exemplo, você pode seguir a
		    seção <quote>Pointer</quote> em
		    <filename>/etc/XF86Config</filename>.</para>

		  <example>
		    <title>Seção <quote>Pointer</quote>
		      no XF86Config para o mouse com bolinha de
		      scroll, da série 3.3.x do XFree86, usando
		      a tradução se;rie 3.3.x do
		      XFree86, usando a tradução por
		      meio do moused</title>

		    <programlisting>Section "Pointer"
Protocol        "SysMouse"
Device          "/dev/sysmouse"
Buttons         5
EndSection</programlisting>
		  </example>

		  <example>
		    <title>Seção
		      <quote>InputDevice</quote> do XF86Config para
		      usar a tradução do X Server na
		      série 4.X do XFree86.</title>

		    <programlisting>Section "InputDevice"
Identifier      "Mouse1"
Driver          "mouse"
Option          "Protocol" "auto"
Option          "Device" "/dev/sysmouse"
Option          "Buttons" "5"
EndSection</programlisting>
		  </example>

		  <example>
		    <title>Exemplo de <quote>.emacs</quote> para usar
		      paginamento em mouse com bolinha de
		      scroll.</title>

		    <programlisting>;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</programlisting>
		  </example>
		</listitem>

		<listitem>
		  <para>Usando o X Server para traduzir os eventos da
		    esfera de scroll.</para>

		  <para>Se você não usa o &man.moused.8;
		    ou simplesmente não quer que ele
		    faça a tradução de eventos,
		    é possível que o servidor X
		    faça o trabalho, no lugar do
		    &man.moused.8;.  Essa ação requer
		    algumas alterações no seu arquivo
		    <filename>/etc/XF86Config</filename>.  Primeiro,
		    é necessário definir o protocolo
		    apropriado para o mouse.  A maioria dos mouses com
		    esferas de scroll usam o protocolo
		    <quote>IntelliMouse</quote>.  De qualquer forma, o
		    XFree86 não suporta outros protocolos como
		    o <quote>MouseManPlusPS/2</quote> dos MouseMan+
		    Logitechfor.  Uma vez definido o protocolo,
		    é necessário criar uma entrada
		    apropriada na seção
		    <quote>Pointer</quote>.</para>

		  <para>Depois, é preciso definir que o
		    servidor X deve remapear os eventos 4 e 5 do
		    mouse.  A opção
		    <varname>ZAxisMapping</varname> é usada
		    para essa finalidade.</para>

		  <para>Por exemplo, caso não estejas usando o
		    &man.moused.8; e exista um IntelliMouse ligado na
		    PS/2 do seu computador, use o seguinte, no
		    <filename>/etc/XF86Config</filename>.</para>

		  <example>
		    <title>Seção <quote>Pointer</quote>
		      do <filename>XF86Config</filename> com um mouse
		      com scroll na série 3.3.x do
		      XFree86.</title>

		    <programlisting>Section "Pointer"
Protocol        "IntelliMouse"
Device          "/dev/psm0"
ZAxisMapping    4 5
EndSection</programlisting>
		  </example>

		  <example>
		    <title>Seção
		      <quote>InputDevice</quote> do
		      <filename>XF86Config</filename> com um mouse com
		      scroll na série 4.x do XFree86.</title>

		    <programlisting>Section "InputDevice"
Identifier      "Mouse1"
Driver          "mouse"
Option          "Protocol" "auto"
Option          "Device" "/dev/psm0"
Option          "ZAxisMapping" "4 5"
EndSection</programlisting>
		  </example>

		  <example>
		    <title>Arquivo <quote>.emacs</quote> para usar
		      paginamento em mouse com bolinha de
		      scroll.</title>

		    <programlisting>;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)</programlisting>
		  </example>
		</listitem>
	      </orderedlist>
	    </listitem>

	    <listitem>
	      <para>Instale o
		<application>imwheel</application></para>

	      <para>Depois, instale o
		<application>imwheel</application> à partir da
		coleção de <literal>ports</literal> do
		FreeBSD; ele pode ser encontrado sob a categoria
		<filename>x11</filename>.  A finalidade desse programa
		é assimilar os eventos dos botões 4 e 5
		do mouse, com os eventos de alguma tecla do teclado.
		Por exemplo, o programa deve enviar o evento da tecla
		<keycap>Page Up</keycap> quando a esfera for deslocada
		para frente.  O <application>imwheel</application> usa
		um arquivo de configurações para
		assimilar esses eventos à uma tecla, de forma
		que possam ser configuradas ações
		diferentes (teclas diferentes) para
		aplicações diferentes.  O arquivo de
		configuração padrão do
		<application>imwheel</application> é instalado
		em <filename>/usr/X11R6/etc/imwheelrc</filename>.  Ele
		pode ser copiado para
		<filename>~/.imwheelrc</filename> e editado, caso se
		deseja customizar o arquivo de
		configuração.  O formato esperado para o
		arquivo é documentado na página de
		manual do &man.imwheel.1;.</para>
	    </listitem>

	    <listitem>
	      <para>Configure o <application>Emacs</application> para
		trabalhar em conjunto com o
		<application>Imwheel</application>
		(<emphasis>optional</emphasis>)</para>

	      <para>Se você usa o
		<application>emacs</application> ou o
		<application>Xemacs</application>, será
		necessário adicionar uma breve
		seção ao arquivo
		<filename>~/.emacs</filename>.  No
		<application>emacs</application>, adicione o
		seguinte:</para>

	      <example>
		<title>Configuração do
		  <application>Emacs</application> para
		  <application>Imwheel</application></title>

		<programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</programlisting>
	      </example>

	      <para>Pro <application>Xemacs</application>, adicione o
		seguinte, no seu arquivo
		<filename>~/.emacs</filename>:</para>

	      <example>
		<title>Configuração do
		  <application>Xemacs</application> para
		  <application>Imwheel</application></title>

		<programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section</programlisting>
	      </example>
	    </listitem>

	    <listitem>
	      <para>Execute o
		<application>Imwheel</application></para>

	      <para>Basta digitar <command>imwheel</command> em algum
		terminal X (xterm) para inicia-lo, uma vez que tudo
		esteja pronto.  Imediatamente o programa vai estar
		efetivo e vai se tornar um processo em segundo plano.
		Caso queira sempre iniciar o
		<application>imwheel</application>, basta adicionar o
		comando no seu arquivo <filename>.xinitrc</filename>
		ou no <filename>.xsession</filename>.  É
		possível que o
		<application>imwheel</application> mostre algumas
		mensagens de advertência sobre arquivos PID;
		elas podem ser seguramente ignoradas, visto que
		são mensagens que se aplicam à
		versão para Linux.</para>
	    </listitem>
	  </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="window-menu-weird">
	  <para>Por quê os menus e caixas de diálogo do
	    X, sistema de interface gráfica não
	    funcionam direito?</para>
	</question>

	<answer>
	  <para>Tente desativar a tecla <keycap>Num
	      Lock</keycap>.</para>

	  <para>Se por padrão seu <keycap>Num Lock</keycap>
	    é ativo na hora do processo de
	    inicialização, adicione a seguinte linha a
	    seção <literal>Keyboard</literal> do seu
	    arquivo <filename>XF86Config</filename>.</para>

	  <programlisting># Deixar o servidor fazer o trabalho do NumLock.  Deve ser usado apenas em versoes anteriores a R6
    ServerNumLock</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="virtual-console">
	  <para>O que é um console virtual, e como eu crio mais
	    consoles?</para>
	</question>

	<answer>
	  <para>Consoles virtuais simplesmente permitem que se tenha
	    várias sessões simultâneas em uma
	    mesma máquina, sem a necessidade de fazer nada
	    complicado como configurar uma rede ou usar um servidor
	    X.</para>

	  <para>Quando o sistema é iniciado, a primeira
	    ação é apresentar um prompt de login
	    na tela do usuário, tão logo todas as
	    mensagens do processo de inicialização sejam
	    apresentadas.  Nesse momento é possível
	    entrar com seu nome de usuário e senha para
	    começar trabalhar (ou brincar!) no primeiro console
	    virtual.</para>

	  <para>Em algum momento, é provável que se
	    deseje iniciar uma outra sessão, talvez para ler a
	    documentação de alguma
	    aplicação que está sendo usada, ou
	    para ler e-mail enquanto a transferência FTP se
	    conclúi, enfim, qualquer ação
	    (a)típica de um sistema multitarefa.  Nesse caso,
	    basta pressionar <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	    (segure a tecla <keycap>Alt</keycap> e depois aperte a
	    tecla <keycap>F2</keycap>), e outro prompt de login
	    estará esperando você no segundo
	    <quote>console virtual</quote>!  Quando quizer alternar de
	    volta à sessão original, digite <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F1</keycap></keycombo>.</para>

	  <para>A instalação padrão do FreeBSD
	    oferece três consoles virtuais já habilitados
	    (8 a partir do 3.3-RELEASE), e as teclas <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,

	    <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,
	    e <keycombo
	      action="simul"><keycap>Alt</keycap><keycap>F3</keycap></keycombo>
	    irá alternar entre esses consoles.</para>

	  <para>Para habilitar mais consoles, edite o
	    <filename>/etc/ttys</filename> (veja a página de
	    manual do &man.ttys.5;) e adicione as entradas da
	    <devicename>ttyv4</devicename> à
	    <devicename>ttyvc</devicename> depois do comentário
	    sobre <quote>Virtual terminals</quote>:</para>

	  <programlisting># Edite as entradas existentes para ttyv3 e mude de "off" para "on"
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</programlisting>

	  <para>Use quantos consoles desejar.  Quanto mais, maior o
	    uso de recursos; essa é uma
	    consideração relevante quando se tem 8MB de
	    RAM ou menos.  Também pode ser interessante mudar o
	    terminal de <literal>secure</literal> para
	    <literal>insecure</literal>.</para>

	  <important>
	    <para>Caso se deseje usar um servidor X, é
	      necessário garantir que exista ao menos um
	      terminal virtual fora de uso (ou desligado).  Com isso,
	      entenda que, se sua inteção for usar
	      consoles virtuais nas suas doze teclas de
	      funções, nada feito; apenas onze
	      poderão ser usadas caso deseje-se usar o X na
	      mesma máquina.</para>
	  </important>

	  <para>A maneira mais simples de desabilitar um console,
	    é desligando-o.  Por exemplo, caso existam 12
	    terminais definidos, como mencionado na
	    situação acima, e se queira usar o servidor
	    X, o mais interessante é mudar as
	    configurações do terminal 12 de:</para>

	  <programlisting>ttyvb   "/usr/libexec/getty Pc"        cons25  on  secure</programlisting>

	  <para>para:</para>

	  <programlisting>ttyvb   "/usr/libexec/getty Pc"        cons25  off  secure</programlisting>

	  <para>Caso seu teclado tenha apenas dez teclas de
	    funções, basta encerrar as
	    definições com:</para>

<programlisting>ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>

	  <para>(Claro que as linhas poderiam simplesmente ser
	    apagadas.)</para>

	  <para>Uma vez editado o <filename>/etc/ttys</filename>, o
	    passo seguinte é garantir que existam devices o
	    bastante pros terminais virtuais.  A forma mais
	    fácil de fazer isso é:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vty12</userinput></screen>

	  <para>Em seguida, a maneira mais fácil (e mais limpa)
	    de ativar cada um dos consoles virtuais é reiniciar
	    o sistema.  Mas se reiniciar o FreeBSD não é
	    a intenção, basta desligar o servidor X,
	    sistema de interface gráfica e executar (logado
	    como <username>root</username>):</para>

	  <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	  <para>É obrigatório tirar por completo o X,
	    sistema de interface gráfica do ar antes de dar
	    esse comando, caso o X esteja sendo usado.  Se isso
	    não for feito, o sistema vai parecer que
	    travou.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="vty-from-x">
	  <para>Como posso acessar os consoles virtuais quando eu
	    estiver no X?</para>
	</question>

	<answer>
	  <para>Use <keycombo action="simul">
	      <keycap>Ctrl</keycap>
	      <keycap>Alt</keycap>
	      <keycap>F<replaceable>n</replaceable></keycap>
	    </keycombo> para alternar de volta para algum console
	    virtual.  Por exemplo,
	    <keycombo action="simul">
	      <keycap>Ctrl</keycap>
	      <keycap>Alt</keycap>
	      <keycap>F1</keycap>
	    </keycombo> retornaria ao primeiro console virtual.</para>

	  <para>Uma vez de volta ao console textual, pode-se usar
	    <keycombo action="simul">
	      <keycap>Alt</keycap>
	      <keycap>F<replaceable>n</replaceable></keycap>
	    </keycombo> normalmente, para alternar entre os consoles
	    virtuais.</para>

	  <para>Pra voltar para sessão X basta alternar para o
	    console virtual onde o X está sendo executado.
	    Caso o X tenha sido iniciado por linha de comando (por
	    exemplo, com o comando <command>startx</command>) a
	    sessão terá sido assimilada ao
	    próximo console virtual fora de uso, e não
	    ao console onde o comando foi digitado.  Caso existam oito
	    terminais virtuais ativos, o X estará sendo
	    executado no nono.  Nesse caso as teclas
	    <keycombo action="simul">
	      <keycap>Alt</keycap>
	      <keycap>F9</keycap>
	    </keycombo> retornarão ao sistema
	    gráfico.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="xdm-boot">
	  <para>Como eu inicio o XDM no processo de
	    inicialização?</para>
	</question><answer>

	  <para>Existem duas formas clássicas de iniciar o
	    <ulink
	      url="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">xdm</ulink>.
	    A primeira consiste em inciá-lo a partir do
	    <filename>/etc/ttys</filename> (veja a página de
	    manual do &man.ttys.5;) usando o exemplo disponível
	    no arquivo; a segunda forma é simplesmente executar
	    o xdm a partir do <filename>rc.local</filename> (veja a
	    página de manual do &man.rc.8;) ou então por
	    um script <filename>X.sh</filename> em
	    <filename>/usr/local/etc/rc.d</filename>.  As duas
	    maneiras são igualmente válidas, mas algumas
	    podem ser mais eficientes em algumas
	    situações, onde a outra forma não
	    seria ideal.  Nos dois casos, o resultado será o
	    mesmo: o X iniciará o mostrando uma tela de login:
	    gráfica.</para>

	  <para>O método de inicialização via
	    ttys oferece a vantagem de definir explicitamente em qual
	    vtyX o servidor gráfico vai ser carregado, passando
	    a responsabilidade da reinicialização do X
	    para o init, no momento do logout.  O método via
	    rc.local oferece facilidades caso seja necessário
	    encerrar o processo xdm, no caso, por exemplo, de
	    ocorrerem problemas ao carregar o servidor
	    gráfico.</para>

	  <para>Ao usar o rc.local para carregar o
	    <command>xdm</command>, ele não deve ser
	    acompanhado de nenhum argumento (deve ser iniciado como um
	    daemon e deve ser iniciado DEPOIS que o getty já
	    estiver em execussão, senão é
	    provável que ocorram conflitos entre ambos, podendo
	    travar o console.  A melhor forma de assegurar o correto
	    funcionamento desse método é fazer com que o
	    script espere 10 segundos (por exemplo, com um sleep 10;)
	    antes de iniciar o xdm.</para>

	  <para>Se a inteção é iniciar o
	    <command>xdm</command> a partir do
	    <filename>/etc/ttys</filename>, ainda existe a
	    probabilidade de conflitos entre o <command>xdm</command>
	    e o &man.getty.8;.  Uma forma interessante de evitar esse
	    tipo de desconforto, é definir, no arquivo
	    <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename>, o
	    número do <literal>vt</literal> onde o X deve ser
	    iniciado, da seguinte forma:</para>

	  <programlisting>:0 local /usr/X11R6/bin/X vt4</programlisting>

	  <para>O exemplo acima indica que o servidor X será
	    ativado no <devicename>/dev/ttyv3</devicename>.  Note que
	    existe um offset de um vt, já que o X começa
	    a contar os terminais (vty) a partir do um, enquando o
	    <foreignphrase>kernel</foreignphrase> do FreeBSD os conta
	    a partir do zero.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="xconsole-failure">
	  <para>Por que eu enfrento um <errorname>Couldn't open
	      console</errorname> ao executar o xconsole? </para>
	</question>

	<answer>
	  <para>Se o <application>X</application> for iniciado com um
	    <command>startx</command>, as permissões do
	    <devicename>/dev/console</devicename> não
	    serão redefinidas, resultando em
	    situações onde um <command>xterm
	      -C</command> ou mesmo o <command>xconsole</command>
	    não funcionarão corretamente.</para>

	  <para>O motivo disso é a forma como as
	    permissões são definidas por padrão.
	    Em sistemas multiusuário, normalmente não se
	    espera que qualquer pessoa possa escrever no console do
	    sistema.  Para os usuários que estão se
	    logando diretamente na máquina, em algum VTY,
	    existe o arquivo &man.fbtab.5; que resolve esse tipo de
	    problema.</para>

	  <para>Se for apropriado, garanta que exista uma linha
	    assim</para>

	  <programlisting>/dev/ttyv0 0600 /dev/console</programlisting>

	  <para>No arquivo <filename>/etc/fbtab</filename> (veja a
	    página de manual do &man.fbtab.5;).   Essa linha
	    garantirá que qualquer usuário que se logar
	    no <devicename>/dev/ttyv0</devicename> será
	    também proprietário do console.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="xfree86-root">
	  <para>Antes eu conseguia usar o XFree86 com um
	    usuário sem privilégios.  Porque agora o
	    servidor diz que eu tenho que ser
	    <username>root</username>?</para>
	</question>

	<answer>
	  <para>Todo servidor gráfico precisa ser executado
	    como <username>root</username> para que o sistema permita
	    acesso direto aos equipamentos de vídeo.  Acontece
	    que nas versões mais antigas, o XFree86
	    (versões &lt;= 3.3.6) instalava o servidor de forma
	    que ele era automaticamente executado como
	    <username>root</username> (setuid de
	    <username>root</username>).  Óbviamente esse
	    comportamente implica em riscos de segurança em
	    qualquer caso onde o programa em questão seja
	    complexo e grande; esse é o caso dos servidores X.
	    As versões mais atuais do XFree86 não
	    instalam os servidores gráficos com todo esse
	    poder, exatamente por esse motivo.</para>

	  <para>É claro que rodar o X como usuário
	    <username>root</username> não é uma
	    idéia muito aceitável, especialmente em
	    relação à segurança.  Existem
	    duas formas de usar o X como usuário comum.  A
	    primeira é usar o <command>xdm</command> ou
	    qualquer outro gerenciador de display (como o
	    <command>kdm</command>); a segunda é usar o
	    <command>Xwrapper</command>.</para>

	  <para>O <command>xdm</command> é um daemon que
	    controla logins gráficos.  Normalmente ele é
	    iniciado no processo de inicialização e
	    é responsável pela
	    autenticação dos usuários, e por
	    inciar suas sessões; essencialmente é a
	    união gráfica do &man.getty.8; como o
	    &man.login.1;.  Para mais informações sobre
	    o <command>xdm</command>, por gentileza, refira-se
	    à <ulink
	      url="http://www.xfree86.org/support.html">documentação
	      do XFree86</ulink> e à questão do <link
	      linkend="xdm-boot"><literal>FAQ</literal> sobre
	      xdm</link>.</para>

	  <para>O <command>Xwrapper</command> é um
	    intermediador do servidor gráfico; é um
	    programa bem pequeno que possibilita a
	    inicialização manual do servidor
	    gráfico por qualquer usuário, garantindo
	    razoável segurança à
	    operação.  O programa ainda faz algumas
	    verificações na linha de comando definida
	    pelo usuário, para garantir a sanidade das
	    intenções do mesmo.  Se todas as
	    intenções forem aprovadas, ele executa o X.
	    Se por qualquer razão, a idéia de usar um
	    gerenciador de displays não te agrada, o
	    <command>Xwrapper</command> é feito para
	    você.  Caso a coleção de
	    <literal>Ports</literal> esteja instalada, o programa pode
	    ser encontrado em
	    <filename>/usr/ports/x11/wrapper</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ps2-x">
	  <para>Por que meu mouse PS/2 não se comporta
	    corretamente no X?</para>
	</question>

	<answer>
	  <para>O seu mouse e a device que o controla devem ter
	    desincronizado.</para>

	  <para>Nas versões 2.2.5 e anteriores, a simples
	    alternância entre o X e o terminal, e voltar para o
	    X, força a resincronização do mouse.
	    Se o problema se tornar frequênte, adicione a
	    seguinte opção ao arquivo de
	    configuração do seu
	    <foreignphrase>kernel</foreignphrase>, e o
	    recompile:</para>

	  <programlisting>options PSM_CHECKSYNC</programlisting>

	  <para>Veja a seção sobre a <link
	      linkend="make-kernel">compilação do
	      <foreignphrase>kernel</foreignphrase></link>, caso
	    você não tenha experiência com
	    isso.</para>

	  <para>Com essa opção as chances de ter
	    problemas com a sincronia do mouse são bem
	    pequenas.  Contudo, se ainda assim o problema persistir,
	    clique em qualquer botão durante o movimento do
	    mouse.  É o bastante para resincroniza-lo.</para>

	  <para>Infelizmente essa opção pode não
	    funcionar em alguns sistemas, dependendo de qual driver
	    controle o seu mouse PS/2; especialmente se a device de
	    controle for do tipo ALPS GlidePoint.</para>

	  <para>Na versão 2.2.6 e posteriores, a
	    verificação de sincronia se tornou
	    razoávelmente melhor, e é padrão nos
	    mouses PS/2.  Deve funcionar corretamente com GlidePoint,
	    inclusive (como o código de
	    verificação de sincronia ter se tornado
	    padrão, a opção PSM_CHECKSYNC
	    não existe mais).  Contudo, em
	    situações muito raras, o driver de controle
	    do mouse pode, errôneamente reportar problemas de
	    sincronização, mostrando a seguinte mensagem
	    do <foreignphrase>kernel</foreignphrase>:</para>

	  <programlisting>psmintr: out of sync (xxxx != yyyy)</programlisting>

	  <para>Pensando que seu mouse não está
	    funcionando corretamente.</para>

	  <para>Se for o caso, desligue o código de
	    verificação de sincronia do mouse PS/2,
	    definindo a flag 0x100 na device de controle do mesmo.
	    Entre no modo <emphasis>UserConfig</emphasis> definindo a
	    opção <option>-c</option> na tela do
	    processo de inicialização:</para>

	  <screen>boot: <userinput>-c</userinput></screen>

	  <para>Depois, na linha de comando do
	    <emphasis>UserConfig</emphasis>, digite:</para>

	  <screen>UserConfig&gt; <userinput>flags psm0 0x100</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ps2-mousesystems">
	  <para>Por que meu mouse PS/2 da MouseSystems não
	    funciona?</para>
	</question>

	<answer>
	  <para>Existem notícias que alguns modelos de mouse
	    PS/2 da MouseSystems funcionam corretamente apenas em modo
	    de alta resolução.  Do contrário, o
	    cursor do mouse costuma pular para diagonal superior
	    esquerda da tela com certa frequência.</para>

	  <para>Infelizmente não existe solução
	    à esse problema, nas versões 2.0.X e 2.1.X.
	    Contudo, das versões 2.2 à 2.2.5, basta
	    aplicar o seguinte patch, no
	    <filename>/sys/i386/isa/psm.c</filename> e recompilar o
	    <foreignphrase>kernel</foreignphrase>.  Veja a
	    seção sobre <link linkend="make-kernel">
	      compilação do
	      <foreignphrase>kernel</foreignphrase></link> caso
	    não tenha experiência com o assunto.</para>

	  <programlisting>@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
         log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
             unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);        /* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);                /* stream mode */</programlisting>

	  <para>Na versão 2.2.6 e versões posteriores,
	    basta especificar a flag 0x04 para device de controle do
	    mouse PS/2, colocando-o em modo de alta
	    resolução.  Entre no modo
	    <emphasis>UserConfig</emphasis> com a opçãp
	    <option>-c</option> na tela do processo de
	    inicialização:</para>

	  <screen>boot: <userinput>-c</userinput></screen>

	  <para>Depois, na linha de comando do
	    <emphasis>UserConfig</emphasis> digite:</para>

	  <screen>UserConfig&gt; <userinput>flags psm0 0x04</userinput>
UserConfig&gt; <userinput>quit</userinput></screen>

	  <para>Veja a pergunta anterior, sobre outra causa
	    possível de problemas com o mouse.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="imake-tmpl">
	  <para>Ao compilar uma aplicação X, o
	    <command>imake</command> não consegue encontrar o
	    <filename>Imake.tmpl</filename>.  Onde ele
	    está?</para>
	</question>

	<answer>
	  <para>O <filename>Imake.tmpl</filename> é parte do
	    pacote Imake, uma aplicação padrão
	    para construção de aplicações
	    gráficas.  O <filename>Imake.tmpl</filename>, assim
	    como vários outros arquivos de cabeçalhos
	    necessários para compilar aplicações
	    gráficas, é parte da
	    distribuição do X.  Eles podem ser
	    instalados pelo sysinstall ou manualmente a partir dos
	    arquivos da distribuição.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="xfree86-version">
	  <para>Estou construindo uma aplicação
	    gráfica que depende do XFree86 3.3.X, mas eu estou
	    com o XFree86 4.X instalado.  O que fazer?</para>
	</question>

	<answer>
	  <para>Pra definir que a construção do
	    <literal>Port</literal> deve ser linkada às
	    bibliotecas do XFree86 4.X, adicione o seguinte, no seu
	    <filename>/etc/make.conf</filename>, (se o arquivo
	    não existir, crie-o):</para>

	  <programlisting>XFREE86_VERSION=	4</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mouse-button-reverse">
	  <para>Como posso inverter as funções dos
	    botões do mouse?</para>
	</question>
	<answer>
	  <para>Execute o comando <command>xmodmap -e "pointer = 3 2
	      1"</command> à partir do
	    <filename>.xinitrc</filename> ou do
	    <filename>.xsession</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="install-splash">
	  <para>Como instalar uma Splash Screen e onde posso
	    encontra-las?</para>
	</question>

	<answer>
	  <para>A partir da lançamento do FreeBSD 3.1, uma nova
	    característica foi adicionada ao sistema,
	    permitindo que alguns arquivos de imagens sejam usados
	    como <quote>Splash Screens</quote> durante as mensagens do
	    processo de inicialização.  Tais imagens
	    devem ser arquivos do tipo bitmap com 256 cores
	    (<filename>*.BMP</filename>) ou então ZSoft PCX
	    (<filename>*.PCX</filename>).  Devem ainda ter
	    resolução de 320x200 pixels (ou menos), para
	    funcionarem corretamente em adaptadores de vídeo
	    VGA tradicionais.  Caso o
	    <foreignphrase>kernel</foreignphrase> tenha sido compilado
	    com suporte à VESA, então podem ser usados
	    bitmaps maiores, até 1024.768 px.  O suporte
	    à VESA pode ser diretamente compilado no
	    <foreignphrase>kernel</foreignphrase>, com a
	    opção VESA no arquivo de
	    configuração, ou carregado como
	    módulo, com o kld, durante o processo de
	    inicialização do sistema.</para>

	  <para>Para definir a <quote>Splash Screens</quote>, basta
	    modificar alguns arquivos de inicialização
	    que controlam o processo de inicialização do
	    FreeBSD.  Tais arquivos foram alterados na versão
	    3.2 do FreeBSD, existindo portanto duas formas de carregar
	    uma <quote>Splash Screens</quote>:</para>

	  <itemizedlist>
	    <listitem>
	      <para>No FreeBSD 3.1</para>

	      <para>O primeiro passo é escolher o seu bitmap, e
		sua versão.  Até o FreeBSD 3.1, apenas
		os bitmaps do tipo Windows eram suportados.  Assim que
		escolher (ou criar) sua <quote>Splash Screens</quote>,
		copie-a para <filename>/boot/splash.bmp</filename>.
		Depois, basta editar (ou criar, caso não
		exista) o arquivo <filename>/boot/loader.rc</filename>
		e adicionar as seguintes linhas:</para>

	      <programlisting>load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</programlisting>
	    </listitem>

	    <listitem>
	      <para>No FreeBSD 3.2 e posteriores</para>

	      <para>Além de adicionar suporte a <quote>Splash
		  Screens</quote> de formato PCX, o FreeBSD 3.2 passou
		a oferecer uma maneira mais interessante de configurar
		o processo de inicialização.  Caso
		prefira, o método descrito acima, para o
		FreeBSD 3.1 também funciona.  Nesse caso, se a
		imagem for do tipo PCX basta substituir a entrada
		<literal>splash_bmp</literal> por
		<literal>splash_pcx</literal>.  Caso queira usar a
		nova configuração do processo de
		inicialização, basta criar um arquivo
		<filename>/boot/loader.rc</filename> com o seguinte
		conteúdo:</para>

	      <programlisting>include /boot/loader.4th
start</programlisting>

	      <para>e depois, um
		<filename>/boot/loader.conf</filename> com o
		seguinte:</para>

	      <programlisting>splash_bmp_load="YES"
bitmap_load="YES"</programlisting>

	      <para>Essa configuração assume que o
		<filename>/boot/splash.bmp</filename> deve ser usado
		como sua <quote>Splash Screens</quote>.  Caso prefira
		usar um arquivo PCX, copie para o
		<filename>/boot/splash.pcx</filename>, e crie um
		<filename>/boot/loader.rc</filename>, da forma como
		foi indicado anteriormente; depois crie um
		<filename>/boot/loader.conf</filename> com o
		seguinte:</para>

	      <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</programlisting>
	    </listitem>
	  </itemizedlist>

	  <para>Agora você só precisa de uma imagem, para
	    servir de <quote>Splash Screens</quote>.  Pra isso,
	    dê uma navegada na galeria disponível em
	    <ulink
	      url="http://www.baldwin.cx/splash/">http://www.baldwin.cx/splash/</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="windows-keys">
	  <para>Posso usar as teclas do Windows&reg; que meu teclado
	    possui, sob o X?</para>
	</question>

	<answer>
	  <para>Pode.  Basta usar o &man.xmodmap.1; para redefinir a
	    função das teclas.</para>

	  <para>Assumindo que todos os teclados <quote><trademark
		class="registered">Windows</trademark></quote> sejam
	    padrão, os códigos de mapeamento pras 3
	    teclas são:</para>

	  <itemizedlist>
	    <listitem>
	      <para>115 - <trademark
		  class="registered">Windows</trademark>, entre a
		tecla Ctr e a Alt do lado esquerdo.</para>
	    </listitem>

	    <listitem>
	      <para>116 - <trademark
		  class="registered">Windows</trademark>, à
		direita a tecla AltGr.</para>
	    </listitem>

	    <listitem>
	      <para>117 - <keycap>Menu</keycap>, do lado esquerdo da
		tecla Ctrl esquerda</para>
	    </listitem>
	  </itemizedlist>

	  <para>Por exemplo, para fazer com que a tecla Windows&reg;
	    esquerda imprima uma vírgula, faça o
	    seguinte:</para>

	  <screen>&prompt.root; <userinput>xmodmap -e "keycode 115 = comma"</userinput></screen>

	  <para>É provável que seu gerenciador de
	    janelas tenha que ser reiniciado, para visualizar o
	    resultado.</para>

	  <para>Pra forçar o carregamento automático do
	    mapeamento das teclas <trademark
	      class="registered">Windows</trademark>, coloque os
	    comandos do <command>xmodmap</command> no arquivo
	    <filename>~/.xinitrc</filename> ou de preferência,
	    crie um arquivo <filename>~/.xmodmaprc</filename> e inclua
	    as opções do <command>xmodmap</command> uma
	    por linha, nesse arquivo.  Depois adicione:</para>

	  <programlisting>xmodmap $HOME/.xmodmaprc</programlisting>

	  <para>No seu <filename>~/.xinitrc</filename>.</para>

	  <para>Por exemplo, pode-se mapear as 3 teclas em
	    questão para fazer o papel das teclas
	    <keycap>F13</keycap>, <keycap>F14</keycap>, e
	    <keycap>F15</keycap>, respectivamente.  Dessa forma, seria
	    fácil mapear as aplicações de forma
	    que as teclas tivessem ações no seu sistema,
	    como veremos agora.</para>

	  <para>Adicione o seguinte conteúdo, no arquivo
	    <filename>~/.xmodmaprc</filename>.</para>

	  <programlisting>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</programlisting>

	  <para>Se o gerenciador de janelas em questão for o
	    <command>fvwm2</command>, por exemplo, pode-se mapear as
	    teclas de forma que o <keycap>F13</keycap> minimize (ou
	    maximize) a janela que o cursor está apontando, a
	    tecla <keycap>F14</keycap> de forma que ela traga a janela
	    marcada pelo cursor para frente (ou volte para
	    trás, caso já esteja à frente), e o
	    <keycap>F15</keycap> pode alternar o menu da área
	    detrabalho principal, o que é bem útil
	    quando a tela não é visível.</para>

	  <para>As seguintes definições no
	    <filename>~/.fvwmrc</filename> implementam a
	    configuração acima descrita:</para>

	  <programlisting>Key F13	FTIWS    A	Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
	<question id="x-3d-acceleration">
	  <para>Como posso obter a aceleração de
	    equipamentos 3D para o OpenGL?</para>
	</question>

	<answer>
	  <para>A disponibilidade da aceleração 3D
	    depende da versão do XFree86 e da placa de
	    vídeo.  Caso a placa seja NVIDIA, verifique a
	    página da <ulink
	      url="http://nvidia.netexplorer.org/">Iniciativa de
	      Driver NVIDIA para o FreeBSD</ulink>, que discute a
	    aceleração 3D em chips NVIDIA com XFree86-4.
	    Pra outras placas em conjunto com o XFree86-4, incluindo a
	    Matrox G200/G400, a ATI Rage 128/Radeon, as 3dfx Voodoo 3,
	    4, 5, e Banshee, refira-se à página sobre
	    <ulink
	      url="http://gladstone.uoregon.edu/~eanholt/dri/">Renderização
	      Direta do XFree86-4 no FreeBSD</ulink>.  Usuários
	    do XFree86 na versão 3.3 podem usar o
	    <literal>port</literal> do Utah-GLX que pode ser
	    encontrado em <filename
	      role="package">graphics/utah-glx</filename> para
	    conseguir alguma (limitada) aceleração 3D
	    para o OpenGL em placas Matrox Gx00, ATI Rage Pro, SiS
	    6326, i810, Savage, e algumas NVIDIA antigas.</para>
	  </answer>
	</qandaentry>
    </qandaset>
  </chapter>

  <chapter id="networking">
    <title>Redes</title>

    <qandaset>
      <qandaentry>
	<question id="diskless-booting">
	  <para>Onde obter informações a respeito do
	    processo de processo de inicialização sem
	    disco rígido (<foreignphrase>diskless
	      booting</foreignphrase>)?</para>
	</question>

	<answer>
	  <para>O processo de processo de inicialização
	    sem disco implica na possibilidade de uma máquina
	    FreeBSD ser inicializada através da rede, lendo os
	    arquivos necessários à partir de um
	    servidor, ao invés de um disco rígido.  Para
	    maiores detalhes, por favor, consulte o ítem <ulink
	      url="../handbook/diskless.html"><foreignphrase>diskless
		booting</foreignphrase> no
	      &a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="router">
	  <para>Um sistema FreeBSD pode ser utilizado como roteador
	    dedicado para uma rede?</para>
	</question>

	<answer>
	  <para>Pode.  Por gentileza, refira-se à <ulink
	      url="../handbook/routing.html">documentação
	      do &a.ptbr.p.handbook; sobre configurações
	      avançadas de rede</ulink>, mais especificamente,
	    a seção sobre <ulink
	      url="../handbook/routing.html#DEDICATED-ROUTER">roteamento
	      e gateways</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="win95-connection">
	  <para>Posso conectar minha máquina com Win95 à
	    Internet, através do meu FreeBSD?</para>
	</question>

	<answer>
	  <para>Normalmente, as pessoas que propõem esse tipo
	    de questão possuem dois computadores em casa, um
	    com FreeBSD e outro com Win95.  A idéia é
	    utilizar a maquina com FreeBSD para se conectar à
	    Internet, e então oferecer acesso Internet a
	    máquina Win95 através do FreeBSD.  Essa
	    é apenas uma extensão especial da
	    questão anterior.</para>

	  <para>... e a resposta é sim!  No FreeBSD 3.x, o
	    &man.ppp.8; em modo usuário oferece a
	    opção <option>-nat</option>.  Se o
	    &man.ppp.8; for executado com essa opção,
	    basta definir a variável
	    <literal>gateway_enable</literal> para
	    <emphasis>YES</emphasis> no arquivo
	    <filename>/etc/rc.conf</filename>, e configurar
	    corretamente a máquina Windows.  Isso é o
	    bastante.</para>

	  <para>Para obter mais informações, por
	    gentileza, refira-se a página de manual do
	    &man.ppp.8;</para>

	  <para>Se o &man.ppp.8; estiver sendo usado em modo
	    <foreignphrase>kernel</foreignphrase>
	    (<foreignphrase>kernel-mode</foreignphrase>) ou a
	    conexão com a Internet for via Ethernet, a
	    opção mais viável será
	    utilizar o &man.natd.8;.  Por favor, consulte a
	    seção <link linkend="natd">natd</link> dessa
	    documentação.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="slip-ppp-support">
	  <para>O FreeBSD suporta SLIP e PPP?</para>
	</question>

	<answer>
	  <para>Claro.  Veja as páginas de manual do
	    &man.slattach.8;, &man.sliplogin.8;, &man.ppp.8;, e
	    &man.pppd.8;.  O &man.ppp.8; e o &man.pppd.8; oferecem
	    suporte à conexões entrantes e de
	    saída (conexões incoming/outgoing), enquanto
	    o &man.slattach.8; à conexões de
	    saída (outgoing).</para>

	  <para>Para obter mais informações sobre a
	    correta utilização desses recursos, por
	    gentileza, refira-se ao Capítulo sobre <ulink
	      url="../handbook/ppp-and-slip.html">PPP e SLIP do
	      &a.ptbr.p.handbook;</ulink>.</para>

	  <para>Se o seu acesso à Internet for apenas por meio
	    de uma conta Shell, pode ser interessante dar uma olhada
	    no <literal>port</literal> da aplicação
	    <filename role="package">net/slirp</filename>.  Esse
	    <literal>port</literal> oferece acesso (limitado) à
	    serviços como FTP e HTTP direto da máquina
	    local.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="natd">
	  <para>O FreeBSD suporta NAT ou Masquerading?</para>
	</question>

	<answer>
	  <para>Se no seu caso, existe uma subrede (uma ou mais
	    máquinas locais interconectadas em rede), mas o seu
	    Provedor de Internet disponibiliza apenas um IP (ou se o
	    endereço IP em questão é
	    dinâmico), com certeza é interessante dar uma
	    olhada no &man.natd.8;.  O &man.natd.8; possibilita que
	    uma subrede inteira acesse a Internet através de um
	    único endereço IP.</para>

	  <para>O &man.ppp.8; oferece suporte interno à essa
	    mesma funcionalidade, através da
	    opção <option>-nat</option> do programa.  A
	    biblioteca &man.libalias.3; é usada tanto pelo
	    &man.ppp.8; quanto pelo &man.natd.8;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="parallel-connect">
	  <para>Como posso conectar duas estações
	    FreeBSD por linha paralela, usando o PLIP?</para>
	</question>

	<answer>
	  <para>Por gentileza, refira-se à seção
	    sobre <ulink url="../handbook/plip.html">PLIP do
	      &a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="create-dev-net">
	  <para>Por que eu não posso criar um dispositivo
	    /dev/ed0?</para>
	</question>

	<answer>
	  <para>Porque não é preciso!  Na estrutura de
	    redes de Berkeley, as interfaces de rede são
	    acessadas somente (e diretamente) pelo código do
	    <foreignphrase>kernel</foreignphrase>.  Por favor
	    verifique o arquivo <filename>/etc/rc.network</filename> e
	    as páginas do manual para os diversos programas de
	    rede ali mencionados, para maiores
	    informações.  Se isto deixá-lo
	    completamente confuso, consulte um livro que descreva a
	    administração de rede em um outro sistema
	    operacional baseado no modelo BSD.  Com poucas
	    exceções significativas, a
	    administração de rede em sistemas FreeBSD
	    é basicamente a mesma da utilizada em sistemas como
	    o SunOS 4.0 ou o Ultrix.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ethernet-aliases">
	  <para>Como eu configuro aliases (apelidos) de
	    Ethernet?</para>
	</question>

	<answer>
	  <para>Se a intenção é definir um
	    apelido IP para uma subrede previamente configurada, basta
	    adicionar a máscara <literal>0xffffffff</literal>
	    junto à sintaxe usual para definição
	    de alias no &man.ifconfig.8;:</para>

	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff</userinput></screen>

	  <para>Do contrário, basta definir o endereço
	    de rede e a netmask em questão, da forma
	    tradicional:</para>

	  <screen>&prompt.root; <userinput>ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="port-3c503">
	  <para>Como eu configuro minha placa 3Com 3C503 para utilizar
	    outra interface de conexão ?</para>
	</question>

	<answer>
	  <para>Se você deseja utilizar uma outra interface de
	    conexão, deverá especificar alguns
	    parâmetros adicionais na linha de comando do
	    &man.ifconfig.8;.  A porta padrão é a
	    <literal>link0</literal>.  Para usar a porta AUI ao
	    invés da porta BNC utilize a flag
	    <literal>link2</literal>.  Tais flags devem ser definidas
	    através das variáveis ifconfig_*  no arquivo
	    <filename>/etc/rc.conf</filename>.  (consulte o
	    &man.rc.conf.5;).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="nfs">
	  <para>Por que eu tenho problemas com NFS no FreeBSD?</para>
	</question>

	<answer>
	  <para>Certas interfaces de rede para PC são melhores
	    do que outras (para adotarmos um eufemismo) e as vezes
	    podem causar problemas em aplicações que
	    utilizam a rede de modo intensivo, como o NFS.</para>

	  <para>Consulte o item <ulink
	      url="../handbook/nfs.html">NFS</ulink> do
	    &a.ptbr.p.handbook; para obter mais
	    informações sobre o assunto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="nfs-linux">
	  <para>Por que não é possível montar
	    sistemas de arquivos NFS de máquinas Linux?</para>
	</question>

	<answer>
	  <para>Algumas versões do código NFS do Linux
	    aceitam requisições de montagem provenientes
	    apenas de portas privilegiadas, experimente o
	    comando:</para>

	  <screen>&prompt.root; <userinput>mount -o -P linuxbox:/blah /mnt</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="nfs-sun">
	  <para>Por que não é possível montar
	    sistemas de arquivos NFS de máquinas Sun?</para>
	</question>

	<answer>
	  <para>Estações de trabalho Sun rodando SunOS
	    4.X aceitam requisições de montagem
	    provenientes apenas de portas privilegiadas, experimente o
	    comando:</para>

	  <screen>&prompt.root; <userinput>mount -o -P sunbox:/blah /mnt</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="exports-errors">
	  <para>Por que o <command>mountd</command> informa
	    repetidamente que <errorname>can't change
	      attributes</errorname> e <errorname>bad exports
	      list</errorname> utilizando o servidor de NFS do
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O problema mais freq&uuml;ente é o não
	    entendimento correto do formato do arquivo
	    <filename>/etc/exports</filename>.  Por gentileza, leia
	    com atenção a página de manual do
	    &man.exports.5; e a documentação sobre
	    <ulink url="../handbook/nfs.html">NFS</ulink> no
	    &a.ptbr.p.handbook;, especialmente a seção
	    sobre a <ulink
	      url="../handbook/nfs.html#CONFIGURING-NFS">configuração
	      do NFS</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-nextstep">
	  <para>Por que existem problemas na comunicação
	    (via protocolo PPP) com máquinas NeXTStep?</para>
	</question>
	<answer>
	  <para>Experimente desabilitar a variável TCP
	    extensions no arquivo <filename>/etc/rc.conf</filename>
	    (consulte &man.rc.conf.5;) alterando a variável
	    abaixo para NO:</para>

	  <programlisting>tcp_extensions=NO</programlisting>

	  <para>Máquinas Annex da Xylogic também
	    apresentam um problema similar neste aspecto, e você
	    deve adotar a mesma solução para conectar-se
	    a estes sistemas.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ip-multicast">
	  <para>Como habilitar o suporte a IP multicast?</para>
	</question>

	<answer>
	  <para>Desde o FreeBSD 2.0 que operações
	    Multicast são completamente suportadas por
	    padrão.  Se a itenção é fazer
	    o sistema FreeBSD atuar como um roteador multicast,
	    será necessário que o
	    <foreignphrase>kernel</foreignphrase> do sistema seja
	    recompilado com a opção
	    <literal>MROUTING</literal> e que o &man.mrouted.8; seja
	    executado.  O FreeBSD, à partir da versão
	    2.2, pode iniciar o &man.mrouted.8; durante o processo de
	    inicialização se a variável
	    <literal>mrouted_enable</literal> estiver configurada com
	    o parâmetro <literal>"YES"</literal> no arquivo
	    <filename>/etc/rc.conf</filename>.</para>

	  <para>As ferramentas MBONE estão disponíveis
	    em sua própria categoria na coleção
	    de <literal>ports</literal>, <ulink
	      url="http://www.FreeBSD.org/ports/mbone.html">mbone</ulink>.
	    Se você está procurando as ferramentas de
	    conferência <command>vic</command> e
	    <command>vat</command>, procure neste
	    diretório!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dec-pci-chipset">
	  <para>Quais interfaces de rede são baseadas no
	    chipset DEC PCI?</para>
	</question>

	<answer>
	  <para>Esta é uma lista compilada por Glen Foster
	    <email>gfoster@driver.nsta.org</email>, com algumas
	    adições recentes:</para>

	  <table>
	    <title>Interfaces de rede baseadas no chipset DEC
	      PCI</title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Vendedor</entry>

		  <entry>Modelo</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>ASUS</entry>

		  <entry>PCI-L101-TB</entry>
		</row>

		<row>
		  <entry>Accton</entry>

		  <entry>ENI1203</entry>
		</row>

		<row>
		  <entry>Cogent</entry>

		  <entry>EM960PCI</entry>
		</row>

		<row>
		  <entry>Compex</entry>

		  <entry>ENET32-PCI</entry>
		</row>

		<row>
		  <entry>D-Link</entry>

		  <entry>DE-530</entry>
		</row>

		<row>
		  <entry>Dayna</entry>

		  <entry>DP1203, DP2100</entry>
		</row>

		<row>
		  <entry>DEC</entry>

		  <entry>DE435, DE450</entry>
		</row>

		<row>
		  <entry>Danpex</entry>

		  <entry>EN-9400P3</entry>
		</row>

		<row>
		  <entry>JCIS</entry>

		  <entry>Condor JC1260</entry>
		</row>

		<row>
		  <entry>Linksys</entry>

		  <entry>EtherPCI</entry>
		</row>

		<row>
		  <entry>Mylex</entry>

		  <entry>LNP101</entry>
		</row>

		<row>
		  <entry>SMC</entry>

		  <entry>EtherPower 10/100 (Model 9332)</entry>
		</row>

		<row>
		  <entry>SMC</entry>

		  <entry>EtherPower (Model 8432)</entry>
		</row>

		<row>
		  <entry>TopWare</entry>

		  <entry>TE-3500P</entry>
		</row>

		<row>
		  <entry>Znyx (2.2.x)</entry>

		  <entry>ZX312, ZX314, ZX342, ZX345, ZX346,
		    ZX348</entry>
		</row>

		<row>
		  <entry>Znyx (3.x)</entry>

		  <entry>ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
		    ZX444, ZX474, ZX478, ZX212, ZX214
		    (10mbps/hd)</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="fqdn-hosts">
	  <para>Por que preciso utilizar um FQDN (Nomes de
	    domínio completamente qualificados) pras
	    estações da minha rede?</para>
	</question>

	<answer>
	  <para>Provavelmente você vai estar trabalhando com
	    estações em domínios diferentes.  Por
	    exemplo, se você esta em foo.bar.edu e deseja
	    alcançar uma estação chamada
	    <hostid>mumble</hostid> no domínio <hostid
	      role="domainname">foo.bar.edu</hostid>, deverá
	    referir-se à essa esse host através do seu
	    nome de domínio qualificado, <hostid
	      role="fqdn">mumble.foo.bar.edu</hostid>, ao invés
	    de apenas <hostid>mumble</hostid>.</para>

	  <para>Normalmente era possível alcançar a
	    estação apenas por seu nome.  Essa
	    função era realizada pelos resolvedores BIND
	    do ISC.  Contudo, as versões atuais do
	    <application>BIND</application> (veja o &man.named.8;) que
	    acompanham o FreeBSD não oferecem mais
	    abreviações padrão para
	    domínios que não sejam FQDN, com a
	    única exceção do domínio que
	    sua própria estação faz parte.  Dessa
	    forma, o host <hostid>mumble</hostid>, se não for
	    localizado como <hostid
	      role="fqdn">mumble.foo.bar.edu</hostid>, será
	    localizado através de uma busca direta à
	    partir da raiz dos servidores de
	    resolução.</para>

	  <para>Este comportamento é diferente do verificado
	    anteriormente onde a pesquisa continuaria através
	    de <hostid role="domainname">mumble.bar.edu</hostid> e
	    <hostid role="domainname">mumble.edu</hostid>.  Consulte a
	    RFC 1535 para descobrir porque isso é considerado
	    uma prática ruím, e até mesmo uma
	    brecha de segurança.</para>

	  <para>Uma alternativa é adicionar a linha
	    abaixo:</para>

	  <programlisting>search foo.bar.edu bar.edu</programlisting>

	  <para>ao invés da linha previamente existente</para>

	  <programlisting>domain foo.bar.edu</programlisting>

	  <para>em seu arquivo <filename>/etc/resolv.conf</filename>
	    (consulte &man.resolv.conf.5;).  Contudo verifique se a
	    ordem de pesquisa não vai além da fronteira
	    entre a administração pública e a
	    local, conforme definido na RFC 1535.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="network-permission-denied">
	  <para>Por que obtenho o erro, <errorname>Permission
	      denied</errorname>, para todas as
	    operações de rede?</para>
	</question>

	<answer>
	  <para>Se o <foreignphrase>kernel</foreignphrase> do seu
	    FreeBSD foi compilado com a opção
	    <literal>IPFIREWALL</literal>, você deve compreender
	    que a política padrão, à partir da
	    versão 2.1.7 (atualmente alterada durante o
	    desenvolvimento da versão 2.1-STABLE) é
	    negar todos os pacotes que não forem explicitamente
	    permitidos.</para>

	  <para>A seu firewall foi erroneamente configurado, de forma
	    não intencional, a operacionalidade do sistema pode
	    ser restaurada, simplesmente digitando o seguinte
	    (conectado como <username>root</username>):</para>

	  <screen>&prompt.root; <userinput>ipfw add 65534 allow all from any to any</userinput></screen>

	  <para>A variável
	    <literal>firewall_type="open"</literal> também pode
	    ser definida, no arquivo
	    <filename>/etc/rc.conf</filename>.</para>

	  <para>Para maiores informações sobre a
	    configuração de firewall, por gentileza,
	    consulte a seção correspondente no <ulink
	      url="../handbook/firewalls.html">&a.ptbr.p.handbook;</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ipfw-overhead">
	  <para>Qual o acréscimo de sobrecarga ocasionado pelo
	    IPFW?</para>
	</question>

	<answer>
	  <para>Por gentileza, refira-se ao capítulo sobre
	    <ulink url="../handbook/firewalls.html">Firewalls</ulink>
	    do &a.ptbr.p.handbook; mais específicamente, a
	    seção sobre <ulink
	      url="../handbook/firewalls.html#IPFW-OVERHEAD">Overhead
	      &amp; Otimização do IPFW</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ipfw-fwd">
	  <para>Minha regra de fwd do IPFW, que deveria redirecionar
	    um serviço para outra estação,
	    não está funcionando.  Por que?</para>
	</question>

	<answer>
	  <para>Provavelmente porque a verdadeira
	    intenção é traduzir os pacotes que
	    chegam na sua estação, e rescrevê-los
	    para renviar para a outra máquina, e não
	    simplesmente redirecionar o pacote.  Normalmente o ideal
	    é fazer NAT (tradução de
	    endereços de rede).  Uma regra de reenvio de
	    pacotes, faz exatamente o que ela deve fazer: reenviar
	    pacotes.  As regras não alteram (rescrevem) o
	    conteúdo ou cabeçalhos dos dados presentes
	    no pacote.  Por exemplo, digamos que a questão seja
	    a seguinte regra:</para>

	  <screen>01000 fwd <replaceable>10.0.0.1</replaceable> from any to <replaceable>foo 21</replaceable></screen>

	  <para>Quando um pacote destinado à
	    estação <replaceable>foo</replaceable>
	    chegar no FreeBSD que filtra essa regra, ele será
	    encaminhado para a máquina cujo endereço IP
	    é <replaceable>10.0.0.1</replaceable>, mas o
	    endereço de destino original do pacote será
	    mantido, ou seja, os pacotes chegando em
	    <replaceable>10.0.0.1</replaceable> ainda terão a
	    estação <replaceable>foo</replaceable> como
	    destino final, marcado em seu cabeçalho TCP.  O
	    endereço de destino não é alterado
	    (reescrito) para a máquina
	    <replaceable>10.0.0.1</replaceable>, o que propicia um
	    comportamento de verificação de checksum do
	    cabeçalho IP.  O comportamento normal é que
	    a máquina <replaceable>10.0.0.1</replaceable>
	    descarte o pacote, já que o endereço de
	    destino do mesmo não é o endereço da
	    estação em questão.  Esse
	    comportamento costuma confundir alguns usuários
	    menos experientes, não correspondendo a
	    ação com suas expectativas.  Essa é
	    uma característica do IPFW, e não um
	    problema.</para>

	  <para>Consulte o <literal>FAQ</literal> sobre <link
	      linkend="service-redirect">Redirecionamento de
	      Serviços</link>, a página de manual do
	    &man.natd.8;, ou uma das diversas ferramentas de
	    redirecionamento disponíveis na
	    Coleção de <literal>Ports</literal>, para
	    verificar a forma correta de obter o comportamento
	    desejado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="service-redirect">
	  <para>Como redirecionar requisições de
	    serviço de uma máquina para outra?</para>
	</question>

	<answer>
	  <para>Serviços como FTP (e outros) podem ser
	    redirecionados com o pacote <literal>socket</literal>,
	    disponível na árvore de
	    Coleção do <literal>Ports</literal>, sob a
	    categoria <quote>sysutils</quote>.  Simplesmente substitua
	    a linha de comando do serviço a ser redirecionado
	    para executar a ferramenta <literal>socket</literal>, como
	    no exemplo abaixo:</para>

	  <programlisting>ftp stream tcp nowait nobody /usr/local/bin/socket socket <replaceable>ftp.example.com</replaceable> <replaceable>ftp</replaceable></programlisting>

	  <para>Onde ftp.foo.com e ftp são a máquina
	    (host) e a porta de conexão que será
	    utilizada para o redirecionamento, respectivamente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bandwidth-mgr-tool">
	  <para>Onde obtenho uma ferramenta de gerenciamento de
	    banda?</para>
	</question>

	<answer>
	  <para>Existem três ferramentas de gerenciamento de
	    banda disponíveis para o FreeBSD.  O
	    &man.dummynet.4;, integrada ao FreeBSD (ou mais
	    especificamente ao &man.ipfw.4;);, o <ulink
	      url="http://www.csl.sony.co.jp/person/kjc/programs.html">ALTQ</ulink>,
	    disponível gratuitamente, e o <ulink
	      url="http://www.etinc.com/">Bandwidth Manager da
	      Emerging Technologies</ulink>, um produto
	    comercial.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bpf-not-configured">
	  <para>O que causa o erro <errorname>/dev/bpf0: device not
	      configured</errorname>?</para>
	</question>

	<answer>
	  <para>Você está tentando usar um programa que
	    precisa do Berkeley Packet Filter (veja a página de
	    manual do &man.bpf.4; para obter maiores
	    informações), mas ele não está
	    compilado no <foreignphrase>kernel</foreignphrase>.
	    Adicione a seguinte linha no arquivo de
	    configuração do seu
	    <foreignphrase>kernel</foreignphrase> e
	    recompile-o:</para>

	  <programlisting>pseudo-device bpf        # Berkeley Packet Filter</programlisting>

	  <para>Depois que reiniciar o sistema com o novo
	    <foreignphrase>kernel</foreignphrase>, basta criar a
	    interface do dispositivo, o que pode ser feito ao executar
	    o seguinte comando, no diretório
	    <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>sh MAKEDEV bpf0</userinput></screen>

	  <para>Por gentileza, refira-se à seção
	    sobre <ulink
	      url="../handbook/kernelconfig-nodes.html">Criação
	      de interface de Dispositivos</ulink> do
	    &a.ptbr.p.handbook;, para obter mais
	    informações sobre o assunto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="mount-smb-share">
	  <para>Como montar o disco de uma estação
	    Windows na minha rede, de forma semelhante ao smbmount em
	    sistemas Linux?</para>
	</question>

	<answer>
	  <para>Use o conjunto de ferramentas
	    <application>SMBFS</application>.  Se trata de um conjunto
	    de modificações no
	    <foreignphrase>kernel</foreignphrase>, e uma série
	    de aplicações específicas.  O
	    programa e outras informações podem ser
	    obtidos na Coleção de
	    <literal>Ports</literal> do FreeBSD, em <filename
	      role="package">net/smbfs</filename>, ou no sistema base
	    do FreeBSD a partir da versão 4.5-RELEASE.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="icmp-response-bw-limit">
	  <para>O que são as mensagens sobre
	    <quote>icmp-response bandwidth limit 300/200 pps</quote>
	    em meus registros de logs?</para>
	</question>

	<answer>
	  <para>É o resultado de seu
	    <foreignphrase>kernel</foreignphrase> informando-o que
	    alguma atividade esta provocando o envio de um
	    número de respostas ICMP ou TCP reset (RST)
	    superior ao número que o
	    <foreignphrase>kernel</foreignphrase> julga adequado.
	    Respostas ICMP são, geralmente, comportamento
	    ocasionado pela tentativa de conexão em portas UDP
	    não utilizadas.  As respostas TCP reset são
	    o resultado gerado pelas tentativas de conexão em
	    portas TCP não poníveis.  Entre outras
	    causas, algumas das atividades que podem ocasionar esse
	    tipo de mensage, são:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Ataques de negação de serviço
		(DoS) por força bruta (em
		oposição a ataques baseados em um
		único pacote que visa explorar uma
		vulnerabilidade específica).</para>
	    </listitem>

	    <listitem>
	      <para>Varreduras de porta (<foreignphrase>port
		  scans</foreignphrase>) que visam rastrear um elevado
		número de portas (em oposição a
		ataques que tentam varrer apenas um pequeno
		número de portas conhecidas).</para>
	    </listitem>
	  </itemizedlist>

	  <para>O primeiro número (valor) na mensagem indica
	    quantos pacotes foram enviados pelo
	    <foreignphrase>kernel</foreignphrase> antes do limite
	    passar a vigorar e o segundo valor indica o limite
	    estabelecido no <foreignphrase>kernel</foreignphrase>.
	    Você pode controlar este limite através da
	    variável <varname>net.inet.icmp.icmplim</varname>
	    do sysctl com instruções como esta abaixo,
	    onde estabelecemos um limite de 300 pacotes por
	    segundo:</para>

	  <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim=300</userinput></screen>

	  <para>Se a intenção é não
	    registrar essas mensagens nos arquivos de registros, mas
	    ainda assim manter a capacidade do
	    <foreignphrase>kernel</foreignphrase> limitar as
	    respostas, a variável
	    <varname>net.inet.icmp.icmplim_output</varname> do sysctl
	    pode ser usada para desabilitar o registro:</para>

	  <screen>&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim_output=0</userinput></screen>

	  <para>Finalmente se a inteção é
	    desabilitar esse comportamento por completo, basta definir
	    a variável <varname>net.inet.icmp.icmplim</varname>
	    do sysctl (conforme o exemplo acima) como 0.  Desabilitar
	    o recurso de limite de resposta é desencorajado
	    pelas razões acima expostas.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="unknown-hw-addr-format">
	  <para>Do que se trata estas mensagens de erro
	    <errorname>arp: unknown hardware address
	      format</errorname>?</para>
	</question>

	<answer>
	  <para>Significa que alguma interface de rede no mesmo
	    barramento Ethernet que você, está usando um
	    endereço de MAC cujo formato não é
	    reconhecido pelo FreeBSD.  Provavelmente isso deve estar
	    sendo causado por algum outro usuário, fazendo
	    experiências com placas Ethernet em algum lugar na
	    sua mesma rede.  Em redes com Cable Modens esse
	    comportamento é ainda mais comum; não
	    é prejudicial e não atrapalha a performance
	    do seu FreeBSD.</para>
	</answer>
      </qandaentry>

     <qandaentry>
      <question id="cvsup-missing-libs">
	<para>Acabei de instalar o CVSup, mas ao tentar usá-lo,
	    aparecem erros.  O que está havendo?</para>
      </question>

      <answer>
	<para>Primeiro, verifique se as mensagens de erro em
	    questão são como essas:</para>

	  <programlisting>/usr/libexec/ld-elf.so.1: Shared object "libXaw.so.6" not found</programlisting>

	<para>Esse tipo de erro se deve à
	    instalação do <literal>port</literal>
	    <filename role="package">net/cvsup</filename> em
	    estações sem o XFree86.  Se a
	    inteção é usar a interface
	    gráfica oferecida pelo
	    <application>CVSup</application>, então instale o
	    <application>XFree86</application> imediatamente.  Do
	    contrário, se a intenção é
	    usar o <application>CVSup</application> apenas por linha
	    de comando, basta desinstalar a aplicação
	    anterior e instalar o <literal>port</literal> <filename
	      role="package">net/cvsup-without-gui</filename>.  A
	    seção sobre <ulink
	      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvsup.html">CVSup</ulink>
	    do &a.ptbr.p.handbook; cobre essas questões de
	    forma mais detalhada.</para>
      </answer>
     </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="security">
    <title>Segurança</title>
    <qandaset>
      <qandaentry>
	<question id="extra-named-port">
	  <para>O BIND (<command>named</command>) está
	    escutando na porta 53 e em outras portas elevadas.  O que
	    está havendo?</para>
	</question>

	<answer>
	  <para>O FreeBSD, a partir da versão 3.0, utiliza
	    portas não privilegiadas e elevadas,
	    aleatoriamente, para responder à
	    requisições de DNS.  Se a
	    intenção é usar a porta 53 para
	    responder a estas requisições, para adequar
	    o comportamento do BIND à um
	    <foreignphrase>firewall</foreignphrase> ou apenas para
	    sentir-se melhor, experimente acrescentar a
	    instruçõo abaixo no arquivo
	    <filename>/etc/namedb/named.conf</filename>:</para>

	  <programlisting>options {
            query-source address * port 53;
            };</programlisting>

	  <para>O <literal>*</literal> deve ser substituído por
	    um endereço IP único, caso se deseje
	    restringir ainda mais este comportamento.</para>

	  <para>De qualquer forma, parabéns.  É uma
	    pratica saudável verificar registros não
	    usuais no conteúdo de saída do
	    &man.sockstat.1; </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sendmail-port-587">
	  <para>O Sendmail está ouvindo na porta 587
	    além da tradicional porta 25!  O que está
	    havendo?</para>
	</question>

	<answer>
	  <para>As versões mais novas do Sendmail tem suporte
	    à uma característica que se chama
	    <foreignphrase>Mail Submission</foreignphrase>, que ouve
	    na porta 587.  Esse serviço não é
	    completamente suportado ainda, mas sua popularidade vem
	    crescendo.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="toor-account">
	  <para>O que é a conta do usuário
	    <username>toor</username> que tem UID 0?  Meu sistema foi
	    comprometido?</para>
	</question>

	<answer>
	  <para>Não se preocupe.  O usuário
	    <username>toor</username> é uma conta
	    <quote>alternativa</quote> com poderes de super
	    usuário (toor é root escrito ao
	    contrário).  Normalmente esse usuário era
	    criado quando o interpretador de comandos &man.bash.1; era
	    instalado, mas agora o usuário existe por
	    padrão no sistema.  A intenção
	    é que o usuário seja usado com um
	    interpretador de comandos fora do padrão, de forma
	    que o ambiente de linha de comando do usuário
	    <username>root</username> não tenha que ser
	    alterada.  Essa é uma situação
	    importante quando nos referimos à interpretadores
	    de comandos que não fazem parte da base do sistema
	    operacional (por exemplo, que foram instaladas do
	    <literal>Ports</literal> ou como pacotes, já que
	    normalmente, elas são instaladas sob o
	    <filename>/usr/local/bin</filename> que por padrão
	    está em um sistema de arquivos diferente da raiz do
	    sistema.  Em uma situação onde o
	    interpretador de comandos do usuário estiver sob
	    <filename>/usr/local/bin</filename> ou sob
	    <filename>/usr</filename> (ou onde quer que seja) e esse
	    sistema de arquivos não puder ser montado por
	    alguma razão, o usuário
	    <username>root</username> estará impossibilitado de
	    se logar no sistema para corrigir o problema (contudo, ao
	    entrar em modo mono tarefa, o sistema pede o caminho
	    completo para algum interpretador de comandos.
	  </para>

	  <para>Alguns administradores costumam usar o
	    <username>toor</username> para tarefas do dia-a-dia, com
	    um interpretador de comandos
	    (<foreignphrase>shell</foreignphrase>) não comum, e
	    deixando o <username>root</username> com seu interpretador
	    de comandos (<foreignphrase>shell</foreignphrase>)
	    padrão para realizar tarefas de emergência ou
	    de modo mono usuário.  Por padrão, o
	    usuário <username>toor</username> não pode
	    ser usado, já que ele não tem uma senha
	    definida.  Para habilitar a conta, logue-se como
	    <username>root</username> no sistema e defina uma senha
	    para o <username>toor</username>.
	  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="suidperl">
	  <para>Por que o <command>suidperl</command> não
	    está funcionando corretamente?</para>
	</question>

	<answer>
	  <para>Por motivos de segurança, a
	    instalação padrão do
	    <command>suidperl</command> não tem o bit suid
	    definido.  Os administradores de sistemas podem reaver o
	    comportamento esperado com o seguinte comando:</para>

	  <screen>&prompt.root; <userinput>chmod u+s /usr/bin/suidperl</userinput></screen>

	  <para>Se a intenção é que o
	    <command>suidperl</command> seja compilado com suid
	    durante as atualizações do sistema, edite o
	    <filename>/etc/make.conf</filename> e adicione a linha
	    <varname>ENABLE_SUIDPERL=true</varname> no arquivo, antes
	    de começar um <command>make
	      buildworld</command>.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="ppp">
    <title>PPP</title>

    <qandaset>
      <qandaentry>
	<question id="userppp">
	  <para>Não consigo fazer meu &man.ppp.8; funcionar.  O
	    que estou fazendo de errado?</para>
	</question>

	<answer>
	  <para>Deve-se primeiro ler a man page do &man.ppp.8; e <ulink
	      url="../handbook/ppp-and-slip.html#USERPPP">
	      seção PPP do &a.ptbr.p.handbook;</ulink>.
	    Habilite os logs com o comando</para>

	  <programlisting>set log Phase Chat Connect Carrier lcp ipcp ccp command</programlisting>

	  <para>Este comando pode ser digitado no prompt do &man.ppp.8;
	    ou pode ser colocado no
	    <filename>/etc/ppp/ppp.conf</filename> (A
	    seção <literal>default</literal> no
	    início do arquivo é o melhor lugar para
	    colocar isso).  Tenha certeza de que
	    seu<filename>/etc/syslog.conf</filename> (veja
	    &man.syslog.conf.5;) tenha as linhas</para>

	  <programlisting>!ppp *.*/var/log/ppp.log</programlisting>

	  <para>e que o arquivo <filename>/var/log/ppp.log</filename>
	    exista.  Agora pode-se ver o que está acontecendo
	    analisando seu arquivo de log.  Não se preocupe se
	    isso não faz sentido mas se precisar de ajuda, esta
	    informação fará sentido a
	    eles.</para>

	  <para>Se a sua versão do &man.ppp.8; não
	    suporta o comando set log ,deve-se fazer o download da
	    <ulink url="http://people.FreeBSD.org/~brian/">
	      versão mais recente</ulink>.  O FreeBSD 2.1.5 (e
	    posteriores) suporta a compilação do
	    código mais recente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-hangs">
	  <para>Por que o &man.ppp.8; fica pendurado quando eu o
	    inicializo?</para>
	</question>

	<answer>
	  <para>Isso normalmente acontece porque seu hostname
	    não esta sendo resolvido.  A melhor maneira de
	    corrigir isso é certificar-se de que o
	    <filename>/etc/hosts</filename> está sendo
	    consultado pelo resolvedor; editando primeiro o
	    <filename>/etc/host.conf</filename> e colocando
	    <literal>hosts</literal> na primeira linha.  Para isso,
	    simplesmente adicione no <filename>/etc/hosts/</filename>
	    uma entrada para sua máquina local.  Se não
	    tem nenhuma rede local, mude a linha do
	    <hostid>localhost</hostid>:</para>

	  <programlisting>127.0.0.1        foo.example.com foo localhost</programlisting>

	  <para>Senão, adicione uma outra entrada para seu
	    host.  Consulte as man pages relevantes para maiores
	    detalhes.</para>

	  <para>Ao terminar, deve ser possível dar um
	    <command>ping -c1 `nomedohost`</command> com sucesso.
		</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-nodial-auto">
	  <para>Porque o &man.ppp.8; não disca em
	    modo<literal>-auto</literal>
	  </para>
	</question>

	<answer>
	  <para>Primeiro verifique se há uma rota
	    padrão.  Ao executar um <command>netstat
	      -rn</command> (veja &man.netstat.1;), devem aparecer duas
	    entradas como essas:</para>

	  <programlisting>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</programlisting>

	  <para>Assume-se o uso do endereço recomendado pelo
	    &a.ptbr.p.handbook;, páginas de manual ou no
	    arquivo ppp.conf.sample.  Se a rota padrão
	    não foi definida, &eacute possível que a
	    versão do &man.ppp.8; seja antiga, uma vez que
	    não entendem a palavra <literal>HISADDR</literal>
	    no arquivo ppp.conf.  Se a versão do seu FreeBSD
	    for anterior a  2.2.5, mude a linha</para>

	  <programlisting>add 0 0 HISADDR</programlisting>

	  <para>para</para>

	  <programlisting>add 0 0 10.0.0.2</programlisting>

	  <para>Outra razão para a rota padrão estar
	    ausente, pode ser porquê você equivocadamente
	    definiu uma rota default em seu arquivo
	    <filename>/etc/rc.conf</filename> (veja &man.rc.conf.5;)
	    (este arquivo era chamado
	    <filename>/etc/sysconfig</filename> nas versões
	    anteriores a 2.2.2) e omitiu a linha</para>

	  <programlisting>delete ALL</programlisting>

	  <para>no <filename>ppp.conf</filename>.  Se este for o
	    problema, volte para <ulink
	      url="../handbook/ppp-and-slip.html#USERPPP-FINAL">
	      seção de configurações
	      Finais do &a.ptbr.p.handbook;.</ulink></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="no-route-to-host">
	  <para>O que <errorname>No route to host</errorname>
	    significa?</para>
	</question>

	<answer>
	  <para>Este erro é causado pela falta das linhas</para>

	  <programlisting>MYADDR:
  delete ALL
  add 0 0 HISADDR</programlisting>

	  <para>no seu arquivo
	    <filename>/etc/ppp/ppp.linkup</filename>.  Isso somente
	    é necessário se você tem um IP
	    dinâmico ou não sabe o endereço do seu
	    gateway.  Se você esta usando o modo interativo,
	    pode-se digitar o seguinte, depois de ter entrado no
	    <literal>modo packet</literal> (O modo packet é
	    indicado pelo <acronym>PPP</acronym> maiísculo no
	    prompt):
	  </para>

	  <programlisting>delete ALL
add 0 0 HISADDR</programlisting>

	  <para>Consulte a <ulink
	      url="../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP">
	      seção PPP e Endereços IPs
	      dinâmicos</ulink> do &a.ptbr.p.handbook; para
	    maiores detalhes
	  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="connection-threeminutedrop">
	  <para>Porque minha conexão cai depois de (em média)
	    3 minutos?</para>
	</question>

	<answer>
	  <para>O default timeout do PPP é de 3 minutos.  Isso pode
	    ser ajustado com a linha</para>

	  <programlisting>set timeout <replaceable>NNN</replaceable></programlisting>

	  <para>Onde NNN é o número em
	    segundos de inatividade antes da conexão ser
	    fechada.  Se <replaceable>NNN</replaceable> é zero a conexão
	    nunca será fechada devido a um timeout.  É
	    possível colocar esse comando no
	    <filename>ppp.conf</filename> ou digitá-lo no modo
	    interativo.  Também é
	    possível que isso seja ajustado enquanto sua
	    conexão esta ativa conectando
	    pelo socket do servidor <application>ppp</application> usando
	    &man.telnet.1; ou &man.pppctl.8;.  Consulte a man
	    page do &man.ppp.8; para maiores detalhes.
	  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-drop-heavy-load">
	  <para>Por que minha conexão cai quando está
	    sobrecarregada?</para>
	</question>

	<answer>
	  <para>Se você tem o relatório da qualidade da
	    ligação (opção LPR)
	    configurado é possível que muitos pacotes
	    LQR entre sua máquina e a origem estejam sendo
	    perdidos.  O ppp deduz que sua linha deve ser ruim e
	    desconecta.  Antes da versão 2.2.5 do FreeBSD, o
	    LQR era habilitado por default.  Agora ele é
	    desabilitado por default.  O LQR pode ser desabilitado com
	    a linha</para>

	  <programlisting>disable lqr</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-drop-random">
	  <para>Por que minha conexão cai após um
	    período aleatório de tempo?</para>
	</question>

	<answer>
	  <para>Às vezes, em uma linha telefônica com
	    ruídos, ou quando a linha tem espera de
	    ligações,  seu modem pode desligar, pensando
	    (incorretamente) que perdeu o sinal de linha.</para>

	  <para>Existem ajustes em grande parte dos modems
	    determinando o quão tolerante ele deve ser a
	    respeito de perdas de sinal de linha.  No USR Sportster,
	    por exemplo, isso é medido  pelo registrador S10 em
	    décimos de segundo.  Para fazer com que seu modem
	    não caia, poderia-se adicionar a seguinte string
	    dial up para envio/espera:</para>

	  <programlisting>set dial "...... ATS10=10OK......"
	   </programlisting>

	  <para>Consulte o manual do seu modem para detalhes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-hangs-random">
	  <para>Por que minha conexão fica pendurada depois de
	    um período aleatório de tempo?</para>
	</question><answer>

	  <para>Muitas pessoas experimentam conexões presas sem
	    aparentemente nenhuma explicação.</para>

	  <para>Se você usa um modem externo, você
	    simplesmente pode tentar um &man.ping.8; para ver se a luz
	    <acronym>TD</acronym> fica piscando quando você
	    transmite dados.  Se piscar (e a luz do
	    <acronym>RD</acronym> não), o problema é com
	    a extremidade remota.  Se o <acronym>TD</acronym>
	    não piscar, o problema é local.  Com um
	    modem interno você precisará usar o comando
	    <literal>set server</literal> no seu arquivo ppp.conf.
	    Quando ocorrer de cair, conecte com o &man.ppp.8; usando o
	    &man.pppctl.8;.  Se a conexão de sua rede voltar de
	    repente (o ppp voltou devido a atividade no
	    diagnóstico do socket) ou se você não
	    consegue conectar (assumindo que o comando <literal>set
	      socket</literal> foi iniciado com sucesso) o problema
	    é local.  Se você puder conectar e ainda as
	    coisas estiverem "penduradas" habilite os logs do async
	    local com o comando <literal>set log local async</literal>
	    e use o &man.ping.8; de outra janela ou terminal para
	    forçar a atividade da conexão.  Os logs
	    async irão mostrar os dados que estão sendo
	    transmitidos e recebidos durante a ligação.
	    Se os dados estão indo e não estão
	    voltando, o problema é remoto.</para>

	  <para>Tendo estabelecido que o problema é local ou
	    remoto, você tem agora duas possibilidades:</para>

	   <itemizedlist>
	    <listitem>
	      <para>Se o problema é remoto, leia a
		secção <xref
		  linkend="ppp-remote-not-responding"/>.</para>
	    </listitem>

	    <listitem>
	      <para>Se o problema for remoto, leia a
		secção <xref linkend="ppp-hung"/>.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-remote-not-responding">
	  <para>A extremidade remota não está
	    respondendo.  O que eu posso fazer?</para>
	</question>

	<answer>
	  <para>Há muito pouco que pode ser feito em
	    relação a isso.  A maioria dos provedores
	    irão recusar ajuda-lo se você não usar
	    o Windows.  Você pode habilitar a
	    <literal>lqr</literal> no seu arquivo
	    <filename>ppp.conf</filename>, permitindo ao &man.ppp.8;
	    detectar a falha remota e desligar-se, mas essa
	    detecção é relativamente lenta e
	    consequentemente inútil.  Pode-se querer evitar
	    dizer ao seu provedor que você está rodando o
	    user-ppp....</para>

	  <para>Primeiro tente desabilitar toda compressão
	    local adicionando o seguinte em sua
	    configuração:</para>

	  <programlisting>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</programlisting>

	  <para>Então reconecte para assegurar de que isso
	    não fez diferença.  Se as coisas melhoraram
	    ou se o problema foi resolvido completamente, determine
	    quais ajustes fizeram a diferença através de
	    tentativas e erros.  Isto fornecerá uma boa cartada
	    quando você contactar seu provedor (embora possa
	    parecer que você não esteja rodando um
	    produto Microsoft).</para>

	  <para>Antes de contactar seu provedor, habilite  o log async
	    localmente e aguarde até que sua conexão
	    caia novamente.  Isto pode usar um bocado de espaço
	    em disco.  A última leitura de dados da porta pode
	    ser de seu interesse.  São geramente dados em
	    ascii, e podem mesmo descrever o problema (<quote>Memory
	      fault, core dumped</quote>?).</para>

	  <para>Se seu provedor for prestativo, ele deve ser capaz de
	    habilitar o log da extremidade da conexão dele,
	    então quando a proxima queda de link ocorrer, eles
	    podem ser capazes de dizer porque o seu lado esta tendo
	    problemas.  Sinta-se livre para enviar os detalhes para
	    &a.brian ou peça para seu provedor
	    contactá-lo diretamente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-hung">
	  <para>O &man.ppp.8; está travado.  O que eu posso
	    fazer?</para>
	</question>

	<answer>
	  <para>A melhor coisa a fazer aqui é recompilar o
	    &man.ppp.8; adicionando <literal>CFLAGS+=-g </literal>e
	    <literal>STRIP=</literal> no final do Makefile, depois
	    faça <command>make clean &amp;&amp; make &amp;&amp;
	      make install</command>.  Quando o &man.ppp.8; ficar
	    travado, procure o id do processo com um <command>ps ajxww
	      | fgrep ppp</command> e execute <command>gdb ppp
	    </command>PID.  No prompt do gdb você pode
	    então usar o <command>bt</command> para obter um
	    rastreamento da pilha.</para>

	  <para>Envie os resultados para:
	    <email>brian@Awfulhak.org</email>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-loginok-thennothing">
	  <para>Por que não acontece nada depois da mensagem
	    <quote>Login OK!</quote>?</para>
	</question>

	<answer>
	  <para>Antes da versão 2.2.5 do FreeBSD, uma vez que a
	    conexão foi estabelecida, o &man.ppp.8; espera que o
	    modem remoto inicie o protocolo do controle de linha
	    (LCP), Muitos provedores não iniciarão a
	    negociação e esperarção que o
	    cliente a faça.  Para forçar o &man.ppp.8;
	    para iniciar o LCP, use a seguinte linha:</para>

	    <programlisting>set openmode active</programlisting>

	  <note>
	    <para>Nota: isto geralmente não prejudica em nada
	      se a negociação for iniciada por ambos os
	      lados, assim, a opção openmode é
	      agora ativada por padrão.  Entretanto, na
	      próxima seção será explicado
	      quando isso realmente <emphasis>proporciona</emphasis>
	      algum problema.</para>
	  </note>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-same-magic">
	  <para>Eu vejo os mesmos erros sobre <literal>magic is the
	      same</literal>.  O que significa?</para>
	</question>

	<answer>
	  <para>Ocasionalmente, depois da conexão, você
	    pode ver mensagens no log dizendo <quote>"magic is the
	      same"</quote>.  Às vezes essas mensagens
	    são sem importância e as vezes um lado ou o
	    outro sai.  A maioria das implementações do
	    ppp não consegue continuar com esse problema, e
	    mesmo se a conexão estiver para ser estabelecida,
	    você verá repetidas requisições
	    de configuração e reconhecimentos de
	    configuração no arquivo de log até
	    que o &man.ppp.8; eventualmente desista e feche a
	    conexão.</para>

	  <para>Isto normalmente acontece em máquinas com
	    discos lentos que estão dando spawning getty na
	    porta e executam o &man.ppp.8; através de um login
	    script ou programa depois do login.  Eu também ouvi
	    relatórios disso estar acontecendo consistentemente
	    ao usar slirp.  A razão é que no tempo entre
	    saída do &man.getty.8; e a
	    inicialização do &man.ppp.8;, o &man.ppp.8; do
	    lado cliente começa a emitir pacotes do protocolo
	    do controle da linha LCP).  Porque o ECHO ainda esta
	    ligado na porta do servidor, o cliente então
	    vê esses pacotes serem <quote>refletidos</quote> de
	    volta.</para>

	  <para>Uma parte da negociação LCP deve
	    estabelecer um número mágico para cada lado
	    da ligação de modo que as
	    <quote>reflexões</quote> possam ser detectadas.  O
	    protocolo diz que quando um ponto tenta negociar o mesmo
	    número mágico, um NAK deve ser emitido e um
	    novo número mágico deve ser escolhido.
	    Durante o período que a porta do server tem o ECHO
	    ligado, o &man.ppp.8; cliente manda pacotes LCP, vê o
	    mesmo número mágico nos pacotes refletidos e
	    manda NAKs a ele.  Ve-se também o NAK que foi
	    refletido (que significa que o &man.ppp.8; deve mudar o seu
	    número mágico).  Isto produz um
	    número potencialmente enorme de mudanças de
	    números mágicos que estão sendo
	    empilhados no buffer do tty do servidor.  Tão logo
	    o &man.ppp.8; se inicia no servidor, ele é inundado
	    com  mudanças de números mágicos
	    imediatamente ao negociar o LCP, e desiste.  Enquanto
	    isso, o cliente não vê por muito tempo as
	    reflexões e fica feliz apenas por algum tempo,
	    até receber a desconexão do servidor.</para>

	  <para>Isto pode ser evitado permitindo que a
	    negociação seja iniciada pelo servidor
	    (peer), adicionando a seguinte linha no seu arquivo
	    ppp.conf:</para>

	  <programlisting>set openmode passive</programlisting>

	  <para>Isso diz ao &man.ppp.8; para esperar que o servidor
	    inicie as negociações LCP.  Alguns
	    servidores, entretanto, podem nunca iniciar as
	    negociações.  Se este for o caso, você
	    deve fazer algo como:</para>

	  <programlisting>set openmode active 3</programlisting>

	  <para>Isto diz ao &man.ppp.8; para ser passivo durante 3
	    segundos, e então começar a enviar
	    requisições LCP.  Se o servidor (peer)
	    começar a enviar requisições durante
	    esse período, o &man.ppp.8; irá responder
	    imediatamente, ao invés de aguardar pelo
	    período completo de 3 segundos.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-lcp-constant">
	  <para>As negociações LCP continuam até
	    que a conexão seja fechada.  O que está
	    errado?</para>
	</question>

	<answer>
	  <para>Há atualmente uma característica
	    faltando no ppp onde ele não associa respostas LCP
	    , CCP &amp; IPCP com suas requisições
	    originais.  Como consequência, se uma
	    implementação ppp é 6 segundos mais
	    lenta do que o outro lado, esse lado emitir&aacute duas
	    requisões adicionais de configuração
	    LCP.  Isto é fatal.</para>

	  <para>Considere duas implementações,
	    <hostid>A</hostid> e <hostid>B</hostid>.
	    <hostid>A</hostid> emite requisições LCP
	    imediatamente após a conexão e
	    <hostid>B</hostid> leva 7 segundos para iniciar.  Quando
	    <hostid>B</hostid> inicia, <hostid>A</hostid> emitiu 3 LCP
	    REQs.  Nós estamos supondo que a linha ECHO esteja
	    desabilitada, senão nós veríamos
	    problemas com número mágico como descritos
	    na seção anterior.  <hostid>B</hostid> emite
	    um REQ, entao um ACK para o primeiro dos REQs de
	    <hostid>A</hostid>.  Isto resulta em <hostid>A</hostid>
	    entrando no estado <acronym>OPENED</acronym> e enviando um
	    ACK (o primeiro) de volta a <hostid>B</hostid>.  Enquanto
	    isso, <hostid>B</hostid> envia de volta mais dois ACKs em
	    resposta aos dois REQs adicionais enviados por
	    <hostid>A</hostid> antes de <hostid>B</hostid> ter
	    iniciado.  <hostid>B</hostid> então recebe o
	    primeiro ACK de <hostid>A</hostid> e também entra
	    no estado de <acronym>OPENED</acronym>.
	    <hostid>A</hostid> recebe o segundo ACK de
	    <hostid>B</hostid> e retorna ao estado de
	    <acronym>REQ-SENT</acronym>, enviando um outro (seguinte)
	    REQ conforme a RFC ordena.  Então, recebe o
	    terceiro ACK e entra no estado OPENED.  Enquanto isso,
	    <hostid>B</hostid> recebe REQ (posterior) de
	    <hostid>A</hostid>, tendo como resultado uma
	    reversão para o estado <acronym>ACK-SENT</acronym>
	    e enviando um outro (segundo) REQ e (depois) ACK conforme
	    a RFC.  Conseguindo o REQ, <hostid>A</hostid> entra em
	    <acronym>REQ-SENT</acronym> e envia outro REQ.
	    Imediatamente recebe o ACK seguinte e entra em
	    <acronym>OPENED</acronym>.</para>

	  <para>Isto continuará até que um dos lados
	    descubra que eles não estão indo a lugar
	    algum e desista.</para>

	  <para>A melhor maneira de evitar isso é configurar um
	    lado para ser <literal>passivo</literal> - isso faz com
	    que um lado espere pelo outro para iniciar uma
	    negociação.  Isto pode ser feito com o
	    comando</para>

	  <programlisting>set openmode passive</programlisting>

	  <para>Deve-se ter cuidado com esta opção.
	    Você também deve usar o comando</para>

	  <programlisting>set stopped N</programlisting>

	  <para>para limitar a quantidade de tempo que o &man.ppp.8;
	    esperará pelo outro lado iniciar a
	    negociação.  Alternativamente o
	    comando</para>

	  <programlisting>set openmode active N</programlisting>

	  <para>(onde <replaceable>N</replaceable> é o
	    número de segundos para esperar antes de iniciar as
	    negociações) pode ser usado.  Consulte as
	    páginas de manual para detalhes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-lockups">
	  <para>Por que o &man.ppp.8; trava logo apó a
	    conexão?</para>
	</question>

	<answer>
	  <para>Antes da versão 2.2.5 do FreeBSD, era
	    possível que sua ligação fosse
	    desabilitada logo após a conexão, devido a
	    incapacidade de negociação da
	    compressão Predictor1 do &man.ppp.8;.  Isto
	    aconteceria somente se ambos os lados tentassem negociar
	    protocolos diferentes do controle da compressão
	    (CCP).  Este problema atualmente esta corrigido, mas se
	    você ainda roda uma versão antiga do
	    &man.ppp.8;, o problema pode ser resolvido com a
	    linha:</para>

	  <programlisting>disable pred1</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-shell-test-lockup">
	  <para>Por que o &man.ppp.8; trava quando executo
	    comandos shell pelo &man.ppp.8;?</para>
	</question>

	<answer>
	  <para>Quando executa-se o <command>shell</command> com o
	    comando <command>!</command> , o &man.ppp.8; executa um
	    shell (ou se você passar quaisquer argumentos, o
	    &man.ppp.8; executará aqueles argumentos).  Ppp
	    aguardará o comando terminar antes de continuar.
	    Se você tentar usar a sua ligaço ppp enquanto
	    é executado o comando, a ligação
	    aparacerá congelada.  Isto porque o ppp
	    estará esperando pelo finalização da
	    comando.</para>

	  <para>Se você desejar executar comandos assim, use o
	    comando <command>!bg</command>.  Ele executará o
	    comando em background e o &man.ppp.8; poderá
	    continuar a servir a conexão normalmente.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-nullmodem">
	  <para>Como uma conexão por &man.ppp.8; usando um nunca
	    termina?</para>
	</question>

	<answer>
	  <para>Não há nenhuma maneira para que o
	    &man.ppp.8; determine automaticamente que uma
	    conexão direta caiu.  Isto é devido
	    às linhas que são usadas na série de
	    cable null modems.  Ao usar esse tipo de conexão o
	    LQR deve sempre ser habilitado com a linha:</para>

	  <programlisting>enable lqr</programlisting>

	  <para>A LQR é aceita por padrão, se negociada
	    com o outro lado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-auto-noreasondial">
	  <para>Por que o &man.ppp.8; disca sem nenhuma razão no
	    modo -auto?</para>
	</question>

	<answer>
	  <para>Se o &man.ppp.8; esta discando inesperadamente,
	    você deve determinar a causa, e setar os filtros de
	    discagem (dfilters) para evitar esse comportamento.</para>

	  <para>Para determinar a causa, use a seguinte linha:</para>

	  <programlisting>set log +tcp/ip</programlisting>

	  <para>Isto registrará todo o tráfego
	    através da conexão.  A próxima vez
	    que a linha acima for ativada, você verá a
	    razão logada.</para>

	  <para>Você pode agora desabilitar a discagem sob estas
	    circunstâncias.  Geralmente, este tipo de problema
	    ocorre devido aos lookups do DNS.  Para evitar que os
	    lookups do DNS estabeleçam uma conexão (isto
	    <emphasis>não</emphasis> impedirá que o
	    &man.ppp.8; passe os pacotes através de uma
	    conexão já estabelecida) use o
	    seguinte:</para>

	  <programlisting>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</programlisting>

	  <para>Nem sempre isso é apropriado, porque irá
	    interromper suas capacidades de discagem por demanda - a
	    maioria dos programas precisarão de lookup do DNS
	    antes de fazer alguma outra coisa relacionada a
	    rede.</para>

	  <para>No caso do DNS, você deve tentar determinar o
	    que esta realmente tentando resolver um hostname.  Na
	    maioria das vezes o &man.sendmail.8; é o culpado.
	    Você deve certificar-se que o sendmail não
	    deve fazer nenhum DNS lookup em seu arquivo de
	    configuração.  Veja na seção
	    <link linkend="ispmail">Configuração de
	      Mail</link> para detalhes de como criar seu
	    próprio arquivo de configuração e o
	    que deve conter nele.  Você pode também
	    adicionar a seguinte linha ao seu arquivo
	    <filename>.mc</filename>:</para>

	  <programlisting>define(`confDELIVERY_MODE', `d')dnl
	  </programlisting>

	  <para>Isto fará o sendmail enfileirar tudo,
	    até que a fila esteja funcionando (normalmente o
	    sendmail é invocado com <option>-bd -q30m</option>,
	    dizendo a ele para rodar a fila (queue) a cada 30minutos)
	    ou até que o <command>sendmail</command> -q seja
	    feito (talvez do arquivo ppp.linkup)</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ccp-errors">
	  <para>O que estes erros de CCP significam?</para>
	</question>

	<answer>
	  <para>Eu estou vendo os seguintes erros em
	    meus logs:</para>

	  <programlisting>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</programlisting>

	  <para>Isto é porque o &man.ppp.8; esta tentando
	    negociar a compressão Predictor1, e o outro ponto
	    não quer negociar nenhuma compressão.  As
	    mensagens são inofensivas, mas se você
	    desejar remove-las, poderá desabilitar a
	    compressão Predictor1 também
	    localmente:</para>

	  <programlisting>disable pred1</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-lockup-ioerrors">
	  <para>Por que o &man.ppp.8; trava durante a
	    transferência de arquivo com erros de
	    IO(Input/Output)?</para>
	</question>

	<answer>
	  <para>No FreeBSD 2.2.2 e anteriores, havia um bug no driver
	    tun, que impedia pacotes de entrada de um tamanho maior do
	    que o MTU da interface.  O O recebimento de pacotes
	    maiores que o MTU da interface resulta em erro de IO que
	    é logado através do syslogd.</para>

	  <para>A especificação do ppp diz que um MTU de
	    1500 deve ser <emphasis>sempre</emphasis> aceito como
	    mínimo.  Apesar de todas as
	    negociações de LCP, é possível
	    diminuir o MTU para menos de 1500, independentemente
	    disso, seu provedor irá transmitir pacotes de 1500
	    para você, e isso travará sua
	    conexão.</para>

	  <para>O problema pode ser contornado por nunca ajustar um
	    MTU menor que 1500 sobre o FreeBSD 2.2.2 ou
	    anteriores.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-connectionspeed">
	  <para>Por que o &man.ppp.8; não loga minha velocidade
	    de conexão?</para>
	</question>

	<answer>
	  <para>A fim de logar todas as linhas de
	    <quote>conversação</quote> de seu modem
	    você deve habilitar o seguinte:</para>

	  <programlisting>set log +connect</programlisting>

	  <para>Isto irá fazer o &man.ppp.8; logar tudo,
	    até a ultima requisição
	    <quote>expect</quote>.</para>

	  <para>Se você desejar ver sua velocidade de
	    conexão e estiver usando PAP ou CHAP (e
	    consequentemente não tenha qualquer coisa para o
	    <quote>chat</quote> depois do CONNECT no script de
	    discagem - no <literal>set login</literal> script),
	    você deve certificar-se que instruiu o &man.ppp.8; a
	    ``a esperar" a linha inteira CONNECT, algo como:</para>

	  <programlisting>set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</programlisting>

	  <para>Aqui nosso CONNECT, não envia nada, ele espera
	    então um line-feed, forçando o &man.ppp.8; a
	    ler toda a resposta do CONNECT.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-ignores-backslash">
	  <para>Por que o &man.ppp.8; ignora o caracter
	    <literal>\</literal> no meu script de
	    conversação?</para>
	</question>

	<answer>
	  <para>O Ppp analiza cada linha no seu arquivo de
	    configuração, então isso pode ser
	    interpretado como string tal como <literal>set phone "123
	      456 789"</literal> corretamente e compreende de fato que
	    o número é um
	    <emphasis>único</emphasis> argumento.  A fim de
	    especificar um caracter<literal>&quot;</literal>,
	    você deve escapar desse comportamento, usando um a
	    barra invertida <literal>\</literal>.</para>

	  <para>Quando o script de conversação analizar
	    cada argumento, ele reinterpretará o argumento a
	    fim de encontrar quaisquer sequências especiais como
	    <literal>\P</literal> ou <literal>\T</literal> (veja a man
	    page).  Como resultado desta dupla análise,
	    você deve conseguir usar o número correto de
	    espaços.</para>

	 <para>Se você deseja enviar um caracter
	    <literal>\</literal> para dizer a seu modem, você
	    precisará de algo assim:</para>

	  <programlisting>set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</programlisting>

	  <para>resultando a seguinte sequência:</para>

	  <programlisting>ATZ
OK
AT\X
OK</programlisting>

	  <para>ou</para>

	  <programlisting>set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"</programlisting>

	  <para>resultando na seguindo sequência:</para>

	  <programlisting>ATZ
OK
ATDT1234567</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-segfault-nocore">
	  <para>Por que o &man.ppp.8; dá um seg-fault, mas eu
	    não vejo nenhum arquivo
	    <filename>ppp.core</filename>?</para>
	</question>

	<answer>
	  <para>O Ppp (ou qualquer programa desta natureza) nunca
	    dever dar core dump.  Porque o &man.ppp.8; roda com um
	    e-userid (effective user id) 0, o sistema operacional
	    não irá escrever a imagem do core do
	    &man.ppp.8; em disco antes de terminá-lo.  Mas se
	    acontecer de o &man.ppp.8; terminar devido a uma falha de
	    segmentação ou algum outro sinal que
	    normalmente causaria um core dumped,
	    <emphasis>e</emphasis> você tem certeza de que esta
	    usando uma versão mais recente do ppp (veja o
	    começo desta seção), você deve
	    fazer o seguinte:</para>

	  <screen>&prompt.user; <userinput>tar xfz ppp-*.src.tar.gz</userinput>
&prompt.user; <userinput>cd ppp*/ppp</userinput>
&prompt.user; <userinput>echo STRIP= &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>echo CFLAGS+=-g &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>make clean all</userinput>
&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>chmod 555 /usr/sbin/ppp</userinput></screen>

	  <para>Você agora tem uma versão
	    debugável do &man.ppp.8; instalada.  Você
	    precisará ser <username>root</username> para rodar
	    o ppp porque todos os seus privilégios foram
	    revogados.  Quando você iniciar o &man.ppp.8;, tome
	    nota com cuidado de qual era o seu diretório
	    corrente naquele instante.</para>

	  <para>Agora, quando o &man.ppp.8; receber uma
	    violação de segmento (seg-fault), você
	    terá um arquivo chamado ppp.core.  Você deve
	    então fazer o seguinte:</para>

	  <screen>&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>gdb /usr/sbin/ppp ppp.core</userinput>
<prompt>(gdb)</prompt> <userinput>bt</userinput>
.......
<prompt>(gdb)</prompt> <userinput>f 0</userinput>
......
<prompt>(gdb)</prompt> <userinput>i args</userinput>
......
<prompt>(gdb)</prompt> <userinput>l</userinput>
.......</screen>

	  <para>Toda essa informação deve ser dada com a
	    sua pergunta, sendo possível agora diagnosticar o
	    problema.</para>

	  <para>Se você é familiarizado com o gdb,
	    você pode desejar encontrar alguns outros bits e
	    partes como as que causaram o dump e também os
	    endereços e valores das variáveis
	    revelantes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-autodialprocess-noconnect">
	  <para>Por que o processo que força a discagem em auto
	    mode nunca conecta?</para>
	</question>

	<answer>
	 <para>Este era um problema conhecido na
	    configuração &man.ppp.8; para negociar um IP
	    local dinâmico com o outro ponto no auto mode.  Isto
	    foi corrigido na versão mais recente.  Procure na
	    man page do &man.ppp.8; por
	    <literal>iface</literal>.</para>

	 <para>O problema era que quando este programa inicial chamava
	    o &man.connect.2;, o número IP da interface tun
	    estava atribuído ao endpoint do soquete.  O
	    <foreignphrase>kernel</foreignphrase> cria o primeiro
	    pacote de saída e escreve-o no dispositivo tun.  O
	    &man.ppp.8; então lê o pacote e estabelece a
	    conexão.  Se em consequência da
	    atribuição dinâmica do IP do
	    &man.ppp.8; o endereço da interface for mudado, o
	    endpoint do soquete original será inválido.
	    Todos os pacotes subsequentes emitidos ao outro ponto
	    serão geralmente descartados.  Mesmo se não
	    forem descartados, nenhuma das respostas irá voltar
	    pela rota da máquina de origem, isto porque o
	    número IP já não pertence a essa
	    máquina.</para>

	  <para>Há diversas maneiras teóricas para
	    abordargem desse problema.  Seria mais agradável se
	    o ponto reatribuísse,  se possível o mesmo
	    número IP <literal>:-)</literal> A versão
	    atual do &man.ppp.8; faz isso, mas a maioria das outras
	    implementações não.</para>

	  <para>O método mais fácil do nosso lado, seria
	    nunca mudar o número IP da interface tun, mas ao
	    invés disso, mudar todos os pacotes de saída
	    de modo que a origem do número IP é mudada
	    da interface IP para o IP negociado dinâmicamente.
	    Isto é essencialmente o que a opção
	    <literal>iface-alias</literal> na versão mais
	    recente do ppp faz (com a ajuda da &man.libalias.3; e da
	    opção <option>-nat</option> do &man.ppp.8;) -
	    esta mantendo endereços anteriores da interface e
	    fazendo NAT do último endereço
	    negociado.</para>

	  <para>Uma outra alternativa (e provavelmente a mais
	    confiável) seria implementar uma chamada de sistema
	    que mudasse todos os soquetes ligados de um IP para outro.
	    O &man.ppp.8; usaria essa chamada para modificar os
	    soquetes de todos os programas em execução
	    quando um novo endereço IP é negociado.  O
	    mesmo sistema de chamadas poderia ser usado por clientes
	    dhcp quando são forçados a religar seus
	    soquetes.</para>

	  <para>Ainda, outra possibilidade é permitir a
	    interface para ser ativada sem um número IP.  Os
	    pacotes de saída seriam dados um número IP
	    255.255.255.255 até que a primeira SIOCAIFADDR
	    ioctl esteja pronta.  Isto resultaria na completa
	    ligação com o soquete.  Seria até o
	    &man.ppp.8; mudar o número IP de origem, mas somente
	    se foi setado para 255.255.255.255, e somente o
	    número IP e o IP checksum deveriam ser mudados.
	    Isto porém, é um pequeno hack do
	    <foreignphrase>kernel</foreignphrase> que deve estar
	    enviando maus pacotes para uma interface configurada, na
	    suposição de que algum outro mecanismo
	    é capaz de corrigir as coisas de forma
	    restrospectiva.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ppp-nat-games">
	  <para>Por que a maioria dos jogos não funciona com a
	    opção -nat?</para>
	</question>

	<answer>
	  <para>A razão para os jogos e outros programas
	    não funcionarem quando a libalias esta em uso
	    é porque a máquina de fora irá tentar
	    abrir uma conexão ou enviar pacotes UDP (não
	    solicitados) para a máquina de dentro.  O software
	    NAT não sabe que deve enviar esses pacotes para a
	    máquina interna.</para>

	  <para>Para que as coisas funcionem, certifique-se de que a
	    única coisa que esta rodando é o software
	    que você esta tendo problemas, a seguir rode o
	    tcpdump na interface tun do gateway ou habilite &man.ppp.8;
	    tcp/ip logging (<literal>set log+tcp/ip</literal>) na
	    gateway.</para>

	  <para>Quando você iniciar o software, você deve
	    ver pacotes passando através da máquina
	    gateway.  Quando alguma coisa volta vindo de fora,
	    será descartado (este é o problema).  Tome
	    nota do número da porta desses pacotes e a seguir
	    feche o software.  Faça isso algumas vezes para ver
	    se os números da porta são consistentes.  Se
	    eles forem, a seguinte linha no
	    <filename>/etc/ppp/ppp.conf</filename> fará o
	    software funcional:</para>

	  <programlisting>nat port <replaceable>proto</replaceable><replaceable>máquinainterna</replaceable>:
<replaceable>porta</replaceable><replaceable>porta</replaceable></programlisting>

	  <para>Onde <replaceable>proto</replaceable> é ou
	    <literal>tcp</literal> ou <literal>udp</literal>,
	    <replaceable>máquinainterna</replaceable> é
	    a máquina de onde você quer que os pacotes
	    sejam enviados e <replaceable>porta</replaceable> é
	    número da porta de destino dos pacotes.</para>

	  <para>Você não poderá usar o software em
	    outras máquinas sem mudar o comando acima, e rodar
	    o software em duas máquinas internas ao mesmo tempo
	    é fora de questão - Apesar de tudo, o lado
	    de fora esta vendo toda sua rede interna como sendo
	    somente uma máquina.</para>

	  <para>Se os números da porta não são
	    consistentes, há ainda mais 3
	    opções.</para>

	  <orderedlist>
	    <listitem>
	      <para>Enviar o suporte na libalias.  Exemplos de 'casos
		especiais' podem ser encontrados em
		<filename>/usr/src/lib/libalias/alias_*.c </filename>
		(<filename>alias_ftp.c</filename> eh um bom tipo de
		protocolo).  Isto geralmente envolve ler determinados
		pacotes reconhecidos na saída, identificando a
		instrução que chama a máquina
		externa para iniciar a conexão de volta para a
		máquina interna em uma porta (aleatória)
		específica e setar a <quote>rota</quote> na
		tabela de aliases de modo que os pacotes subsequentes
		saibam para onde ir.</para>

	      <para>Esta solução é a mais
		difícil, mas é a melhor e irá
		fazer o software trabalhar com múltipla
		máquinas.</para>
	    </listitem>

	    <listitem>
	      <para>Use um proxy.  A aplicação
		poderá suportar sock5 por exemplo, ou (como no
		caso do <quote>cvsup</quote>) pode ter uma
		opção <quote>passive</quote> que evita
		sempre requisições feitas pelo outro
		ponto de volta para a máquina local.</para>
	    </listitem>

	    <listitem>
	      <para>Redirecione tudo para a máquina interna
		usando <literal>nat addr</literal>.  Pode-se dizer que
		essa seja a apelação.</para>
	    </listitem>
	  </orderedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="useful-port-numbers">
	  <para>Alguém fez uma lista de número de portas
	    úteis?</para>
	</question>

	<answer>
	  <para>Não ainda, mas a intensão é
	    produzir tal lista (se algum interesse for mostrado).  Em
	    cada exemplo, <replaceable>internal</replaceable> deve ser
	    substítuido pelo IP da máquina que esta
	    jogando o jogo.</para>

	  <itemizedlist>
	    <listitem>
	      <para><application>Asheron's Call</application></para>

	      <para><literal>nat port udp <replaceable>
		    internal</replaceable>:65000
		  65000</literal></para>

	      <para>Mude manualmente o número da porta dentro
		do jogo para 65000.  Se você começar com
		um determinado número de máquinas que
		você deseja jogar atribua uma porta para cada
		(por ex 65001, 65002, etc) e adicione uma
		<literal>porta nat</literal> para cada uma.</para>
	    </listitem>

	    <listitem>
	      <para><application>Half Life</application></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:27005
		  27015</literal></para>
	    </listitem>

	    <listitem>
	      <para><application> PCAnywhere
		  8.0</application></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:5632 5632
		</literal></para>

	      <para><literal>nat port tcp
		  <replaceable>internal</replaceable>:5631 5631
		</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>Quake</application></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:6112
		  6112</literal></para>

	      <para>Alternativamente, você pode querer ir em
		<ulink url="www.battle.net"> www.batle.net</ulink>
		para dar uma olhada no suporte de proxy do
		quake.</para>
	    </listitem>

	    <listitem>
	      <para><application>Quake 2</application></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:27901
		  27901</literal></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:60021
		  60021</literal></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:60040
		  60040</literal></para>
	    </listitem>

	    <listitem>
	      <para><application>Red Alert</application></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:8675
		  8675</literal></para>

	      <para><literal>nat port udp
		  <replaceable>internal</replaceable>:5009 5009
		</literal></para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="fcs-errors">
	  <para>O que são erros FCS?</para>
	</question>

	<answer>
	  <para>FCS significa <literal>F</literal>rame
	    <literal>C</literal>heck <literal>S</literal>equence.
	    Cada pacote do ppp tem um checksum anexado para
	    assegurar-se de que os dados que estão sendo
	    recebidos sejam os dados que estão sendo emitidos.
	    Se o FCS de um pacote de entrada estiver incorreto, o
	    pacote sera perdido e a contagem do HDLC FCS é
	    aumentada.  Os valores de erro HDLC podem ser mostrados
	    usando o comando <literal>show hdlc</literal>.</para>

	  <para>Se a sua ligação é ruim  ou se o
	    driver serial esta perdendo pacotes), você
	    irá ver ocasionalmente erros FCS.  Isto geralmente
	    não é motivo para se preocupar, embora
	    diminua substancialmente os protocolos de
	    compressão.  Se você tem um modem externo,
	    certifique-se que seu cabo esteja protegido corretamente
	    de interferências - Isso pode erradicar o
	    problema.</para>

	  <para>Se sua ligação congelar assim que
	    você conectar e vier um grande número de
	    erros FCS, pode ser porque seu link não esta com o
	    bit 8 limpo.  Certifique-se que seu modem não
	    esteja usando o controle de fluxo do software (XON/XOFF).
	    Se o seu datalink deve usar software de controle de fluxo,
	    use o comando <literal>set accmap 0x000a0000</literal>
	    para dizer ao ppp para ignorar os caracteres
	    <literal>^Q</literal> e <literal>^S</literal>.</para>

	  <para>Uma outra razão para estar vendo muitos erros
	    FCS pode ser que a extremidade remota parou de comunicar
	    com o <acronym>PPP</acronym>.  Você pode querer
	    habilitar registros <literal>async</literal> neste ponto
	    para determinar se os dados entrantes são realmente
	    um alerta de início de sessão do prompt da
	    shell.  Se você tiver um prompt shell na extremidade
	    remota, é possível terminar o &man.ppp.8; sem
	    deixar cair a linha usando o comando <literal>close
	      lcp</literal> (o comando <literal>term</literal>
	    irá reconectar você shell da máquina
	    remota).  Se nada em seus logs indicar o porque de sua
	    ligação ter sido terminada, você pode
	    perguntar ao administrador remoto (do seu provedor?)
	    porque a sessão foi terminada.</para>
	</answer>
      </qandaentry>

      <qandaentry id="PPPoEwithNAT">
	<question id="macos-win98-pppoe-freeze">
	  <para>Por que a conexão do MacOS e Windows98 travam
	    ao rodar o PPPoE no gateway?</para>
	</question>

	<answer>
	  <para>Agradecimentos a Michael Wozniak
	    <email>mwozniak@netcom.ca</email> por descobrir o
	    problema, e a Dan Flemming
	    <email>danflemming@mac.com</email> pela
	    solução do Mac:</para>

	  <para>Isto é devido ao que é chamado de
	    roteador <quote>Buraco Negro</quote> (<foreignphrase>Black
	      Hole</foreignphrase>).  MacOS e Windows98 (e talvez
	    outros SO's da Microsoft) envia m pacotes TCP com um
	    tamanho de segmento requisitado muito grande para ser
	    contido em um frame do PPPoE (MTU por default na ethernet
	    é de 1500) <emphasis>e</emphasis> tenha o
	    <quote>não fragmento</quote> do bit ajustado
	    (default do TCP) e o roteador Telco não esta
	    enviando ICMP <quote>deve ser fragmentado</quote> de volta
	    ao sitio www que você esta tentando carregar.
	    (Alternativamente o roteador está enviando pacotes
	    ICMP corretamente, mas o firewall no sitio www esta
	    deixando perdê-los).  Quando o servidor www esta
	    enviando seus frames que não cabem no pipe do PPPoE
	    o roteador Telco deixa-os perder e sua página
	    não é carregada (algumas páginas
	    gráficas carregam porque são menores que um
	    MSS).  Esta parece ser a configuração
	    default da maioria dos Telco PPPoE (somente eles sabem
	    como programar o roteador).</para>

	  <para>Um maneira de fixar isso é usando o regedit em
	    sua seu Windows 95/98 e adicionar a seguinte entrada de
	    registro:</para>

	  <programlisting>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU</programlisting>

	  <para>Deve ser uma string com um valor <quote>1436</quote>,
	    porque há relatos de que alguns roteadores ADSL
	    são incapazes de tratar os pacotes maiores que
	    esse.  Esta chave de registro foi mudada para
	    <literal>Tcpip\Parameters\Interfaces\<replaceable>ID-para-o-adptador</replaceable>\MTU</literal>
	    no windows 2000 e tornou-se um DWORD.</para>

	  <para>Consulte os documentos da Microsoft <ulink
	      url="http://support.microsoft.com/support/kb/articles/Q158/4/74.asp">
	      Q158474 - Windows TCPIP Entradas de registroi</ulink> e
	    <ulink
	      url="http://support.microsoft.com/support/kb/articles/Q120/6/42.asp">
	      Q120642 - TCPIP &amp; NBT Parametros de
	      configuração para Windows NT</ulink> para
	    maiores informacoes sobre alterações de MTU
	    no Windows para funcionar com um roteador NAT.</para>

	  <para>Uma outra possibilidade do regedit sob o Windows 2000
	    é setar
	    <literal>Tcpip\Parameters\Interfaces\<replaceable>ID-para-o-adaptador</replaceable>\EnablePMTUBHDetect</literal>
	    DWORD para 1 como mencionado no documento original da
	    Microsoft 120642 comentado acima.</para>

	  <para>Infelizmente o MacOS não oferece uma
	    mudança TCP/IP nas configurações da
	    interface.  Entretanto, há um software comercial
	    disponível, o OTAdvancedTuner (OT para
	    OpenTransport, a pilha TCP/IP do MacOS) feito pela <ulink
	      url="http://www.softworks.com/"> Sustainable
	      Softworks</ulink>, ele permite aos usuários
	    customizar as configurações TCP/IP.  Os
	    usuários de NAT do MacOS devem selecionar o
	    <literal>ip_interface_MTU</literal> no menu drop-down,
	    colocar <literal>1450</literal> em vez de
	    <literal>1500</literal>, clique na caixa próximo ao
	    <literal>Save as Auto Configure</literal>, e clique em
	    <literal>Make Active</literal>.</para>

	  <para>Versões mais recentes do &man.ppp.8; (2.3 ou
	    mais recente) tem o comando <command>enable
	      tcpmssfixup</command> que irá automaticamente
	    ajustar um valor apropriado ao MSS.  Esta facilidade
	    é habilitada por default.  Se você for
	    apaixonado pela versão mais antiga do &man.ppp.8;
	    você pode querer dar uma olhada no
	    <literal>port</literal> do
	    <application>tcpmssd</application>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="desperation">
	  <para>Nada disso me ajudou - Eu estou desesperado!  O que eu
	    posso fazer?</para>
	</question>

	<answer>
	  <para>Se tudo falhar, envie o máximo de
	    informacões que você puder, incluindo seus
	    arquivos de configuração, a forma como
	    está iniciando o &man.ppp.8;, os trechos relevantes
	    de seu arquivo de log e a saída do comando
	    <command>netstat -rn</command> (antes e depois de
	    conectado) para a lista &a.questions; ou para o grupo de
	    notícias <ulink
	      url="news:comp.unix.bsd.freebsd.misc">comp.unix.bsd.freebsd.misc</ulink>.
	    Alguém deve ajudar a solucionar seu
	    problema.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="serial">
    <title>Comunicações Seriais</title>

    <para>Essa seção cobre as perguntas mais comuns
      sobre comunicação serial com o FreeBSD.  PPP e
      SLIP são abordados na seção
    <xref linkend="networking" remap="Networking"/>.</para>

    <qandaset>
      <qandaentry>
	<question id="found-serial">
	  <para>Como eu posso dizer se o FreeBSD encontrou minhas
	    portas seriais?</para>
	</question>

	<answer>
	  <para>Assim que o kernel do FreeBSD é carregado, ele
	    irá varrer as portas seriais do seu sistema
	    procurando dispositivos nas portas configuradas no kernel.
	    Pode-se observar atentamente as mensagens que o sistema
	    exibe, ou então executar o seguinte comando:</para>

	  <screen>&prompt.user; <userinput>dmesg | grep sio</userinput></screen>

	  <para>assim que o sistema estiver em funcionamento e
	    execução.</para>

	  <para>Aqui estão alguns exemplos dos resultados do
	    comando executado acima:</para>

	  <programlisting>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A</programlisting>

	  <para>Eles mostram duas portas seriais.  A primeira
	    está na irq 4, está usando o endereço
	    de porta <literal>0x3f8</literal>, e tem um chip modelo
	    UART 16550A.  O segundo utiliza o mesmo tipo de chip mas
	    está na irq 3 e seu endereço de porta
	    é <literal>0x2f8</literal>.  Modems internos
	    são tratados como se fossem portas seriais --
	    exceto que sempre tem um modem <quote>conectado</quote>
	    à porta.</para>

	  <para>O <foreignphrase>kernel</foreignphrase>
	    <filename>GENERIC</filename> tem suporte para duas portas
	    seriais utilizando os mesmos irqs e
	    configurações de endereços de portas
	    do exemplo acima.  Se tais configurações
	    não estão certas para seu sistema, ou se
	    você adicionou placas de modem ou tem mais portas
	    seriais para o qual o
	    <foreignphrase>kernel</foreignphrase> foi configurado,
	    apenas recompile seu
	    <foreignphrase>kernel</foreignphrase>.  Veja a a
	    seção de <link
	      linkend="make-kernel">compilação do
	      <foreignphrase>kernel</foreignphrase></link> para obter
	    mais detalhes.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="found-modem">
	  <para>Como eu posso dizer se o FreeBSD encontrou minha placa
	    de fax modem?</para>
	</question>

	<answer>
	  <para>Refira-se à resposta da pergunta
	    anterior.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="missing-tty0X">
	  <para>Eu acabei de atualizar para a versão 2.0.5 e as
	    minhas
	    <devicename>tty0<replaceable>X</replaceable></devicename>
	    desapareceram!  Como eu resolvo esse problema?</para>
	</question>

	<answer>
	  <para>Não se preocupe, eles foram incluídos
	    com os dispositivos
	    <devicename>ttyd<replaceable>X</replaceable></devicename>.
	    No entanto, você deve mudar todos os arquivos da
	    configuração antiga que você
	    tiver.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="access-serial-ports">
	  <para>Como eu acesso as portas seriais no FreeBSD?</para>
	</question>

	<answer>
	  <para>A terceira porta serial, <devicename>sio2</devicename>
	    (veja &man.sio.4;, conhecida como COM3 no DOS),
	    está na <devicename>/dev/cuaa2</devicename> para os
	    dispositivos dial-out, e na
	    <devicename>/dev/ttyd2</devicename> para os dispositivos
	    dial-in.  Qual é a diferença entre essas
	    duas classes de dispositivos?</para>

	  <para>Você utiliza
	    <devicename>ttyd<replaceable>X</replaceable></devicename>
	    para dial-ins.  Quando o
	    <devicename>/dev/ttyd<replaceable>X</replaceable></devicename>
	    se abre no modo de bloqueio, um processo irá
	    aguardar que o dispositivo
	    <devicename>cuaa<replaceable>X</replaceable></devicename>
	    correspondente torne-se inativo, e aguarda a
	    detecção do <foreignphrase>carrier
	      detect</foreignphrase> da linha para ativar-se.  Quando
	    a
	    <devicename>cuaa<replaceable>X</replaceable></devicename>
	    se abre, ela deixa claro que a porta não esta ainda
	    em uso pelo dispositivo
	    <devicename>ttyd<replaceable>X</replaceable></devicename>.
	    Se a porta estiver disponível, ela é
	    <quote>roubada</quote> do dispositivo
	    <devicename>ttyd<replaceable>X</replaceable></devicename>.
	    Além disso, o dispositivo
	    <devicename>cuaa<replaceable>X</replaceable></devicename>
	    não se importa com o carrier detect.  Com esse
	    esquema de auto-resposta do modem, você pode ter
	    usuários remotos conectando e você pode ainda
	    discar para fora com o mesmo modem, que o sistema
	    irá cuidar de todos os conflitos.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="enable-multiport-serial">
	  <para>Como eu habilito suporte para uma placa serial de
	    múltiplas portas?</para>
	</question>

	<answer>
	  <para>Novamente, a seção de
	    configuração do
	    <foreignphrase>kernel</foreignphrase> provê
	    informações sobre a
	    configuração de seu
	    <foreignphrase>kernel</foreignphrase>.  Para uma placa
	    serial de múltiplas portas, coloque uma linha
	    &man.sio.4; para cada porta serial da placa, no arquivo de
	    configuração do
	    <foreignphrase>kernel</foreignphrase>.  Mas coloque o irq
	    e as espeficicações do vetor apenas em uma
	    das entradas.  Todas as portas da placa devem compartilhar
	    uma irq.  Para consistência, utilize a última
	    porta serial para especificar a irq.  Além disso,
	    especifique a opção
	    <literal>COM_MULTIPORT</literal>.</para>

	  <para>O exemplo seguinte é para uma placa serial AST
	    4-portas na irq 7:</para>

	  <programlisting>options "COM_MULTIPORT"
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr</programlisting>

	  <para>As flags indicam que a porta master tem um
	    <quote>minor number</quote> 7 (<literal>0x700</literal>),
	    diagnósticos habilitados durante o escaneamento
	    (<literal>0x080</literal>), e todas as portas compartilham
	    uma irq (<literal>0x001</literal>).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multiport-serial-share-irq">
	  <para>O FreeBSD pode trabalhar com placas seriais de
	    múltiplas portas compartilhando irqs?</para>
	</question>

	<answer>
	  <para>Ainda não.  Você deverá utilizar
	    uma irq diferente para cada placa.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="default-serial-params">
	  <para>Posso definir os parâmetros seriais
	    padrão para uma porta?</para>
	</question>

	<answer>
	  <para>O
	    <devicename>ttyd<replaceable>X</replaceable></devicename>
	    (<devicename>cuaa<replaceable>X</replaceable></devicename>)
	    é um dispositivo regular que você vai querer
	    abrir para suas aplicações.  Quando um
	    processo abre um dispositivo, ele tem um conjunto
	    padrão de configurações de terminais
	    de E/S.  Você pode ver essas
	    configurações  com o comando</para>

	  <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

	  <para>Ao alterar as configurações para esse
	    dispositivo, elas se manterão em efeito até
	    que o dispositivo seja fechado.  Quando ele for reaberto,
	    vai para o estado padrão.  Para fazer
	    mudanças nos ajustes padrão, pode-se abrir e
	    ajustar as configurações do <quote>estado
	      inicial</quote> do dispositivo.  Por exemplo, para ligar
	    o modo <acronym>CLOCAL</acronym>, 8 bits, e o controle de
	    fluxo <acronym>XON/XOFF</acronym> padrão para a
	    ttyd5, faça:</para>

	  <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

	  <para>Um bom lugar para fazer isso é no
	    <filename>/etc/rc.serial</filename>.  Agora, uma
	    aplicação terá estas
	    configurações por padrão quando abrir
	    o <filename>ttyd5</filename>.  No entanto, pode-se ainda
	    modificar estas configurações a seu
	    gosto.</para>

	  <para>Você pode prevenir certas
	    configurações de serem modificadas por uma
	    aplicação fazendo ajustes no dispositivo de
	    <quote>lock state</quote>.  Por exemplo, para travar a
	    velocidade do <devicename>ttyd5</devicename> em 57600 bps,
	    faça:</para>

	  <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

	  <para>Agora, uma aplicação, ao abrir o
	    <devicename>ttyd5</devicename>, se tentar modificar a
	    velocidade da porta, ficará travada a 57600
	    bps.</para>

	  <para>Naturalmente você deve garantir que os
	    dispositivos de estado inicial e o estado de trava
	    (<literal>lock</literal>) tenham permissão de
	    escrita apenas para o <username>root</username>.  O script
	    &man.MAKEDEV.8; <emphasis>N&Atilde;O</emphasis> faz isso
	    quando ele cria as entradas de dispositivos.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="enable-dialup">
	  <para>Como eu habilito logins dial-up no meu modem?</para>
	</question>

	<answer>
	  <para>Então você quer tornar-se um provedor de
	    serviços internet, não é?  Primeiro,
	    você precisa de um ou mais modems que auto-respondam
	    às chamadas.  Seu modem precisa confirmar o
	    <quote>carrier detect</quote> quando ele for detectado e
	    não fazê-lo todo o tempo.  Ele
	    precisará desligar o telefone e resetar a si mesmo
	    quando a linha <acronym>DTR</acronym> (Data Terminal
	    Ready) alternar de ligado para desligado.  Ele
	    provavelmente deve utilizar o controle de fluxo
	    <filename>RTS/CTS</filename> ou nenhum controle local de
	    fluxo.  Finalmente, ele deve utilizar uma velocidade
	    constante entre o computador e si mesmo, mas (para ser
	    simpático com seus usuários) ele deve
	    negociar uma velocidade entre si mesmo e o modem
	    remoto.</para>

	  <para>Para muitos modems compatíveis com o conjunto
	    de comandos do Hayes este comando criará estas
	    configurações e as armazenará na
	    memória não volátil:</para>

	  <programlisting>AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W</programlisting>

	  <para>Veja a seção <link linkend="direct-at">
	      enviando comandos AT</link> abaixo para mais
	    informações sobre como fazer estas
	    configurações sem o auxílio de um
	    programa de terminal MS-DOS.</para>

	  <para>Depois, faça uma entrada em
	    <filename>/etc/ttys</filename> (veja &man.ttys.5;) para o
	    modem.  Este arquivo lista todas as portas nas quais o
	    sistema irá aguardar pelos logins.  Adicione uma
	    parecida com essa:</para>

	  <programlisting>ttyd1 "/usr/libexec/getty std.57600" dialup on insecure</programlisting>

	  <para>Esta linha indica que a segunda porta serial
	    (<devicename>/dev/ttyd1</devicename>) tem um modem
	    conectado e rodando a 57600 bps e sem paridade
	    (<literal>std.57600</literal>, que vem do arquivo
	    <filename>/etc/gettytab</filename>, veja
	    &man.gettytab.5;).  O tipo de terminal para esta porta
	    é <literal>dialup</literal>.  A porta esta
	    <literal>ligada</literal> e é
	    <literal>insegura</literal> - quer dizer que o login do
	    usuário <username>root</username> não
	    é permitido.  Para portas dialin como esta,
	    utiliza-se a entrada
	    <devicename>ttyd<replaceable>X</replaceable></devicename></para>

	  <para>É uma prática comum utilizar
	    <literal>dialup</literal> como o tipo do terminal.  Muitos
	    usuários configuram um
	    <foreignphrase>prompt</foreignphrase> para seus arquivos
	    <filename>.profile</filename> ou
	    <filename>.login</filename> para o tipo de terminal
	    existente se o tipo iniciante é dialup.  O exemplo
	    mostra a porta como insegura.  Para tornar-se
	    <username>root</username> nesta porta, você tem que
	    logar-se como um usuário regular, e então
	    &man.su.1; para tornar-se <username>root</username>.  Se
	    você usar <literal>seguro</literal>, então o
	    <username>root</username> vai poder efetuar o login
	    diretamente.</para>

	  <para>Após efetuar as operações no
	    <filename>/etc/ttys</filename>, você precisa enviar
	    um sinal de <foreignphrase>hangup</foreignphrase> ou
	    <acronym>HUP</acronym> para o processo
	    &man.init.8;:</para>

	  <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	  <para>Esse comando forçará a releitura do
	    arquivo <filename>/etc/ttys</filename>.  O processo init
	    iniciará os processos getty em todas as portas
	    configuradas em <literal>on</literal> (ligadas).
	    Você pode descobrir se seus logins estão
	    disponíveis para sua porta digitando:</para>

	  <screen>&prompt.user; <userinput>ps -ax | grep '[t]tyd1'</userinput></screen>

	  <para>Você deve ver algo como:</para>

	  <programlisting>747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dumb-terminal">
	  <para>Como eu conecto um terminal burro ao meu
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>Se você esta usando outro computador como um
	    terminal de seu sistema FreeBSD, consiga um cabo
	    <quote>null modem</quote> para ser usado entre as duas
	    portas seriais.  Se você esta utilizando um terminal
	    próprio, veja as instruções que o
	    acompanham.</para>

	  <para>Então, modifique o
	    <filename>/etc/ttys</filename> (veja &man.ttys.5;), como
	    acima.  Por exemplo, se você esta ligando um
	    terminal WYSE 50 à quinta porta serial, utilize uma
	    entrada como esta::</para>

	  <programlisting>ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure</programlisting>

	  <para>Esse exemplo mostra que a porta em
	    <devicename>/dev/ttyd4</devicename> tem um terminal wyse50
	    conectado a 38400 bps (bits por segundo) sem nenhuma
	    paridade (<literal>std.38400</literal> de
	    <filename>/etc/gettytab</filename>, veja
	    &man.gettytab.5;)) e o login do <username>root</username>
	    é permitido (<literal>seguro</literal>).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cannot-tip">
	  <para>Por que eu não posso executar o
	    <command>tip</command> ou o <command>cu</command>?</para>
	</question>

	<answer>
	  <para>Em seu sistema, os programas &man.tip.1; e &man.cu.1;
	    são provavelmente executáveis somente pro
	    <username>uucp</username> e para o grupo
	    <groupname>dialer</groupname>.  Você pode utilizar o
	    grupo <groupname>dialer</groupname> para controlar quem
	    acessa o seu modem ou sistemas remotos.  Basta adicionar
	    você mesmo ao grupo dialer.</para>

	  <para>Alternativamente, você pode permitir a todos no
	    seu sistema executarem o &man.tip.1; e o &man.cu.1;
	    digitando:</para>

	  <screen>&prompt.root; <userinput>chmod 4511 /usr/bin/cu</userinput>
&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput></screen>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="hayes-unsupported">
	  <para>Meu modem modelo Hayes não é suportado -
	    o que eu posso fazer?</para>
	</question>

	<answer>
	  <para>De fato a manpage para o &man.tip.1; esta
	    desatualizada.  Há um discador generico do Hayes
	    já incorporado.  Apenas insira
	    <literal>at=hayes</literal> em seu arquivo
	    <filename>/etc/remote</filename> (veja
	    &man.remote.5;).</para>

	  <para>O drive do Hayes não é inteligente o
	    bastante para reconhecer algumas das avançadas
	    características dos modems mais novos - mensagens
	    como <literal>BUSY</literal>, <literal>NO
	      DIALTONE</literal>, ou <literal>CONNECT 115200</literal>
	    estarão apenas confundindo-o.  Você deve
	    desabilitar estas mensagens quando utilizar o &man.tip.1;
	    (com o comando <literal>ATX0&amp;W</literal>).</para>

	  <para>Além disso, o timeout para discagem com o
	    &man.tip.1; é de 60 segundos.  Seu modem deve
	    utilizar um valor menor, senão o tip pensará
	    que existe um problema de comunicação.
	    Tente <literal>ATS7=45&amp;W</literal>.</para>

	  <para>De fato, como o &man.tip.1; não foi compilado
	    para suportar HAYES, essa funcionalidade não
	    é completamente suportada.  A solução
	    é editar o arquivo <filename>tipconf.h</filename>
	    no diretório
	    <filename>/usr/src/usr.bin/tip/tip</filename>.  Obviamente
	    você precisa da distribuição fonte
	    para fazer isso.</para>

	  <para>Edite a linha <literal>#define HAYES 0</literal>
	    alterando-a para <literal>#define HAYES 1</literal>.
	    Depois digite <command>make</command> e <command>make
	      install</command>.  Tudo funcionará bem depois
	    disso.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="direct-at">
	  <para>Como posso entrar nestes comandos AT?</para>
	</question>

	<answer>
	  <para>Faça o que é chamado de uma entrada
	    <quote>direta</quote> no seu
	    <filename>/etc/remote</filename> (veja &man.remote.5;).
	    Por exemplo, se o seu modem está definido na
	    primeira porta serial,
	    <devicename>/dev/cuaa0</devicename>, coloque a seguinte
	    linha:</para>

	  <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

	  <para>Utilize a taxa de velocidade mais alta que seu modem
	    suportar na capacidade br.  Então digite
	    <command>tip <devicename>cuaa0</devicename></command>
	    (veja &man.tip.1;) e você estará conectado ao
	    seu modem.</para>

	  <para>Se não existir nenhum
	    <devicename>/dev/cuaa0</devicename> no sistema,
	    faça isso:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV cuaa0</userinput></screen>

	  <para>Ou utilize cu como <username>root</username> com o
	    seguinte comando:</para>

	  <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

	  <para>com a <replaceable>line</replaceable> sendo a porta
	    serial (por exemplo, <devicename>/dev/cuaa0</devicename>)
	    e <replaceable>speed</replaceable> sendo a velocidade (por
	    exemplo, <literal>57600</literal>).  Quando terminar com
	    os comandos AT, digite <literal>~.</literal> para
	    sair.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="gt-failure">
	  <para>Porque o sinal <literal>&lt;@&gt;</literal> para a
	    capacidade pn não
	    funciona?</para>
	</question>

	<answer>
	  <para>O sinal <literal>&lt;@&gt;</literal> no número
	    de telefone diz ao tip para procurar em
	    <filename>/etc/phones</filename> por um número de
	    telefone.  Mas o sinal <literal>&lt;@&gt;</literal>
	    é também um caracter especial em arquivos
	    como o <filename>/etc/remote</filename>.  Escape dele com
	    um <literal>\</literal> (barra invertida):</para>

	  <programlisting>pn=\@</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dial-command-line">
	  <para>Como eu posso discar um número de telefone pela
	    linha de comando?</para>
	</question><answer>

	  <para>Coloque o que é chamado de uma entrada
	    <quote>genérica</quote> no arquivo
	    <filename>/etc/remote</filename> (veja &man.remote.5;).
	    Por exemplo:</para>

	  <programlisting>tip115200|Disque para qualquer número em 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Disque para qualquer número em 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

	  <para>Depois voc&ecirc pode fazer algo como <command>tip
	      -115200 5551234</command>.  Se preferir o &man.cu.1; ao
	    invés do &man.tip.1;, utilize uma entrada
	    genérica:</para>

	  <programlisting>cu115200|Use o cu para discar qualquer número em 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

	  <para>e digite <command>cu 5551234 -s
	      115200</command>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="set-bps">
	  <para>Tenho que definir a taxa de bits por segundo sempre
	    que fazer isso?</para>
	</question>

	<answer>
	  <para>Coloque uma entrada para <literal>tip1200</literal> ou
	    para <literal>cu1200</literal>, mas vá em frente e
	    utilize quaisquer taxas de bps (bits por segundo) que
	    sejam apropriadas para a capacidade br.  O &man.tip.1; diz
	    que um bom padrão é 1200 bps porquê
	    ele procura uma entrada <literal>tip1200</literal>.  De
	    qualquer forma, você não precisa utilizar
	    1200 bps.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="terminal-server">
	  <para>Como posso facilmente acessar vários hosts
	    através de um <literal>terminal
	      server</literal>?</para>
	</question>

	<answer>
	  <para>Ao invés de esperar até a
	    conexão, digitando <literal>CONNECT
	      <replaceable>host</replaceable></literal> sempre, use a
	    opção <literal>cm</literal> do tip.  Por
	    exemplo, estas entradas em
	    <filename>/etc/remote</filename> (veja
	    &man.remote.5;):</para>

	  <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

	  <para>permitirá a você digitar <command>tip
	      pain</command> ou <command>tip muffin</command> para se
	    conectar aos hosts <hostid>pain</hostid> ou
	    <hostid>muffin</hostid>; e <command>tip deep13</command>
	    para se conectar ao <literal>terminal
	      server</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="tip-multiline">
	  <para>O <quote>tip</quote> pode tentar discar mais de uma
	    linha por vez?</para>
	</question>

	<answer>
	  <para>Normalmente esse é um problema tradicional onde
	    uma universidade possue várias linhas de modems e
	    vários milhares de estudantes tentando
	    usá-las...</para>

	  <para>Faça uma entrada para sua universidade
	    em<filename>/etc/remote</filename> (veja &man.remote.5;) e
	    utilize a <literal>&lt;\@&gt;</literal> para a
	    característica <literal>pn</literal>:</para>

	  <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

	  <para>Então, liste os números de telefones
	    para a universidade em <filename>/etc/phones</filename>
	    (veja &man.phones.5;):</para>

	  <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

	  <para>O &man.tip.1; tentará usar cada um na ordem
	    listada, e depois desistirá.  Se você quer
	    manter-se tentando, execute o &man.tip.1; em um loop
	    while.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="multi-controlp">
	  <para>Por que eu tenho que pressionar duas vezes o
	    <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>P</keycap></keycombo>
	    para enviar <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>P</keycap></keycombo>
	    uma única vez?</para>
	</question>

	<answer>
	  <para><keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>P</keycap></keycombo>
	    é o padrão para <quote>force
	      character</quote>, utilizado para dizer ao &man.tip.1;
	    que o próximo caracter é um dado literal.
	    Você pode definir o force character para qualquer
	    outro caracter com o escape <literal>~s</literal>, que
	    quer dizer <quote>defina uma variável</quote>.</para>

	  <para>Digite <literal>~sforce=<replaceable>single-char
	      </replaceable></literal> seguido de uma
	    <emphasis>newline</emphasis>.
	    <replaceable>single-charcaracter</replaceable> é
	    qualquer caracter único.  Se você deixar
	    <replaceable>single-char</replaceable>, então o
	    <quote>force character</quote> será o caracter
	    nulo, que você pode ao digitar <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>2</keycap></keycombo>
	    ou <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>SPACE</keycap></keycombo>.
	    Um valor muito bom para o
	    <replaceable>single-char</replaceable> é <keycombo
	      action="simul"><keycap>SHIFT</keycap><keycap>CTRL</keycap><keycap>6</keycap></keycombo>,
	    o qual eu vi sendo usado em alguns servidores de
	    terminais.</para>

	  <para>Você pode ter o <quote>force character</quote>
	    que você quiser especificando o seguinte em seu
	    arquivo <filename>$HOME/.tiprc</filename> o
	    seguinte:</para>

	  <programlisting>force=<replaceable>single-char</replaceable></programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="uppercase">
	  <para>Por que tudo o que eu digito inesperadamente
	    está em CAIXA ALTA?</para>
	</question>

	<answer>
	  <para>Você deve ter pressionado <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>A</keycap></keycombo>,
	    o <quote>raise character do &man.tip.1;</quote>,
	    especialmente projetado para pessoas com teclas
	    <keycap>Caps Lock</keycap> que não funcionam.  Use
	    o <literal>~s</literal> como acima, e defina a
	    variável <quote>raisechar</quote> para algo
	    razoável.  De fato, você pode definir isso
	    para o <emphasis>force character</emphasis> também,
	    se você nunca espera utilizar ambas as
	    características.</para>

	  <para>Aqui está um exemplo de arquivo
	    <filename>.tiprc</filename> perfeito para os
	    usuários de Emacs que precisam digitar muitos
	    <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>2</keycap></keycombo>
	    e <keycombo
	      action="simul"><keycap>CTRL</keycap><keycap>A</keycap></keycombo>:</para>

	  <programlisting>force=^^
raisechar=^^</programlisting>

	  <para>O ^^ é obtido com <keycombo
	      action="simul"><keycap>SHIFT</keycap><keycap>CTRL</keycap><keycap>6</keycap></keycombo>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="tip-filetransfer">
	  <para>Como eu posso transferir arquivos com o
	    <command>tip</command>?</para>
	</question>

	<answer>
	  <para>Se você está conversando com outro
	    sistema Unix, você pode enviar e receber arquivos
	    com <literal>~p</literal> (put) e com
	    <literal>~t</literal> (take).  Estes comandos executam o
	    &man.cat.1; e o &man.echo.1; no sistema remoto para
	    aceitar e enviar arquivos.  Sua sintaxe é:</para>

	  <programlisting>~p &lt;local-file&gt; [&lt;remote-file&gt;]
~t &lt;remote-file&gt; [&lt;local-file&gt;]</programlisting>

	  <para>Não há nenhuma checagem de erro,
	    então você provavelmente deve usar um outro
	    protocolo, como o zmodem</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="zmodem-tip">
	  <para>Como eu posso executar o zmodem com o
	    <application>tip</application>?</para>
	</question>

	<answer>
	  <para>Primeiro, instale um dos programas zmodem da
	    coleção de <literal>ports</literal> (tais
	    como <application>lrzsz</application> ou o
	    <application>rzsz</application>).</para>

	  <para>Para receber arquivos, inicie o programa de envio no
	    destino remoto.  Então, pressione ENTER e digite
	    <literal>~C rz</literal> (ou <literal>~C lrz</literal>
	    caso tenha instalado o <application>lrzsz</application>)
	    para iniciar o recebimento local</para>

	  <para>Para enviar arquivos, inicie o programa do lado
	    remoto.  Depois, aperte ENTER e digite <literal>~C sz
	      <replaceable>arquivos</replaceable></literal> (ou
	    <literal>~C lsz
	      <replaceable>arquivos</replaceable></literal>) para
	    envia-los ao sistema remoto.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="cannot-find-serial">
	  <para>O FreeBSD pode vir a não encontrar minhas
	    portas seriais, mesmo quando as
	    configurações estão corretas?</para>
	</question>

	<answer>
	  <para>Sim, se sua placa-mãe for Acer UARTS.  Elas
	    não escaneiam corretamente o barramento serial,
	    não permitindo que o FreeBSD encontre as Serial
	    Input/Output (sio) da placa.  O patch disponível em
	    <ulink
	      url="http://www.lemis.com/serial-port-patch.html">www.lemis.com</ulink>
	    pode corrigir esse problema.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="misc">
    <title>Perguntas Variadas</title>

    <qandaset>
      <qandaentry>
	<question id="more-swap">
	  <para>O FreeBSD usa bem mais espaço de swap do que o
	    Linux.  Por quê?</para>
	</question>

	<answer>
	  <para>Só parece que o FreeBSD usa mais swap do que o
	    Linux.  Na verdade não usa.  A principal
	    diferença entre o FreeBSD e o Linux nesse quesito
	    é que o FreeBSD vai sempre remanejar - de forma
	    pró-ativa - toda memória que estiver
	    completamente inativa e subutilizada, para o swap, dessa
	    forma garantindo sempre mais memória principal
	    disponível para utilização.  O Linux
	    tende a remanejar páginas de memória para o
	    swap apenas como última alternativa.  A
	    utilização mais acentuada do swap é
	    balanceada pela utilização mais eficiente da
	    memória principal.</para>

	  <para>Note que, pelo fato do FreeBSD ser próativo
	    nesse quesito, ele não decide arbitrariamente fazer
	    swap das páginas quando o sistema está de
	    fato inativo.  Portanto você não corre o
	    risco de encontrar todo seu sistema despaginado pela
	    manhã, depois de uma noite inteira de
	    inatividade.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="top-freemem">
	  <para>Por que o <command>top</command> me mostra
	    pouquíssima memória livre, mesmo quando eu
	    não tenho muitos programas rodando?</para>
	</question>

	<answer>
	  <para>A resposta simples é que memória
	    principal livre é memória
	    desperdiçada.  Toda memória que não
	    estiver ativamente alocada pelos seus programas são
	    utilizadas pelo Kernel do FreeBSD como cache de disco.  Os
	    valores que o &man.top.1; mostra como
	    <literal>Inact</literal>, <literal>Cache</literal>, e
	    <literal>Buf</literal> são dados referentes ao
	    cache de disco, em estágios distintos de
	    utilização.  Esses dados cacheados garantem
	    que o sistema não tenha que fazer acesso em um
	    disco local (muito mais lento que a memória) para
	    utilizar os dados que foram acessados recentemente,
	    garantindo assim melhora significativa na performance
	    geral.  Na maioria dos casos, se o &man.top.1; mostrar que
	    existe pouca memória disponível, isso
	    é uma boa indicação, a não ser
	    que seja uma quantidade <emphasis>extremamente</emphasis>
	    baixa.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="aout-elf">
	  <para>Por que usar (alias, o que são) os formatos
	    executáveis a.out e ELF?</para>
	</question>

	<answer>
	  <para>Para entender porque o FreeBSD usa o formato
	    <filename>ELF</filename>, você deve primeiro saber
	    um pouco sobre os 3 formatos de executáveis Unix
	    <quote>dominantes</quote> atualmente:</para>

	  <note>
	    <para>Até a versão 3.x o FreeBSD usava o
	      formato a.out.</para>
	  </note>

	  <itemizedlist>
	    <listitem>
	      <para>&man.a.out.5;</para>

	      <para>O mais antigo e <quote>classico</quote>formato de
		objetos Unix.  Ele usa um cabeçalho curto e
		compacto, com um <quote>magic number</quote> no
		início que é frequentemente utilizado
		para identificar seu formato (mais detalhes veja
		&man.a.out.5;).  Ele contém três segmentos
		a serem carregados: .text, .data, e .bss acrescidos de
		uma tabela de símbolos e uma tabela de
		caractereres adicionais.</para>
	    </listitem>

	    <listitem>
	      <para><acronym>COFF</acronym></para>

	      <para>O formato de objetos SVR3.  Seu cabeçalho
		se consiste agora em uma tabela de
		seções, dessa forma garantindo que
		você tenha outras seções
		além de .text, .data, e .bss.</para>
	    </listitem>

	    <listitem>
	      <para><acronym>ELF</acronym></para>

	      <para>O sucessor do <acronym>COFF</acronym>,
		atribuído de Múltiplas
		seções e valores de 32-bit ou 64-bit.
		Um de seus principais inconvenientes:  O formato
		<acronym>ELF</acronym> foi originalmente desenvolvido
		presumindo-se que existiria apenas um único ABI
		por arquitetura.  A presunção é
		incorreta, e nem mesmo em relação ao
		mundo comercial do SYSV (onde encontramos ao menos
		três ABIs distintas: SVR4, Solaris, SCO) isso
		acontece.</para>

	      <para>O FreeBSD tenta se virar com esse problema com um
		utilitário que <emphasis>identifica</emphasis>
		um executável <acronym>ELF</acronym>
		relacionando-o ao ABI com o qual ele é
		compatível.  Veja a página de manual do
		&man.brandelf.1; para maiores
		informações.</para>
	    </listitem>
	  </itemizedlist>

	  <para>O FreeBSD vem de tradição
	    <quote>clássica</quote> e por isso sempre usou o
	    formado &man.a.out.5 que é uma tecnologia que foi
	    experimentada e aprovada por várias
	    gerações de sistemas BSD.  Apesar de,
	    há algum tempo também ser possível
	    para o FreeBSD trabalhar nativamente com binários
	    <acronym>ELF</acronym>  (e também
	    <foreignphrase>kernels</foreignphrase>), o FreeBSD
	    inicialmente resistiu à
	    <quote>pressão</quote> em assumir o
	    <acronym>ELF</acronym>  como formato padrão.  Por
	    quê?  Bem, quando o campo do Linux resolveu fazer
	    sua dolorosa transição para o formato
	    <acronym>ELF</acronym>, não sobrou muito para ser
	    aproveitado dos formatos <filename>a.out</filename>
	    especialmente por causa das limitações de
	    tabelas que podiam ser utilizadas em seus
	    cabeçalhos, e isso tornou o desenvolvimento de
	    bibliotecas compartilhadas extremamente árduo para
	    fabricantes e desenvolvedores em geral.  Depois disso, as
	    ferramentas <acronym>ELF</acronym> começaram
	    à oferecer soluções para o
	    compartilhamento de bibliotecas, soluções
	    que fossem extremamente satisfatórias, e a
	    migração, apesar dos custos
	    necessários que a envolvia, foi aceita, e a
	    transição para <acronym>ELF</acronym> passou
	    a ser o <quote>caminho à ser
	      seguido</quote>.</para>

	  <para>No caso do FreeBSD, o nosso mecanismo de bibliotecas
	    compartilhadas tem uma base mais próxima do estilo
	    do <application>SunOS</application>, da Sun, e é
	    extremamente fácil de ser utilizado.  Contudo,
	    à partir da série 3.0, o FreeBSD
	    oficialmente adotou o formato de binários
	    <acronym>ELF</acronym> como padrão.  Apesar do
	    formato <filename>a.out</filename> sempre ter servido
	    muito bem às nossas necessidades, o pessoal da GNU,
	    autores de algumas das ferramentas de
	    compilação que nós usamos,
	    simplesmente deixaram de suportar o formato
	    <filename>a.out</filename>.  Tal fato nos forçou
	    à manter versões distintas do compilador e
	    do linkador, e nos permitiriam usufruir dos
	    esforços que nós achássemos
	    interessantes nos desenvolvimentos GNU.  Finalmente, a
	    demanda pelo ISO-C++, notáveis compiladores e
	    descompiladores, também contribuiram para uma
	    adoção nativa dos binários
	    <acronym>ELF</acronym> nas versões futuras do
	    FreeBSD.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="binary-formats">
	  <para>Certo, mas por que existem tantos formatos
	    diferentes?</para>
	</question>

	<answer>
	  <para>De volta às origens, em um passado obscuro,
	    existiam apenas hardwares mais simples.  Esse hardware
	    simples, suportava sistemas simples e pequenos.  A a.out
	    era completamente adequada para o serviço de
	    representar o formato binário nesses sistemas (os
	    PDP-11).  Conforme as pessoas iam portando o Unix desse
	    sistema mais simples, eles mantinham o formato a.out
	    porque era bom o bastante para portar para arquiteturas
	    como o Motorola 68k, VAXen, etc.</para>

	  <para>Então, algum engenheiro de hardware brilhante,
	    decidiu que se ele pudesse forçar o software
	    à dar conta de algumas coisinhas, alguns
	    truquezinhos, ele poderia então passar por cima de
	    algumas restrições de design, e permitir que
	    a base de sua CPU tivesse um desempenho melhor.  Para
	    poder trabalhar como esse novo tipo de hardware (que hoje
	    é conhecido como RISC), a
	    <filename>a.out</filename> não se encaixava muito
	    bem em suas funções, e então muitos
	    formatos foram desenvolvidos afim de obter melhor
	    performance desse hardware, que a simples
	    <filename>a.out</filename> não podia comportar.
	    Coisas como <acronym>COFF</acronym>,
	    <acronym>ECOFF</acronym> e outras ainda mais obscuras
	    foram inventadas, e todas suas limitações
	    foram exploradas, até que se resultasse o formato
	    <acronym>ELF</acronym>.</para>

	  <para>Em adição, o tamanho dos programas
	    passou a crescer, e os discos (assim como a memória
	    física) ainda eram relativamente pequenos,
	    então nasceu o conceito de compartilhamento de
	    bibliotecas.  O sistema de Memória Virtual (VM)
	    também se tornou mais sofisticado.  Cada um desses
	    avanços eram feitos utilizando-se o formato
	    <filename>a.out</filename>, e o seu uso crescia mais e
	    mais com cada nova característica.  Depois, as
	    pessoas começaram a querer que as coisas fossem
	    dinâmicamente carregadas em tempo de
	    execussão, ou então queriam poder descartar
	    algum trecho de seus programas depois que seu
	    código de inicialização tivesse sido
	    executado, de modo à economizar memória
	    principal ou mesmo Swap.  As linguagens de
	    programação se tornaram mais sofisticadas,
	    então as pessoas queriam códigos com
	    chamadas automáticas antes do programa principal
	    (main).  Começou-se então a hackear a
	    <filename>a.out</filename> de forma que ela pudesse suprir
	    essas necessidades.  E de fato por algum tempo ela as
	    supriu.  Depois a <filename>a.out</filename> passou a
	    não suportar mais determinados problemas sem
	    resultar em uma sobrecarga ou complexidade exagerada de
	    código.  Por outro lado, o formato
	    <acronym>ELF</acronym> resolvia a maioria desses
	    problemas, mas seria doloroso demais simplesmente
	    abandonar um formato e sistema que, basicamente
	    funcionavam bem.  Então o formato
	    <acronym>ELF</acronym> teve que esperar até que
	    fosse ainda mais doloroso continuar com o formato
	    <filename>a.out</filename> do que migrar para
	    <acronym>ELF</acronym>.</para>

	  <para>Contudo, com o passar do tempo, as ferramentas de
	    desenvolvimento às quais o FreeBSD derivava suas
	    próprias ferramentas de desenvolvimento
	    (especialmente o assembler e o carregador - loader) se
	    envolveram em duas árvores paralelas.  A
	    árvore do FreeBSD adicionou inúmeras
	    bibliotecas compartilhadas, e arrumou inúmeros
	    bugs.  E a rapaziada do GNU, que originalmente escreviam
	    algumas dessas ferramentas, passaram a rescreve-las e
	    adicionaram suporte para compilação
	    derivada, adoções de formatos diferentes,
	    etc.  Depois pensou-se em desenvolver um formato derivado,
	    visando o FreeBSD, mas não obteve-se sorte o
	    bastante, especialmente porque os fontes antigos do
	    &quot;ld&quot; do FreeBSD não davam conta da
	    tarefa.  A corrente de novas ferramentas GNU (as chamadas
	    binutils) agora suportam compilação
	    derivada, formato <acronym>ELF</acronym>, bibliotecas
	    compartilhadas, extensões de C++, etc, etc.  Em
	    adição ainda, muitos fabricantes passaram
	    à lançar binários
	    <acronym>ELF</acronym>, e então, por que continuar
	    nos chateando com o formato <filename>a.out</filename>?  A
	    <filename>a.out</filename> é um cavalo velho e
	    muito cansado, que já provou ser extremamente
	    útil no passado, mas agora está na hora de
	    tira-lo do pasto, como recompensa por seus longos e
	    fiéis anos de serviço.</para>

	  <para>O formato <acronym>ELF</acronym> é mais
	    expressivo do que o <filename>a.out</filename>, e vai
	    permitir muito mais extensibilidade à base do
	    sistema.  As ferramentas <acronym>ELF</acronym> são
	    mantidas de forma mais confiável, e oferecem
	    suporte à compilação derivada, o que
	    é importante para muita gente.  O formato
	    <acronym>ELF</acronym> é um pouco mais lento do que
	    o formato <filename>a.out</filename>, mas é quase
	    impossível comparar ambos, existem inúmeros
	    detalhes que os fazem diferentes, desde o mapeamento de
	    páginas de memória, até a forma como
	    eles tratam o código de inicialização
	    de um binário (init code).  Nenhuma dessas
	    questões é importante, mas existem
	    diferenças.  Com o tempo, o suporte para o formato
	    <filename>a.out</filename> vai ser retirado do
	    <foreignphrase>kernel</foreignphrase> GENERIC, e
	    eventualmente será retirado em definitivo do
	    <foreignphrase>kernel</foreignphrase>, uma vez que a
	    necessidade de rodar programas <filename>a.out</filename>
	    tenham se tornado passado.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="chmod-symlinks">
	  <para>Por que o chmod não modifica as
	    permissões dos links simbólicos?</para>
	</question>

	<answer>
	  <para>Links simbólicos não tem
	    permissões, e por padrão, o &man.chmod.1;
	    não vai seguir os links afim de mudar as
	    permissões do arquivo original.  Portanto, se
	    você tem um arquivo qualquer, e um link
	    simbólico para esse arquivo, o seguinte comando vai
	    lhe servir.</para>

	  <screen>&prompt.user; <userinput>chmod g-w &lt;link simbólico&gt;</userinput></screen>

	  <para>Contudo, as permissões para o arquivo original
	    não serão alteradas.  Mas se você usar
	    a opção <option>-H</option> ou
	    <option>-L</option> em conjunto com <option>-R</option>,
	    você vai poder alterá-la.  Veja as
	    páginas de manuais do &man.chmod.1; e do
	    &man.symlink.7; para mais informações.</para>

	  <warning>
	    <para>A opção <option>-R</option> resulta em
	      um &man.chmod.1; <acronym>RECURSIVO</acronym>.  Tome
	      muito cuidado quando for definir diretórios ou
	      links simbólicos com &man.chmod.1;.  Se você
	      quer alterar as permissões dentro do
	      diretório referenciado pelo symlink, então
	      basta usar o &man.chmod.1; sem qualquer outra
	      opção, mas com uma barra
	      <filename>/</filename>.  Por exemplo, se
	      <filename>A</filename> for um link simbólico para
	      o arquivo original <filename>B</filename>, então
	      para alterar sua permissão basta um
	      simples:</para>

	    <screen>&prompt.user; <userinput>chmod 555 A/</userinput></screen>

	    <para>Com essa barra, o &man.chmod.1; vai seguir o link
	      simbólico para mudar as permissões do
	      arquivo original.</para>
	  </warning>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="login-8char">
	  <para>Por que os nomes de login (ou username) são
	    restritos à 8 caracteres no FreeBSD 2.2.X e
	    anteriores?</para>
	</question>

	<answer>
	  <para>Você pode pensar que seria bem
	    confortável simplesmente mudar o
	    <literal>UT_NAMESIZE</literal> e depois recompilar todo o
	    sistema operacional, ai tudo iria funcionar
	    maravilhosamente bem.  Infelizmente não é
	    assim que as coisas funcionam, existem estruturas de
	    aplicações e utilitários (incluindo
	    ferramentas do sistema) que foram codificadas utilizando
	    números pequenos (nem sempre <literal>8</literal>
	    ou <literal>9</literal>, mas alguns valores mais
	    arbitrários como <literal>15</literal> e
	    <literal>20</literal>) em estruturas e buffers.  Você
	    não vai ter problemas apenas com arquivos de logs,
	    que serão inutilizados (devido ao tamanho
	    variável dos dados gravados, quando apenas um
	    tamanho constante era esperado), mas vai também ter
	    problemas com clientes NIS de máquinas Sun, e
	    potencialmente provocar outros problemas ao interagir com
	    outros sistemas Unix.</para>

	  <para>No FreeBSD 3.0 e posteriores, o tamanho máximo
	    do nome de usuário foi elevado para 16 caracteres,
	    e todas as ferramentas e trechos do código
	    principal do sistema que poderiam apresentar problemas em
	    relação à isso, foram encontradas e
	    corrigidas.  O fato dessa alteração mudar
	    tantos fatores importantes no sistema é que,
	    nenhuma mudança tinha sido feita até a
	    versão 3.0.</para>

	  <para>Se você confia completamente em suas habilitades
	    para procurar e corrigir esses prováveis problemas
	    sozinho, então basta aumentar o tamanho do nome de
	    usuário no arquivo
	    <filename>/usr/include/utmp.h</filename> e mudar a
	    UT_NAMESIZE para o valor desejado.  Você
	    também vai ter que atualizar o MAXLOGNAME no
	    <filename>/usr/include/sys/param.h</filename>  para ficar
	    de acordo com a mudança no UT_NAMESIZE.
	    Finalmente, se você vai recompilar os fontes,
	    não se esqueça que o /usr/include é
	    atualizado sempre.  Mude então os arquivos
	    apropriados em /usr/src(...) para garantir que você
	    vai estar alterando sempre a fonte do problema, e
	    não apenas a instância instalada, no
	    sistema.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dos-binaries">
	  <para>Posso rodar binários do DOS sob FreeBSD?</para>
	</question>

	<answer>
	  <para>Sim, à partir da versão 3.0, você
	    pode utilizar o emulador <application>doscmd</application>
	    da BSDI.  A emulação DOS desse aplicativo
	    foi totalmente redefinida depois da sua
	    integração do FreeBSD.  Entre na
	    &a.emulation; se você tem interesse em se juntar ao
	    grupo que se esforça nessa jornada.</para>

	  <para>Em sistemas anteriores ao 3.0, existe um
	    utilitário não muito interessante, chamado
	    <application>pcemu</application> no
	    <literal>Ports</literal>.  O
	    <application>pcemu</application> emula um 8088 e algumas
	    função de BIOS que são o bastante
	    para rodar aplicações DOS que sejam
	    textuais.  Ele requer o X, sistema de interface grafica
	    (XFree86).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="translation">
	  <para>O que eu preciso para traduzir um documento do FreeBSD
	    para a minha língua nativa?</para>
	</question>

	<answer>
	  <para>Veja o <ulink
	      url="../fdp-primer/translations.html"><literal>FAQ</literal>
	      de Tradução</ulink> no
	    <foreignphrase>FreeBSD Documentation Project
	      Primer</foreignphrase>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="freebsd-mail-bounces">
	  <para>Por que meu e-mail para qualquer endereço em
	    FreeBSD.org sempre falha?</para>
	</question>

	<answer>
	  <para>O sistema de correio eletrônico do site
	    FreeBSD.org implementa algumas das
	    restrições do Postfix, verificando nas
	    mensagens que estão chegando, se elas estão
	    sendo entregues por algum servidor mal configurado, ou se
	    representa algum tipo de <literal>SPAM</literal> em
	    potencial.  As suas mensagens podem estar voltando por
	    algum dos seguintes motivos:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A mensagem está sendo enviada de um
		domínio ou bloco de endereços IP
		reconhecidamente utilizados para
		<literal>SPAM</literal>.</para>

	      <para>Os servidores de correio eletrônico do
		projeto FreeBSD rejeitam mensagens de qualquer fonte
		de <literal>SPAM</literal> conhecida.  Se você
		utiliza os serviços de uma empresa que costuma
		fazer <literal>SPAM</literal> ou permitir que seus
		clientes o façam, por gentileza, mude o seu
		provedor de serviços, para um que não
		permite tal prática.</para>
	    </listitem>

	    <listitem>
	      <para>O corpo da mensagem contém apenas
		HTML.</para>

	      <para>Mensagens de correio eletrônico devem ser
		enviadas apenas como texto puro.  Mensagens de e-mail
		não são web sites.  Configure o seu
		cliente de correio eletrônico de modo que ele
		apenas envie mensagens de texto puro.</para>
	    </listitem>

	    <listitem>
	      <para>Os servidores da FreeBSD.org não conseguem
		resolver o seu endereço IP para o nome da
		estação que está entregando a
		mensagem eletrônica.</para>

	      <para>Por padrão, ter registros de DNS reverso
		é um dos requisitos para que nossos servidores
		recebam sua mensagem.  Configure o DNS reverso para o
		IP do seu servidor de e-mail.  Lembre-se que, alguns
		serviços residênciais (como ADSL, dialup,
		cable, etc) não permitem que você mesmo
		configure o seu reverso.  Nesse caso, envie sua
		mensagem pelo servidor de e-mail do seu provedor de
		serviços, ou peça ao provedor que ajuste
		o reverso do seu IP.</para>
	    </listitem>

	    <listitem>
	      <para>O nome da estação enviada no
		cabeçalho inicial EHLO/HELO, parte do protocolo
		de envio SMTP não pode ser resolvido em um
		endereço IP correspondente.</para>

	      <para>O servidor que está tentando entregar a
		mensagem deve ter o registro de nomes configurado
		corretamente, de forma que o nome da
		estação possa ser resolvido em um
		endereço IP.  Caso sua estação
		não tenha um registro DNS configurado, utilize
		o servidor de correio eletrônico do seu provedor
		de serviços.</para>
	    </listitem>

	    <listitem>
	      <para>Sua mensagem teve uma identificação
		que terminava com o conjunto de caracteres
		<quote>localhost</quote>.</para>

	      <para>Alguns clientes de correio eletrônico geram
		ID - identificações - das mensagens de
		forma imprópria.  Nesse caso, o seu servidor de
		correio deve redefinir o ID da mensagem, ou você
		deve reconfigura-lo de modo que ele gere tal
		identificação de forma
		aceitável.</para>
	    </listitem>
	  </itemizedlist>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="free-account">
	  <para>Onde eu consigo uma conta gratuíta em um
	    FreeBSD?</para>
	</question>

	<answer>
	  <para>O Projeto FreeBSD não permite acesso
	    público a nenhum dos seus servidores, contudo
	    algumas empresas oferecem acesso irrestrito à
	    sistemas Unix.  Os preços variam, e alguns
	    serviços limitados podem ser
	    disponibilizados.</para>

	  <para>A <ulink url="http://www.arbornet.org/">Arbornet,
	      Inc</ulink>, também conhecida como M-Net,
	    provê acesso à sistemas Unix desde 1983.
	    Inicialmente rodando sob um System III em arquitetura
	    Altos, o site mudou seu sistema para BSD/OS em 1991.  Em
	    junho de 2000 o site mudou novamente seu sistema para
	    FreeBSD.  A M-Net pode ser acessada via telnet e SSH, e
	    proporciona acesso básico a uma gama completa de
	    softwares do FreeBSD.  Contudo, o acesso à rede
	    é limitado aos membros e patronos da
	    instituição, que fazem doações
	    à empresa, uma vez que a mesma é uma
	    organização sem fins lucrativos.  A M-Net
	    também oferece um Boletim periódico e Chat
	    interativo.</para>

	  <para>A <ulink url="http://www.grex.org/">Grex</ulink>
	    também oferece um acesso parecido com o da M-Net,
	    inclusive com os mesmos serviços, contudo a
	    máquina é uma Sun 4M e seu sistema Unix
	    é o SunOS.  Vale pela curiosidade, e para
	    comparação entre os sistemas.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="sup-define">
	  <para>O que é <command>sup</command>, e como eu uso
	    isso?</para>
	</question>

	<answer>
	  <para><ulink
	      url="http://www.FreeBSD.org/cgi/ports.cgi?^sup">SUP</ulink>
	    significa Protocolo de Atualização de
	    Programa (Software Update Protocol ), e foi desenvolvido
	    pela CMU para manter suas árvores de
	    desenvolvimento sempre sincronizadas.  Nós
	    utilizamos esse protocolo para manter alguns sites remotos
	    em sincronia com os nossos servidores centrais de
	    desenvolvimento.</para>

	  <para>SUP náo é amigável com a banda de
	    tramissão (consome muita banda) , e por isso foi
	    aposentado.  Atualmente recomendados que você
	    faça uso do <ulink
	      url="../handbook/synching.html#CVSUP">CVSup</ulink> para
	    manter seus fontes atualizados.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="daemon-name">
	  <para>Qual o nome daquele capetinha vermelho
	    simpático?</para>
	</question>

	<answer>
	  <para>Ele não tem um nome, é simplesmente
	    chamado de <quote>the BSD daemon</quote>.  Se você
	    insiste em dar um nome à ele, por gentileza,
	    chame-o de <quote>beastie</quote> ;-) Note que
	    <quote>beastie</quote> se pronuncia
	    <quote>BSD</quote>.</para>

	  <para>Você pode saber mais sobre o BSD daemon na sua
	    <ulink
	      url="http://www.mckusick.com/beastie/index.html">home
	      page</ulink>.</para>
	  </answer>
      </qandaentry>

      <qandaentry>
	<question id="use-beastie">
	  <para>Posso usar a imagem do BSD daemon?</para>
	</question>

	<answer>
	  <para>Talvez.  O BSD daemon é de direitos autorais de
	    Marshall Kirk McKusick.  Você deve pedir a
	    permissão do McKusick para usar a imagem do BSD
	    Daemon, e pedir para saber os <ulink
	      url="http://www.mckusick.com/beastie/mainpage/copyright.html">termos
	      de utilização da figura
	      pública</ulink> do nosso querido capetinha
	    ;-)</para>

	  <para>Resumindo, você pode fazer uso da imagem dele,
	    dependendo da maneira, para uso pessoal, por exemplo.  Se
	    os créditos apropriados forem dados, tudo bem.
	    Para fazer uso comercial da imagem, ai sim você deve
	    falar com o McKusick, e dar uma olhada na home page do
	    <ulink url="http://www.mckusick.com/beastie/index.html">
	      BSD Daemon</ulink> para mais detalhes..</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="daemon-images">
	  <para>Vocês tem algumas imagens do BSD daemon que eu
	    poderia usar?</para>
	</question>

	<answer>
	  <para>Você vai encontrar algumas figuras em eps e Xfig
	    sob o diretório
	    <filename>/usr/share/examples/BSD_daemon/</filename>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="define-MFC">
	  <para>O que significa <acronym>MFC</acronym>?</para>
	</question>

	<answer>
	  <para>MFC é um acrônimo para <quote>obtido a
	      partir do ramo -CURRENT</quote> (<foreignphrase>Merged
	      From -CURRENT</foreignphrase>).  É usado nos logs
	    do CVS para identificar uma mudança que seja
	    originada e migrada da série de desenvolvimento
	    (-CURRENT) para série estável
	    (-STABLE).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="define-BSD">
	  <para>O que significa <acronym>BSD</acronym>?</para>
	</question>

	<answer>
	  <para>O significado da sigla BSD é algo, em uma
	    língua secreta que apenas os membros podem saber.
	    Literalmente não seria possível traduzir BSD
	    para uma língua que você pudesse entender,
	    mas poderíamos tentar explicar seu significado como
	    algo bem próximo de <quote>Equipe de
	      Fórmula-1</quote>, <quote>Penguins são
	      aperitivos saborosos</quote>, e também
	    <quote>Nós temos mais senso de humor do que o
	      Linux</quote>.  :-)</para>

	  <para>A versão séria é que BSD é
	    um acrônimo para <quote>Berkeley Software
	      Distribution</quote>, que é o nome que o Grupo de
	    Pesquisa de Ciência da Computação da
	    Universidade de Berkeley - Berkeley
	    <acronym>CSRG</acronym> (Computer Systems Research Group)
	    - escolheu para sua própria
	    distribuição do Unix.
	  </para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="define-pola">
	  <para>O que significa <acronym>POLA</acronym>?</para>
	</question>

	<answer>
	  <para>É o Princípio de Menor
	    Alteração.  Significa que durante o processo
	    de desenvolvimento do FreeBSD, toda e qualquer
	    modificação que seja visível para o
	    usuário, deve ser menos surpreendente
	    possível, mantendo assim uma compatibilidade
	    prévia com a forma de utilização do
	    sistema.  Por exemplo, não se pode alterar
	    arbitráriamente as variáveis dos scripts de
	    configuração do sistema, em
	    <filename>/etc/defaults/rc.conf</filename>, pois esse tipo
	    de ação violaria a POLA.  O desenvolvimento
	    do FreeBSD apenas considera POLA quando as
	    alterações são visíveis pelo
	    usuário.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="define-repocopy">
	  <para>O que é um repo-copy?</para>
	</question>

	<answer>
	  <para>Um repo-copy (que é uma forma breve de chamar
	    um <quote>repository copy</quote>) é simplesmente a
	    cópia direta de arquivos em um repositório
	    CVS.</para>

	  <para>Sem um repo-copy, uma alteração por
	    parte de algum mantenedor, se tornaria uma cópia
	    comum, originada via <command>cvs</command>, seguida de um
	    <command>rm</command> para deletar o arquivo original que
	    tivesse sido modificado.</para>

	  <para>Esse processo contudo, resulta em uma não
	    constatação histórica do arquivo
	    antigo, nos novos registros de log.  O Projeto FreeBSD
	    considera extremamente importante a
	    manutenção desse histórico, e por
	    isso as cópias de repositório são
	    frequentemente utilizadas.  Nesse processo, um dos
	    repositórios centrais vai copiar os arquivos
	    diretamente para outro repositório, e não
	    simplesmente fazer uma sincronia com o programa
	    &man.cvs.1;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bikeshed-painting">
	  <para>Porque eu devo me preocupar com a cor do quartinho de
	    bicicletas (bikeshed)?</para>
	</question>

	<answer>
	  <para>A resposta mais curta, é que você
	    não deve.  A resposta longa é que, só
	    porque você é capaz de fazer quarto para
	    guardar sua própria bicicleta, você
	    não pode fazer as outras pessoas pararem de
	    construir seus próprios quartinhos também,
	    simplesmente porque você não gosta da cor que
	    as pessoas os pintam.  Essa metáfora indica que
	    você não tem que argumentar nem reclamar
	    sobre cada coisinha, só porque tem conhecimento o
	    bastante para critica-la.  Algumas pessoas dizem que a
	    quantidade de barulho provocada por uma
	    alteração é inversamente proporcional
	    à complexidade da mudança.</para>

	  <para>A resposta ainda mais completa, e maior, é que,
	    depois de muita discussão sobre quando o
	    &man.sleep.1; deveria trabalhar com argumentos de segundos
	    fracionados, &a.phk; enviou uma mensagem, longa, chamada
	    de <quote><ulink
		url="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">Um
		quarto de bicicleta (qualquer cor serve) em um gramado
		mais verde...</ulink></quote>.  As partes devidas da
	    mensagem estão citadas abaixo.</para>

	  <blockquote>
	    <attribution>&a.phk; na freebsd-hackers, em 2 de Outubro
	      de 1999</attribution>

	    <para><quote>O que é isso sobre a cor do quartinho
		da bicicleta?</quote> Alguns de vocês me
	      perguntaram.</para>

	    <para>É uma longa história, ou melhor,
	      é uma antiga história, mas pode ser meio
	      curta na verdade.  Um cara chamado C. Northcote
	      Parkinson escreveu um livro em meados de 1960 chamado de
	      <quote>A Lei de Parkinson</quote>, que continha
	      vários insights sobre as dinâmicas da
	      administração.</para>

	    <para>[trechos irrelevantes foram cortados]</para>

	    <para>Vamos deixar de falar sobre o livro em sí,
	      mas vamos tratar apenas um exemplo.  O exemplo
	      específico, do caso do quartinho da bicileta, tem
	      outro componente de vital importância, que
	      é uma usina nuclear.  Isso ilustra a época
	      que o livro foi escrito.</para>

	    <para>Parkinson mostra como você pode fazer para
	      chegar em um corpo de diretores de uma empresa e
	      convencê-los a construir uma usina atômica
	      multi-milhionária ou até mesmo
	      bilhionária, mas diz que se você abordar os
	      diretores da mesma forma, tentando aprovar a
	      construção de um quartinho de bicicleta,
	      você vai cair em uma discussão profunda, e
	      sem fim.</para>

	    <para>Parkinson explica que isso acontece porque uma usina
	      atômica é tão vasta, tão cara
	      e tão complicada que as pessoas simplesmente
	      preferem não discutir, e mesmo que tentem
	      fazê-lo, eles assumem que alguém já
	      observou todos os detalhes possíveis antes que
	      tal proposta chegasse à tal ponto.  Richard P.
	      Feunmann dá alguns exemplos interessantes, sobre
	      o que acontece em Los Alamos em seus livros.</para>

	    <para>Por outro lado, um barracão de bicicleta pode
	      ser construído por qualquer um, em um fim de
	      semana qualquer, e ainda sobraria tempo ao seu
	      desenvolvedor para assistir o jogo na TV.  Então,
	      não importa o quão bem preparado
	      você esteja, alguém vai sempre querer
	      aparecer diante de uma situação dessas, e
	      querer discutir as coisas mais pequenas
	      possíveis.  Na Dinamarca isso se chama
	      <quote>Deixar sua marquinha</quote>.  Envolve
	      prestígio e orgulho pessoal, envolve a
	      possibilidade de apontar para algum lugar (qualquer
	      lugar que seja) e apontar dizendo
	      <quote><emphasis>Aquilo!  Eu fiz
		  aquilo</emphasis></quote> (o que quer que aquilo
	      seja).  Isso é comum em políticos, mas
	      aparece em qualquer pessoa a quem se dê a chance.
	      Simplesmente pense em pegadas, no cimento
	      fresco.&quot;</para>
	  </blockquote>

	  <para>Na verdade, um &quot;quartinho de bicicletas&quot; ou
	    &quot;barracão de bicicletas&quot; é uma
	    tradução literal para a expressão
	    <quote>bikeshed</quote>; comumente utilizada na
	    língua inglesa.  Um <quote>bikeshed</quote>, no
	    significado definido pelo dicionário norte
	    americano é um pequeno quarto ou
	    barração não raramente encontrado no
	    fundo de uma casa, que é utilizado para guardar
	    bicicletas e outras coisas pequenas.  Normalmente os norte
	    americanos constroem esses quartinhos eles mesmos, de
	    madeira, no fundo de suas casas ou próximos
	    à garagem de automóveis.  A expressão
	    é normalmente utilizada pelos desenvolvedores do
	    FreeBSD quando se começa uma discussão sobre
	    algum assunto que não é tão
	    importante para o bom funcionamento de alguma outra coisa,
	    como por exemplo, qual a importância da cor de um
	    quartinho de bicicletas, quando o mesmo já
	    está construído e servindo bem ao seu
	    propósito?</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="funnies">
    <title>As gracinhas do FreeBSD</title>

    <qandaset>
      <qandaentry>
	<question id="very-very-cool">
	  <para>Quão fresco é o FreeBSD?</para>
	</question>

	<answer>
	  <para>P.  Alguém já fez algum tipo de teste de
	    temperatura ao rodar o FreeBSD?  Eu sei que o Linux
	    costuma ser mais fresco que o DOS, mas nunca ouvi falar
	    nada a respeito do FreeBSD.  Parece que ele é um
	    sistema muito
	    <emphasis><foreignphrase>caliente</foreignphrase></emphasis>!</para>

	  <para>R.  Não, mas nós já fizemos
	    vários testes de sabor com usuários vendados
	    que, além de tudo, haviam tomado 250 microgramas de
	    LSD-25.  35% dos voluntários disseram que o FreeBSD
	    tinha um sabor parecido com laranja, enquanto o Linux
	    tinha sabor de névoa púrpura.  Nenhum dos
	    dois grupos comentou nada significante sobre a
	    variação de temperatura.  Eventualmente,
	    tivemos que jogar o resultado desses testes fora,
	    já que descobrimos que vários desses
	    voluntários estavam vagando fora do quarto,
	    prejudicando os resultados.  Acreditamos que hoje, a
	    maioria desses voluntários trabalhe na Apple.  Eles
	    devem estar criando novas interfaces gráficas do
	    tipo <quote>arranha e cheira</quote>.  É um
	    trabalho divertido e clássico, do qual nós
	    fazemos parte!</para>

	  <para>Falando sério, o FreeBSD e o Linux usam as
	    instruções <acronym>HLT</acronym> (halt)
	    quando o sistema está inativo.  Isto diminui
	    consideravelmente o consumo de energia e,
	    conseq&uuml;entemente, o aquecimento que ele proporciona.
	    Além disso, se seu sistema possui APM (sistema
	    avançado de gerenciamento de energia) configurado,
	    o FreeBSD coloca a CPU em modo de consumo menor de
	    energia.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="letmeoutofhere">
	  <para>Quem está arranhando meus pentes de
	    memória??</para>
	</question>

	<answer>
	  <para>P.  Existe alguma <quote>bruxaria</quote> que o
	    FreeBSD faz ao compilar o
	    <foreignphrase>kernel</foreignphrase> que, por ventura,
	    estaria fazendo meus pentes de memória fazer
	    barulhos estranhos, como se estivessem sendo arranhados?
	    Durante a compilação do sistema (e um
	    pouquinho depois, assim que a unidade de disquete é
	    reconhecida, e após a inicialização
	    também), um barulho estranho de arranhos
	    começa a emanar de algum lugar que parece ser os
	    pentes de memória.</para>

	  <para>R.  Claro!  Com muita frequência, você vai
	    ouvir falar dos <quote>daemons</quote> na
	    documentação do BSD.  O que a maioria das
	    pessoas não sabem é que essa é uma
	    referência genuína às entidades
	    não-corporais que estão possuindo o seu
	    computador.  O barulho que parece o som de alguma coisa
	    sendo arranhada, na verdade são sussuros em tons
	    extremamente agudos que os <quote>daemônios</quote>
	    emanam, ao decidir entre si as melhores maneiras de tratar
	    as várias tarefas referentes à
	    administração do seu sistema.</para>

	  <para>Se o barulho te dominar, um bom <command>fdisk
	      /mbr</command> no DOS pode fazer você se livrar
	    dos sons, mas não se surpreenda se a
	    reação dos
	    <foreignphrase>daemons</foreignphrase> forem adversas, ao
	    tentar evitar que você faça isso.  Na
	    verdade, há qualquer momento, é
	    possível que você ouça a voz
	    satânica do Bill Gates pelo auto-falante interno do
	    seu PC.  Se isso acontecer, CORRA!  Corra sem parar e
	    não olhe para trás por qualquer que seja o
	    motivo!  Depois de se liberarem das influências
	    contrastantes dos <foreignphrase>daemons</foreignphrase>
	    BSD, os demônios gêmeos do DOS e do Windows
	    costumam ter sucesso ao repossuir total controle do seu
	    computador, e depois disso, o tempo garantirá que
	    eles consigam a dominação total da sua alma.
	    Agora que você já conhece a verdade,
	    esperamos que sua escolha seja conviver com os barulhinos
	    agudos.  Ou não?</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="changing-lightbulbs">
	  <para>Quantos FreeBSD <foreignphrase>hackers</foreignphrase>
	    são necessários para trocar uma
	    lâmpada?</para>
	</question>

	<answer>
	  <para>Mil cento e sessenta e nove:</para>

	  <para>Vinte e três para reclamarem no -CURRENT que
	    estão sem luz;</para>

	  <para>Quatro para dizer que é um problema na
	    configuração, e que essa pergunta deveria
	    ser feita na freebsd-questions;</para>

	  <para>Três para enviar Relatório de Problemas
	    sobre a lâmpada, dos quais ao menos um, não
	    está completamente concluído, e consiste
	    apenas de um breve <quote>tá escuro</quote>;</para>

	  <para>Um para adicionar uma lâmpada que nunca foi
	    testada, que danifica todo o <literal>buildworld
	    </literal> e depois de 5 minutos tem que ser
	    retirada;</para>

	  <para>Oito para reclamarem para os autores dos
	    Relatórios de Problemas por não ter
	    incluído correções em seus
	    relatórios;</para>

	  <para>Cinco para reclamar que o
	    <literal>buildworld</literal> não está
	    funcionando;</para>

	  <para>Trinta e um para responder que funciona para eles, e
	    que os problemáticos devem ter feito CVSup na hora
	    errada;</para>

	  <para>Um para enviar uma correção para a nova
	    lâmpada na freebsd-hackers;</para>

	  <para>Um para reclamar que ele tinha correções
	    para essa lâmpada há 3 anos, mas que quando
	    elas foram enviadas para o -CURRENT, foram simplesmente
	    ignoradas, e que sua experiência com o sistema de
	    Relatório de Problemas não foram as melhores
	    possíveis; além disso a nova lâmpada
	    proposta não era reflexiva;</para>

	  <para>Trinta e sete para gritarem em alto e bom som que as
	    lâmpadas não fazem parte da base do sistema,
	    e que os desenvolvedores não tem o direito de sair
	    fazendo esse tipo de coisa sem antes consultar a
	    comunidade, e O QUE O -CORE ESTA FAZENDO SOBRE
	    ISSO!?</para>

	  <para>Duzendos para reclamar da cor do quartinho de
	    bicicletas;</para>

	  <para>Três para dizer que a correção
	    enviada não está de acordo com os
	    padrões que o código do
	    <foreignphrase>kernel</foreignphrase> deve ter, conforme
	    documentado na página de manual do
	    &man.style.9;;</para>

	  <para>Dezessete para reclamar que a nova lâmpada
	    proposta está licenciada sob a Licença
	    Pública Geral GNU (GPL);</para>

	  <para>Quinhentos e oitenta e seis para entrarem de corpo e
	    alma em uma discussão sobre as vantagens
	    comparativas entre a licença Pública Geral
	    GNU (GPL), a licença BSD, a licença do MIT,
	    a NPL e a higiene pessoal dos fundadores da
	    <foreignphrase>Free Software
	      Foundation</foreignphrase>;</para>

	  <para>Sete para copiar vários trechos da
	    discussão para a lista de discussão
	    freebsd-chat e para a freebsd-advocacy;</para>

	  <para>Um para trocar a nova lâmpada sugerida, apesar
	    de a nova brilha bem menos que a antiga;</para>

	  <para>Dois para retirarem a lâmpada furiosos, dizendo
	    que o FreeBSD está melhor no escuro do que com uma
	    lâmpada tão fraca;</para>

	  <para>Quarenta e seis para contestarem vorazmente sobre a
	    retirada da lâmpada fraca e escreverem um
	    relatório para o -core;</para>

	  <para>Onze para dar a idéia de criar uma
	    lâmpada menorzinha, que poderia caber no Tamagotchi
	    deles, se um dia nós decidirmos portar o FreeBSD
	    para tal plataforma;</para>

	  <para>Setenta e três para reclamar da razão
	    sinal versus ruído na freebsd-chat e na
	    freebsd-hackers, e se retirarem das listas em
	    protesto;</para>

	  <para>Treze para enviarem mensagens com o conteúdo
	    "unsubscribe", "Como eu saio da lista?", ou "Por favor, me
	    tirem da lista", seguidas do rodapé tradicional do
	    servidor de discussão com as
	    instruções para sair da lista;</para>

	  <para>Um, para adicionar uma nova lâmpada que funciona
	    bem, enquanto todos os outros estão ocupados demais
	    com a discussão para perceber que alguém
	    já trocou a lâmpada por uma funcional;</para>

	  <para>Trinta e um para afirmar que a nova lâmpada
	    brilha em média 0.364% mais, se comparada com as
	    lâmpadas TenDRA (contudo, ela terá que ser
	    refeita em formato de cubo) e que o FreeBSD deveria mudar
	    para TenDRA ao invés do GCC;</para>

	  <para>Um para reclamar que a nova lâmpada não
	    é honesta;</para>

	  <para>Nove (incluindo aqueles que enviaram os
	    Relatórios de Problemas) para perguntar <quote>o
	      que significa MFC?</quote>;</para>

	  <para>Cinquenta e sete para reclamar que ficaram no escuro
	    por duas semanas até que a lâmpada fosse
	    trocada.</para>

	  <para><emphasis>Um adendo do &a.nik;:</emphasis></para>

	  <para><emphasis>Eu estava rindo um bocado
	      aqui.</emphasis></para>

	  <para><emphasis>Aí pensei, "Peraí, não
	      deveria ter ao menos  '1 para documentar a nova
	      lâmpada' em algum lugar?</emphasis></para>

	  <para><emphasis>Daí eu fui iluminado
	      :-)</emphasis></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dev-null">
	  <para>Para onde vão os dados que são escritos
	    no dispositivo <filename>/dev/null</filename> ?</para>
	</question>

	<answer>
	  <para>Esses dados são enviados para um dissipador
	    especial da CPU que os converte em calor, para que depois
	    sejam ventilados pelo <emphasis>cooler</emphasis> do
	    computador. É por isso que o esfriamento do
	    processador é cada vez mais importante; quanto mais
	    rápido os processadores se tornam, menos
	    importância os usuários dão à
	    seus dados, por isso cada vez mais lixo é enviado
	    para o <filename>/dev/null</filename>, gerando um
	    superaquecimento das CPUs.  Se o
	    <filename>/dev/null</filename> for apagado (dessa forma
	    desabilitando o dissipador de dados da CPU), o sistema vai
	    rodar a uma temperatura mais amena.  Contudo, o computador
	    vai manter tanto lixo inútil existente, que o
	    sistema vai logo começar a falhar.  Se você
	    tiver uma conexão de rede bem rápida,
	    dá para resfriar o computador lendo todos os dados
	    criados na <filename>/dev/random</filename> e enviando-os
	    para algum lugar da rede.  Contudo existe o risco de
	    superaquecer sua rede ou do Provedor de Serviço
	    Internet ficar meio bravo com você, já que
	    todo esse calor normalmente é recebido pelo
	    equipamento do provedor.  Mas não se preocupe, os
	    provedores tem grandes ventiladores para esfriar suas
	    máquinas, então se você não
	    insistir nisso com muita frequência, vai ficar tudo
	    bem.</para>

	  <para><emphasis>Adendo de Paul Robinson:</emphasis></para>

	  <para>Existem outros métodos.  Como todo bom
	    administrador de sistemas sabe, faz parte da
	    prática comum enviar dados das mais variadas
	    espécies para a tela.  Isto mantêm todos os
	    <foreignphrase>pixies</foreignphrase>
	    (<foreignphrase>pixie</foreignphrase> significa fadinhas
	    em inglês) de tela felizes.  Os
	    <foreignphrase>pixies</foreignphrase> de tela (normalmente
	    escritos com erro de ortografia, como 'pixels') são
	    divididos de acordo com o tipo de boné que eles
	    usam (vermelho, verde ou azul) e costumam aparecer ou
	    sumir (mostrando a cor de seus bonés) sempre que
	    eles ganham alguma coisinha para comer.  As placas de
	    vídeo transformam os dados em comida de
	    <foreignphrase>pixies</foreignphrase>, e manda essa comida
	    para eles.  Quanto mais cara for a placa de vídeo,
	    melhor é a qualidade da comida.  Dessa forma, mais
	    felizes ficam os <foreignphrase>pixies</foreignphrase>.
	    Os <foreignphrase>pixies</foreignphrase> também
	    precisam ser constantemente estimulados &ndash; é
	    para isso que existem as proteções de
	    telas.</para>

	  <para>Então, para seguir a sugestão anterior,
	    é interessante mandar todos os dados que
	    saírem do <filename>/dev/random</filename> para a
	    tela do console, para alimentar os
	    <foreignphrase>pixies</foreignphrase>.  Isso não
	    causa nenhum aquecimento do computador, e em
	    contrapartida, faz os
	    <foreignphrase>pixies</foreignphrase> viverem mais
	    felizes, e ainda pode ser que faça você se
	    livrar rapidamente de todos os dados existentes no
	    <filename>/dev/random</filename>, mesmo considerando que a
	    tela fique um pouco confusa.</para>

	  <para>Como um ex-administrador de um provedor que teve
	    algumas más experiências tentando manter a
	    estabilidade da temperatura da sala dos servidores, eu
	    recomendo sinceramente que as pessoas não tentem
	    enviar todos os seus dados para a rede.  Existem umas
	    pequenas fadinhas encantadas que fazem a alternância
	    dos pacotes de redes, e que fazem o roteamento desses
	    mesmos pacotes.  Algumas vezes essas fadinhas ficam meio
	    revoltadas com os usuários malvados que ficam
	    mandando seus dados inúteis para a rede.</para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="advanced">
    <title>Tópicos Avançados</title>

    <qandaset>
      <qandaentry>
	<question id="learn-advanced">
	  <para>Como eu posso aprender mais sobre as
	    características internas do FreeBSD?</para>
	</question>

	<answer>
	  <para> Atualmente não há nenhum livro
	    específico sobre as características internas
	    do Sistema Operacional FreeBSD.  Contudo, a maior parte do
	    conhecimento genérico sobre UNIX pode ser aplicado
	    diretamente a ele.  Além disso existem livros
	    específicos para sistemas BSD cuja leitura é
	    recomendada.</para>

	  <para>Para uma lista, verifique a sessão de <ulink
	      url="../handbook/bibliography-osinternals.html">
	      bibliografia sobre características internas dos
	      sistemas operacionais</ulink> no
	    &a.ptbr.p.handbook;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="how-to-contribute">
	  <para>Como posso contribuir com o projeto FreeBSD?</para>
	</question>

	<answer>
	  <para>Por gentileza, consulte o artigo <ulink
	      url="../../articles/contributing/article.html">Contribuindo
	      com o Projeto FreeBSD</ulink> para obter algumas dicas
	    sobre o assunto.  Toda ajuda é mais que bem
	    vinda!</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="define-snap-release">
	  <para>O que são SNAPs e RELEASEs?</para>
	</question>

	<answer>
	  <para>Atualmente existem três séries
	    ativas/semi-ativas no <ulink
	      url="http://www.FreeBSD.org/cgi/cvsweb.cgi">Repositório
	      CVS</ulink> do projeto FreeBSD (a RELENG_2 que é
	    provavelmente alterada somente duas vezes ao ano, sendo
	    esta a razão de termos somente três
	    séries em desenvolvimento):</para>

	  <itemizedlist>
	    <listitem>
	      <para><literal>RELENG_2_2</literal>   ou
		<emphasis>2.2-STABLE</emphasis></para>
	    </listitem>

	    <listitem>
	      <para><literal>RELENG_3</literal>     ou
		<emphasis>3.X-STABLE</emphasis></para>
	    </listitem>

	    <listitem>
	      <para><literal>RELENG_4</literal>     ou
		<emphasis>4-STABLE</emphasis></para>
	    </listitem>

	    <listitem>
	      <para><literal>HEAD</literal>        ou
		<emphasis>-CURRENT</emphasis>    ou
		<emphasis>5.0-CURRENT</emphasis></para>
	    </listitem>

	  </itemizedlist>

	  <para><literal>HEAD</literal> não é um nome de
	    uma tag de série, como os outros dois; é
	    somente uma constante simbólica para
	    <quote><emphasis>o atual desenvolvimento corrente, mas
		não de série</emphasis></quote> a qual
	    nós simplesmente nos referimos como
	    <quote>-CURRENT</quote>.</para>

	  <para>Neste momento, a <quote>-CURRENT</quote> se refere ao
	    desenvolvimento atual do FreeBSD 5.0.  A série
	    <literal>4-STABLE</literal>, <symbol>RELENG_4</symbol>
	    originou-se da <quote>-CURRENT</quote> em Março de
	    2000.</para>

	  <para>A série <literal>2.2-STABLE</literal>,
	    <symbol>RELENG_2_2</symbol>, originou-se da
	    <quote>-CURRENT</quote> em Novembro de 1996, e foi
	    praticamente descontinuada.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="custrel">
	  <para>Como faço a minha própria
	    distribuição personalizada?</para>
	</question>

	<answer>
	  <para>Por gentileza, consulte o artigo sobre a <ulink
	      url="../../articles/releng/article.html">Engenharia de
	      Releases.</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="makeworld-clobbers">
	  <para>Por que o <command>make world</command> sobrescreve os
	    binários já instalados?</para>
	</question>

	<answer>
	  <para>Porque essa é a idéia geral sobre como
	    ele deve funcionar; como seu nome sugere, o <command>make
	      world</command> reconstrói todo o sistema
	    binário a partir do zero, garantindo que o
	    usuário tenha um ambiente limpo e consistente ao
	    final da operação (é por isso que o
	    processo demora tanto).</para>

	  <para>Se a variável de ambiente
	    <literal>DESTDIR</literal> estiver definida enquanto um
	    <command>make world</command> ou <command>make
	      installworld</command> estiver sendo executado, os
	    binários recém criados serão
	    distribuídos no diretório definido em
	    <literal>${DESTDIR}</literal>, criando no mesmo uma
	    réplica do conteúdo do / do sistema.
	    Algumas alterações aleatórias nas
	    bibliotecas compartilhadas podem ocasionar falhas na hora
	    de reconstruir o sistema com o <command>make
	      world</command>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="bus-speed-defaulted">
	  <para>Por que quando meu sistema inicializa, ele diz
	    <quote>(bus speed defaulted)</quote>?</para>
	</question>

	<answer>
	  <para>Os controladores SCSI Adaptec 1542 permitem que o
	    usuário defina a velocidade de acesso ao barramento
	    por meio de software.  Algumas versões mais antigas
	    deste dispositivo tentavam determinar automaticamente a
	    maior velocidade possível e tentavam ajustar sua
	    velocidade à esse limite máximo.
	    Descobriu-se contudo, que esse comportamento as vezes era
	    prejudicial, e fazia com que algumas máquinas
	    não funcionassem de forma adequada, por este motivo
	    essa característica agora vem desabilitada por
	    default, para ativá-la é necessário
	    definir a opção <symbol>TUNE_1542</symbol>
	    no <foreignphrase>kernel</foreignphrase> do FreeBSD.  Essa
	    opção, em sistemas onde ela se aplica,
	    provavelmente assegura que seus discos sejam acessados de
	    forma mais rápida e eficiente; contudo, em sistemas
	    onde o uso desse algoritmo é inviável, pode
	    resultar em perda de dados.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="ctm">
	  <para>Posso acompanhar a série -CURRENT mesmo tendo
	    acesso limitado à Internet?</para>
	</question>

	<answer>
	  <para>Sim, é possível acompanhar a
	    série de desenvolvimento <literal>sem
	      precisar</literal> baixar sempre todo o codigo fonte do
	    sistema, basta utilizar o <ulink
	      url="../handbook/synching.html#CTM">recurso de
	      CTM</ulink>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="split-240k">
	  <para>Como o FreeBSD foi dividido em arquivos de
	    240k?</para>
	</question>

	<answer>
	  <para>O comando split que acompanha as novas versões
	    dos sistemas BSD têm uma opção
	    <option>-b</option> que permite dividir os arquivos em
	    limites arbitrários de bytes.</para>

	  <para>Eis um exemplo tirado do
	    <filename>/usr/src/Makefile</filename>.</para>

<programlisting>bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)</programlisting>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="submitting-kernel-extensions">
	  <para>Eu escrevi uma extensão para o
	    <foreignphrase>kernel</foreignphrase>; a quem eu
	    envio?</para>
	</question>

	<answer>
	  <para>Por gentileza, consulte o artigo <quote><ulink
		url="../../articles/contributing/article.html">Contribuindo
		com o Projeto FreeBSD</ulink></quote> para obter mais
	    informações sobre como enviar código
	    fonte ao projeto.</para>
	  <para>E obrigado pelo seu interesse! :)</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="pnp-initialize">
	  <para>Como as placas Plug N Play ISA são detectadas e
	    inicializadas?</para>
	</question>

	<answer>
	  <para>Por: Frank Durda IV
	    <email>uhclem@nemesis.lonestar.org</email></para>

	  <para>Simplificando, existem poucas portas de E/S que todas
	    as placas PnP respondem quando o sistema indaga se algum
	    dispositivo está usando-a.  Então, quando a
	    rotina de procura do PnP começa, ele pergunta se
	    há alguma placa PnP presente, e todas as placas PnP
	    respondem com seus respectivos números de modelo
	    para uma leitura de E/S da mesma porta.  A rotina de
	    procura recebe então um sinal wired-OR
	    representando um <quote>sim</quote> à pergunta em
	    questão.  Ao menos um bit positivo constitui essa
	    resposta.  Então o código de procura
	    é capaz de fazer com que as placas com o modelo de
	    identificação (atribuído pela
	    Microsoft/Intel) inferior a X sejam colocados em modo
	    <quote>off-line</quote>.  Ele então irá
	    verificar se alguma placa respondeu a consulta.  Se a
	    resposta for <literal>0</literal> o sistema assume que
	    não há placas com
	    identificação acima de X.  Depois a rotina
	    de busca verifica se há alguma placa cujo ID
	    é inferior a <literal>X</literal>.  Se a resposta
	    for positiva, a rotina de busca sabe que ainda existem
	    placas identificadas com um valor menor que X.  Aí
	    a busca tenta identificar placas com ID superior à
	    X (limite / 4) e ordena que entrem em modo off-line.
	    Repete-se o ciclo de pesquisas e
	    identificações nessa forma
	    semi-binária até que um número
	    necessário de interações seja
	    concluído.  Ao final do processo o sistema
	    terá identificado todas as placas PnP presentes na
	    máquina em questão, com o número de
	    interações necessárias sempre menor
	    que 2&circ;64.</para>

	  <para>Os IDs (códigos de identificação)
	    são dois campos de 32-bits (portanto, 2&circ;64)
	    acrescidos de 8 bits que é o checksum
	    (verificação de consistência de
	    dados).  Os primeiros 32 bits identificam o fabricante da
	    placa.  Nenhum fabricante assume isso, mas podemos
	    perceber que diferentes tipos de placas do mesmo
	    fabricante costumam ter diferentes
	    identificações de 32-bit.  O motivo correto,
	    não se sabe, mas percebe-se que 32 bits exclusivos
	    para os fabricantes chega a ser um exagero.</para>

	  <para>Os últimos 32 bits é um número
	    serial que torna a identificação dessa placa
	    única.  O fabricante não pode nunca produzir
	    uma placa que tenha os 32 bits finais iguais, a não
	    ser que os 32 bits iniciais sejam distintos.  Dessa forma
	    é possível existir várias placas do
	    mesmo tipo e fabricante, e ainda assim todos os 64 bits
	    dessas placas serem únicos.</para>

	  <para>Os grupos de 32 bits nunca podem ser todos zero.  Isso
	    permite ao wired-OR identificar bits não nulos
	    durante a procura binária inicial.</para>

	  <para>Uma vez que o sistema tenha identificado todas as IDs
	    presentes, ele vai reativar cada placa, uma por vez (pela
	    mesma porta de E/S) e achar os recursos que cada uma
	    necessita, quais opções de
	    interrupções estão
	    disponíveis, etc.  Uma busca é feita em
	    todas as placas para obter estas
	    informações.</para>

	  <para>Tal informação é então
	    combinada com as informações encontradas nos
	    arquivos ECU, no sistema, ou então da MLB BIOS.  O
	    suporte da BIOS PnP e da ECU costuma ser sintética,
	    portanto os periféricos não são
	    exatamente PnP como é dito.  Contudo, ao examinar as
	    informações da da BIOS e da ECU, as rotinas
	    de busca podem identificar dispositivos ditos PnP e evitar
	    que eles requeiram recursos também
	    necessários por outros dispositivos, que por sua
	    vez não podem realocar tais valores
	    automaticamente.</para>

	  <para>Os dispositivos PnP são visitados mais uma vez
	    e recebem seus endereços de E/S, DMA, IRQ e
	    endereçamentos atribuídos na memória.
	    Os dispositivos permaneceram naquela ordem até a
	    próxima inicialização do sistema,
	    apesar de que nada impede que eles sejam movidos quando se
	    desejar.</para>

	  <para>Essa explicação é muito
	    simplista, mas provavelmente você entendeu a
	    idéia geral do comportamento PnP.</para>

	  <para>A Microsoft fez um exame sobre algumas das portas
	    primárias de status de impressoras para fazer PnP,
	    dentro da lógica que nenhuma placa poderia
	    decodificar aqueles endereços para os ciclos
	    opostos de E/S.  Eu encontrei uma placa genuína de
	    impressora IBM que enviou dados decodificados da porta de
	    status durante o começo do período da
	    proposta de revisão do PnP, mas a Microsoft
	    <quote>ficou brava</quote>.  Então eles resolveram
	    fazer um envio para a porta de status da impressora, de
	    forma a justar o endereço usado (naquele instante +
	    <literal>0x800</literal>) e uma terceira porta de E/S para
	    a leitura que tecnicamente pode ser localizada em qualquer
	    lugar entre <literal>0x200</literal> e
	    <literal>0x3ff</literal>.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="major-numbers">
	  <para>Vocês podem definir um número principal
	    para um driver de dispositivo que eu escrevi?</para>
	</question>

	<answer>

	  <para>Isso depende se você pretende tornar o driver
	    disponível para o público.  Se sim,
	    então por favor nos mande uma cópia do
	    código-fonte do driver, mais as devidas
	    modificações para o
	    <filename>files.i386</filename>, um exemplo do arquivo de
	    configuração, e os devidos códigos do
	    &man.MAKEDEV.8; para criar qualquer arquivo especial que
	    seu dispositivo precise.  Se você não pode,
	    ou está impedido por causa de
	    restrições de licença, então o
	    character major number 32 e o block major number 8
	    estão reservados especificadamente para este
	    propósito; por favor, use-os.  De qualquer maneira,
	    nós gostaríamos de obter maiores
	    informações sobre seu driver na
	    &a.hackers;.</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="alternate-directory-layout">
	  <para>E sobre políticas alternativas de layout de
	    diretórios?</para>
	</question>

	<answer>
	  <para>Em resposta a questão da política de
	    formatos alternativos para diretórios, o esquema
	    que está atualmente em uso está
	    imutável desde quando eu o escrevi em 1983.  Eu
	    escrevi aquela política para o FFS (fast
	    filesystem) original, e nunca o revisei.  Ele funciona bem
	    em evitar que os os grupos de cilindros sejam
	    completamente preenchidos.  Como muitos de vocês
	    notaram, ele funciona mediocremente para procura.  A
	    maioria dos sistemas de arquivos são criados
	    à partir de arquivos que foram criados por uma
	    primeira procura em profundidade (depth first search,
	    também conhecido como ftw).  Estes
	    diretórios acabam sendo distribuídos pelo
	    grupo de cilindros, criando assim um cenário
	    horrível em relação a futuras
	    primeiras buscas de profundidade.  Se pudéssemos
	    saber o número total de diretórios a serem
	    criados, a solução seria criar (total /
	    fs_ncg) por grupo de cilindros antes de movê-los.
	    Evidentemente, seria necessário criar um conjunto
	    de métodos heurísticos para adivinhar esse
	    número.  Mesmo usando um pequeno número
	    fixo, digamos 10, ele produziria um aumento na ordem de
	    magnitude.  Para diferenciar restaurações de
	    operações normais (quando o algoritmo atual
	    é provavelmente mais sensível), você
	    poderia usar o agrupamento acima de 10 se eles fossem
	    finalizados dentro de uma janela de dez segundos.  De
	    qualquer maneira, minha conclusão é que isso
	    é uma área pronta para
	    experimentações. </para>

	  <para>Kirk McKusick, Setembro de 1998</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="kernel-panic-troubleshooting">
	  <para>O que fazer com os dados que eu vejo quando tenho um
	    kernel panic?</para>
	</question>

	<answer>
	  <para><emphasis>[Esta seção foi
	      extraída de um e-mail escrito por &a.wpaul; na
	      <link linkend="mailing">freebsd-current</link> por
	      &a.des;, que arrumou alguns problemas de
	      impressão e adicionou os comentários entre
	      chaves]</emphasis></para>

	  <programlisting>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: Ben Rosengart
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org</programlisting>

	  <para><emphasis>Ben Rosengart posted the following panic
	      message]</emphasis></para>

	  <programlisting>&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</programlisting>

	  <para>[Quando] você vê uma mensagem como essa,
	    não é suficiente somente reproduzí-la
	    e enviá-la em um e-mail.  O valor do ponteiro de
	    instrução (instruction pointer) que eu
	    destaquei acima é muito importante; infelizmente,
	    ele também depende de configuração.
	    Em outras palavras, os valores variam de acordo com a
	    exata imagem do <foreignphrase>kernel</foreignphrase> que
	    você estiver usando.  Se você estiver usando
	    uma imagem GENERIC do
	    <foreignphrase>kernel</foreignphrase> de um dos
	    <foreignphrase>snapshots</foreignphrase>, então
	    é possível que alguém acompanhe a
	    função ofensiva, mas se você
	    está rodando um
	    <foreignphrase>kernel</foreignphrase> customizado
	    então só <emphasis>você</emphasis>
	    pode nos dizer aonde a falha ocorreu.</para>

	  <para>O que você deve fazer é isso:</para>

	  <procedure>
	    <step>
	      <para>Anote o valor do ponteiro de
		instrução.  Observe que o 0x8: parte do
		começo não é significante.  Nesse
		caso é o <literal>0xf0xxxxxx</literal> que
		nós queremos.</para>
	    </step>

	    <step>
	      <para>Quando o sistema reinicializar, faça o seguinte:

		<screen>&prompt.user; <userinput>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</userinput></screen>

		Onde <literal>f0xxxxxx</literal> é o valor do
		ponteiro de instrução.  As chances
		são que você não terá um
		resultado exato visto que os símbolos na tabela
		de símbolos do
		<foreignphrase>kernel</foreignphrase> são para
		os pontos de entrada (entry points) de
		funções e o endereço do ponteiro
		de instrução estarão em algum
		lugar dentro de uma função, não
		no começo.  Se você não receber um
		resultado exato, omita o último dígito
		do valor do ponteiro de instrução e
		tente novamente, ex:

		<screen>&prompt.user; <userinput>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</userinput></screen>

		Se isso não produz nenhum resultado, corte
		outro dígito.  Repita até que você
		tenha algum tipo de retorno.  O resultado será
		uma possível lista de funções que
		causaram o panic.  Isso é menos do que um
		mecanismo exato para rastreamento de um ponto de
		falha, mas é melhor que nada.</para>
	    </step>
	  </procedure>

	  <para>Eu vejo pessoas constantemente mostrando mensagens de
	    panic como essa, mas eu raramente vejo alguém
	    comparar o ponteiro de instrução com uma
	    função na tabela de símbolos do
	    <foreignphrase>kernel</foreignphrase>.</para>

	  <para>A melhor maneira de rastrear a causa de um panic
	    é guardar as mensagens de falha (crash dump), e
	    então usar o &man.gdb.1; para gerar um stack trace
	    da falha.</para>

	  <para>Em qualquer caso, o método que eu normalmente
	    uso é esse:</para>

	    <procedure>
	    <step>
	      <para>Definir um arquivo de configuração
		do <foreignphrase>kernel</foreignphrase>,
		opcionalmente adiconando a <literal>options
		  DDB</literal> se você acha que precisa do
		debugger do <foreignphrase>kernel</foreignphrase> para
		algo.  (Eu uso isso principalmente para ajustar
		breakpoints se eu suspeito que há uma
		condição de laço infinito
		(infinite loop ou algo do tipo).</para>
	    </step>

	    <step>
	      <para>Use <command>config -g
		  <replaceable>KERNELCONFIG</replaceable></command>
		configurar o diretório da
		construção.</para>
	    </step>

	    <step>
	      <para><command>cd /sys/compile/
		  <replaceable>KERNELCONFIG</replaceable>; make
		</command></para>
	    </step>

	    <step>
	      <para>Espere o <foreignphrase>kernel</foreignphrase>
		acabar de compilar.</para>
	    </step>

	    <step>
	      <para><command>make install</command></para>
	    </step>

	    <step>
	      <para>reboot</para>
	    </step>
	    </procedure>

	  <para>O processo do &man.make.1; terá
	    construído dois
	    <foreignphrase>kernels</foreignphrase>.
	    <filename>kernel</filename> e
	    <filename>kernel.debug</filename>.  O
	    <filename>kernel</filename> foi instalado como
	    <filename>/kernel</filename>, enquanto o
	    <filename>kernel.debug</filename> pode ser usado como
	    fonte símbolos de debug para o &man.gdb.1;.</para>

	  <para>Para ter certeza que você irá capturar o
	    crash dump, você precisa editar o
	    <filename>/etc/rc.conf</filename> e ajustar o
	    <literal>dumpdev</literal> para apontar para sua
	    partição swap.  Isso fará com que os
	    scripts &man.rc.8; usem o comando &man.dumpon.8; para
	    habilitar os crash dumps.  Você pode também
	    executar o &man.dumpon.8; manualmente.  Depois de um panic,
	    o crash dump pode ser recuperado usando o &man.savecore.8;;
	    se variavel <literal>dumpdev</literal> estiver definida no
	    <filename>/etc/rc.conf</filename>, os scripts &man.rc.8;
	    irão executar o &man.savecore.8; automaticamente e
	    colocar o crash dump em
	    <filename>/var/crash</filename>.</para>

	  <note>
	    <para>Os crash dumps do FreeBSD são geralmente do
	      mesmo tamanho da memória RAM física da sua
	      máquina.  Isto é, se você tem 64MB
	      de RAM, você terá um crash dump de 64MB.
	      Então você deve ter certeza que há
	      espaço suficiente em
	      <filename>/var/crash</filename> para alocar o dump.
	      Alternativamente, você executa o &man.savecore.8;
	      manualmente e pode fazê-lo recuperar o crash dump
	      para onde você tenha mais espaço.  É
	      possível limitar o tamanho do crash dump
	      utilizando a opção <literal>options
		MAXMEM=(foo)</literal> para ajustar a quantia de
	      memória que o
	      <foreignphrase>kernel</foreignphrase> irá usar
	      para algo um pouco mais sensível.  Por exemplo,
	      se você tem 128MB de RAM, você pode limitar
	      o uso de memória do
	      <foreignphrase>kernel</foreignphrase> para 16MB para que
	      o tamanho do seu crash dump tenha somente 16MB ao
	      invés de 128MB.</para>
	  </note>

	  <para>Uma vez que você recuperou o crash dump,
	    você pode ter um stack trace com o &man.gdb.1; como
	    segue:</para>

	  <screen>&prompt.user; <userinput>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</userinput>
<prompt>(gdb)</prompt> <userinput>where</userinput></screen>

	  <para>Note que há várias telas com
	    informações valiosas; seria ideal o uso do
	    &man.script.1; para capturar todas elas.  Usando a imagem
	    (unstripped) do <foreignphrase>kernel</foreignphrase> com
	    todos os símbolos de debug deve mostrar a linha
	    exata do código-fonte do
	    <foreignphrase>kernel</foreignphrase> onde o panic
	    ocorreu.  Geralmente é mais interessante ler o
	    stack trace de baixo para cima a fim de rastrear a exata
	    seq&uuml;ência de eventos que levaram ao crash.
	    Você também pode usar o &man.gdb.1; para
	    exibir os conteúdos de várias
	    variáveis ou estruturas a fim de examinar o estado
	    do sistema no instante do crash.</para>

	  <para>Agora, se você é realmente louco e tem um
	    segundo computador, você também pode
	    configurar o &man.gdb.1; para executar um debug remoto,
	    tanto que você pode usar o &man.gdb.1; em um sistema
	    para debugar o <foreignphrase>kernel</foreignphrase> em
	    outro sistema, incluindo o ajuste de breakpoints,
	    rastreamento passo-a-passo pelo código do
	    <foreignphrase>kernel</foreignphrase>, do mesmo modo que
	    você pode fazer com um programa do modo de
	    usuário normal.  Eu ainda não brinquei com
	    isso pois não tive a chance de configurar duas lado
	    a lado com o único propósito de
	    debugging.</para>


	  <para><emphasis>[Adendo de Bill: &quot;Eu esqueci de
	      mencionar uma coisa: se você tem DDB habilitado e
	      o <foreignphrase>kernel</foreignphrase> em modo de
	      debug, você pode forçar um panic (e um
	      crash dump) apenas digitando &acute;panic&acute; no
	      prompt do ddb.  Ele pode parar no debugger novamente
	      durante a fase de panic.  Se isso acontecer, digite
	      &acute;continue&acute; e ele finalizará o crash
	      dump.&quot;-ed]</emphasis></para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="dlsym-failure">
	  <para>Por que a dlsym() não funciona mais nos
	    executáveis ELF?</para>
	</question>

	<answer>
	  <para>A toolchain (cadeia de ferramentas) ELF não
	    faz, por padrão, os símbolos definidos em um
	    executável visível para o linkador
	    dinâmico (dynamic linker).  Conseq&uuml;entemente, a
	    procura em nomes obtidos de chamadas com a
	    <function>dlsym()</function> para <function>dlopen(NULL,
	      flags)</function>  irá falhar ao buscar tais
	    símbolos.</para>

	  <para>Se a intenção é usar a
	    <function>dlsym()</function> para buscar símbolos
	    que possam existir nos executáveis principais do
	    processo, é necessário linkar o programa com
	    a opção <option>-export-dynamic</option> com
	    o linker ELF (&man.ld.1;).</para>
	</answer>
      </qandaentry>

      <qandaentry>
	<question id="change-kernel-address-space">
	  <para>Como eu posso aumentar ou reduzir o espaço de
	    endereçamento disponível para o
	    <foreignphrase>kernel</foreignphrase>?</para>
	</question>

	<answer>
	  <para>Por padrão, o espaço de
	    endereçamento (address space) do
	    <foreignphrase>kernel</foreignphrase> é 256 MB no
	    FreeBSD 3.x e 1 GB no FreeBSD 4.x.  Em um servidor de rede
	    com tráfego intensivo (por exemplo, um servidor FTP
	    ou HTTP de muito tráfego) pode acontecer de, por
	    exemplo, 256MB de memória não ser o
	    suficiente.</para>

	  <para>Mas então, como aumentar esse espaço?
	    Existem duas formas.  Primeiro, é necessário
	    dizer ao <foreignphrase>kernel</foreignphrase> que ele
	    deve reservar uma grande quantidade de espaço em
	    memória para ele mesmo.  Segundo, considerando que
	    o <foreignphrase>kernel</foreignphrase> é carregado
	    no topo do espaço de endereçamento, é
	    preciso diminuir o endereço de forma que não
	    conflite com as páginas anteriores de
	    memória, e que no lugar disso, ele seja carregado
	    em seu novo local.</para>

	  <para>O primeiro objetivo é facilmente atingido
	    aumentando as definições de valores do
	    <literal>NKPDE</literal> no arquivo
	    <filename>src/sys/i386/include/pmap.h</filename>.  Aqui
	    está o arquivo, como deve ser, para 1GB de
	    endereço de memória:</para>

	  <programlisting>#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</programlisting>

	  <para>Para achar o valor correto de
	    <literal>NKPDE</literal>, divida o número desejado
	    (em megabytes) por quatro, então subtraia um para
	    máquinas mono processadas e dois para
	    máquinas com SMP.</para>

	  <para>Para atingir o segundo objetivo é
	    necessário descobrir o endereço correto de
	    carregamento.  Para isso basta subtrair o tamanho do
	    espaço de endereçamento desejado (em bytes)
	    de 0x100100000; o resultado é 0xc0100000 para um
	    endereço de espaço de 1 GB.  Ajuste
	    <symbol>LOAD_ADDRESS</symbol> em
	    <filename>src/sys/i386/conf/Makefile.i386</filename> para
	    esse valor, agora ajuste o contador de
	    posiçõo listada no inicio do
	    <filename>src/sys/i386/conf/kernel.script</filename> para
	    o mesmo valor, como a seguir:</para>

	  <programlisting>OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</programlisting>

	  <para>Agora recompile e reinstale seu
	    <foreignphrase>kernel</foreignphrase>.  Provavelmente
	    aparecerão problemas com o &man.ps.1; e com o
	    &man.top.1;, executar um <command>make world</command> deve
	    solucionar tais problemas (ou então, a
	    recompilação manual da
	    <filename>libkvm</filename>, do &man.ps.1; e do &man.top.1;,
	    depois de incluir o <filename>pmap.h</filename> alterado
	    em <filename>/usr/include/vm/</filename>.</para>

	  <para>OBS: o tamanho do espaço em memória do
	    <foreignphrase>kernel</foreignphrase> deve ser um
	    múltiplo de quatro megabytes.</para>

	  <para><emphasis>[Adendo por &a.dg;: Acho que o
	      endereço de espaço do
	      <foreignphrase>kernel</foreignphrase> precisa ser uma
	      potência de dois, mas eu não estou certo
	      disso.  O código do processo de
	      inicialização antigo costumava mexer com
	      os bits de endereço de alta ordem, o que
	      implicava em uma granularidade de
	      256MB]</emphasis></para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="acknowledgments">
    <title>Reconhecimentos</title>

    <blockquote>
      <attribution>Grupo Central (<literal>FreeBSD Core
	  Team</literal>)</attribution>

      <para>Se você encontrar algum problema no
	<literal>FAQ</literal> ou se desejar submeter uma nova
	entrada, por favor envie um e-mail para o &a.faq;.  Nós
	apreciamos o seu feedback e não podemos tornar este
	<literal>FAQ</literal> melhor sem a sua ajuda!</para>
    </blockquote>

    <variablelist>
      <varlistentry>
	<term>&a.jkh;</term>

	<listitem>
	  <para>Atualizações e ajustes ocasionais na
	    ordenação das informações do
	    <literal>FAQ</literal>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&a.dwhite;</term>

	<listitem>
	  <para>Pelos serviços prestados acima e além da
	    chamada do dever em freebsd-questions</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&a.joerg;</term>

	<listitem>
	  <para>Pelos serviços prestados acima e além da
	    chamada do dever na Usenet</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&a.wollman;</term>

	<listitem>
	  <para>Rede (<foreignphrase>networking</foreignphrase>) e
	    formatação</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Jim Lowe</term>

	<listitem>
	  <para>Informações sobre
	    <quote>Multicast</quote></para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&a.pds;</term>

	<listitem>
	  <para>Escravo de digitação mecânica do
	    <literal>FAQ</literal> FreeBSD</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>A Equipe FreeBSD</term>

	<listitem>
	  <para>Reclamações, rabujices e envio de
	    informações</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>E a todos os outros que nós nos esquecemos, nossas
      desculpas e obrigado do coração!</para>
  </chapter>
</book>
